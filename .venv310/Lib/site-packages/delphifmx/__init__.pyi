from typing import Any, Callable, ClassVar, Iterator, List

from typing import overload
import Column
import GridModel
import GridPanelLayout
import Selection
import TabControl
Application: Application
IDABORT: int
IDCANCEL: int
IDCLOSE: int
IDCONTINUE: int
IDHELP: int
IDIGNORE: int
IDNO: int
IDOK: int
IDRETRY: int
IDTRYAGAIN: int
IDYES: int
MB_ABORTRETRYIGNORE: int
MB_APPLMODAL: int
MB_DEFBUTTON1: int
MB_DEFBUTTON2: int
MB_DEFBUTTON3: int
MB_DEFBUTTON4: int
MB_HELP: int
MB_ICONASTERISK: int
MB_ICONERROR: int
MB_ICONEXCLAMATION: int
MB_ICONHAND: int
MB_ICONINFORMATION: int
MB_ICONQUESTION: int
MB_ICONSTOP: int
MB_ICONWARNING: int
MB_NOFOCUS: int
MB_OK: int
MB_OKCANCEL: int
MB_RETRYCANCEL: int
MB_SYSTEMMODAL: int
MB_TASKMODAL: int
MB_YESNO: int
MB_YESNOCANCEL: int
Screen: Screen
crAppStart: int
crArrow: int
crCross: int
crDefault: int
crDrag: int
crHSplit: int
crHandPoint: int
crHelp: int
crHourGlass: int
crIBeam: int
crMultiDrag: int
crNo: int
crNoDrop: int
crNone: int
crSQLWait: int
crSize: int
crSizeAll: int
crSizeNESW: int
crSizeNS: int
crSizeNWSE: int
crSizeWE: int
crUpArrow: int
crVSplit: int
fmCreate: int
fmOpenRead: int
fmOpenReadWrite: int
fmOpenWrite: int
fmShareCompat: int
fmShareDenyNone: int
fmShareDenyRead: int
fmShareDenyWrite: int
fmShareExclusive: int
ssAlt: str
ssCtrl: str
ssDouble: str
ssLeft: str
ssMiddle: str
ssRight: str
ssShift: str

class Action(CustomAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    AutoCheck: bool
    """bool: Controls whether the Checked property toggles when the action executes.
        AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
        If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client."""
    Checked: bool
    """bool: Indicates whether client controls and menu items appear checked.
        Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.
        
        Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
        Tip: Use the AutoCheck property to ensure that the action's Checked property toggles when the action executes."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    GroupIndex: int
    """int: Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
        The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
        When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.
        
        Note:  All actions in a group must be listed by the same action list."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnHint: Callable[[str,bool],None]
    """Callable[[str, bool], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    Text: str
    """str: Represents the caption of the action.
        Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action's clients.
        Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
        In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+<accelerator_letter> key combination.  To show a single ampersand & character in a Text property specify doubled ampersand && characters.  Notice that & and _ are seen and can be used only under Windows."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TAction.Create(AOwner: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ActionList(CustomActionList):
    """Maintains a list of actions that can be used by components such as controls, menu items, and tool buttons.
    Use Action lists to centralize the responses to user actions. Action list components maintain a list of actions that are available to the client controls in an application. You can add action list components to your form from the Standard page of the component palette. 
    TActionList lets you set up actions using the Action List editor. Double-click the action list to display the Action List editor, from which you can add, delete, and rearrange actions.
    TActionList extends the TCustomActionList class redeclaring the public
    Name, State, OnChange, OnExecute,
    OnStateChange, and OnUpdate properties and events with the published visibility; therefore, these properties and events  can be managed in the Object Inspector at design time. 
    
    Code Examples
    FMX.ActionsDemo Sample
    FMX.PhotoEditorDemo Sample"""
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Images: BaseImageList
    """BaseImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Name: str
    """str: Specifies the name of the component as referenced in code.
        Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as 'Button1', 'Button2', and so on.
        Use Name to refer to the component in code.
        
        Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExecute: Callable[[BasicAction,bool],None]
    """Callable[[BasicAction, bool], None]:"""
    OnStateChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdate: Callable[[BasicAction,bool],None]
    """Callable[[BasicAction, bool], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    State: ActionListState
    """ActionListState: Indicates whether the actions in the action list respond when the user triggers a client object. 
        State can be one of the constants defined in the TActionListState type: 
        asNormal, asSuspended, and asSuspendedEnabled."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class AdapterListView(StyledControl):
    __hash__: ClassVar[None] = ...
    Adapter: IListViewAdapter
    """IListViewAdapter: Object that handles all interactions between the list view control and its list view items."""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class AniIndicator(StyledControl):
    """Represents an animated spinning indicator used for illustrating an indefinite waiting time for application processes.
    Use a TAniIndicator in applications where you need to inform the user that a task that takes an indefinite amount of time is in progress. Enable or disable the spinning effect by controlling the state of the Enabled property (True or False). 
    An animated spinning indicator can be rendered as lines or as circles:
    
    You can also style TAniIndicator to be a Metropolis UI  indeterminate ring progress bar (Windows 8 style):
    
    For more information about the Metropolis UI indeterminate ring progress indicator, see Creating an Animated Indeterminate Progress Ring and Developing Metropolis UI Applications.
    
    Note:
    When a task with a definite amount of time or operations is in progress, we recommend that you use a TProgressBar to illustrate the progress."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Style: AniIndicatorStyle
    """AniIndicatorStyle: Specifies the way this animated indicator looks (either linear or circular).
        Use the Style property to specify how this animated indicator looks. You can set its look as a linear indicator (Linear) or a circular indicator (Circular). The following picture illustrates the two rendering modes.
        
        Enable or disable the rotating effect by setting the Enabled property to either True or False."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TAniIndicator.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TAniIndicator.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.StdCtrls.TAniIndicator.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class AppearanceListView(PresentedListView):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Items: AppearanceListViewItems
    """AppearanceListViewItems: Provides access to individual items in this list view component.
        Use the Items property in order to access each individual item stored in this list view component. The Items property is also used if you want to add items to the list view, in a programmatic manner. Otherwise, you would normally add the items automatically via LiveBindings."""
    OnItemClick: Callable[[Object,ListViewItem],None]
    """Callable[[Object, ListViewItem], None]:"""
    OnUpdateObjects: Callable[[Object,ListViewItem],None]
    """Callable[[Object, ListViewItem], None]:"""
    OnUpdatingObjects: Callable[[Object,ListViewItem,bool],None]
    """Callable[[Object, ListViewItem, bool], None]:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def BeginUpdate(self, *args, **kwargs) -> Any:
        """Marks the start of an update session of the control and its children.
        FMX.ListView.TAppearanceListView.BeginUpdate inherits from FMX.Controls.TControl.BeginUpdate. All content below this line refers to FMX.Controls.TControl.BeginUpdate.
        Marks the start of an update session of the control and its children. 
        It increases the value of the FUpdating semaphore. A call to BeginUpdate must be complemented by calls to EndUpdate after the update is finished.
        FUpdating is an internal semaphore used to mark the process of control updating. Painting of a control is disabled while FUpdating is higher than 0.
        
         See Also
        FMX.Controls.TControl.FUpdating
        FMX.Controls.TControl.EndUpdate
        FMX.Controls.TControl.IsUpdating"""
    def Create(self, AOwner: Component) -> None:
        """TAppearanceListView.Create(AOwner: Component) -> None
        Creates an instance of TAppearanceListView with the specified component as its owner."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TAppearanceListView."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Marks the end of an update session of the control and its children.
        FMX.ListView.TAppearanceListView.EndUpdate inherits from FMX.Controls.TControl.EndUpdate. All content below this line refers to FMX.Controls.TControl.EndUpdate.
        Marks the end of an update session of the control and its children.
        The update session must be started first by calling BeginUpdate.
        EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes.
        
         See Also
        FMX.Controls.TControl.FUpdating
        FMX.Controls.TControl.BeginUpdate
        FMX.Controls.TControl.IsUpdating
        FMX.Controls.TControl.Realign"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def Resize(self, *args, **kwargs) -> Any:
        """OnResize event dispatcher. 
        FMX.ListView.TAppearanceListView.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
        OnResize event dispatcher. 
        A control calls Resize when the dimensions of the control change.
        Derived classes can override the protected Resize method to implement specific responses to control resizing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Arc(Ellipse):
    """TArc defines 2D arcs. 
    TArc is drawn as part of TEllipse's contour. It inherits TControl and can be used in styles to construct controls.
    The TArc object is the part of the TEllipse's contour enclosed between radiuses with the StartAngle and EndAngle angles.
    To define the general size, shape, and position of TArc, use the ShapeRect bounding rectangle, the scaling factors specified by  Scale, the RotationCenter rotation axis, and the RotationAngle rotation angle of the TEllipse object.
    TArc draws the contour and fills the shape background with the Paint method. 
    The Paint method draws the TArc contour using the drawing pen having the Stroke property of the TArc object."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    EndAngle: float
    """float: Specifies the end angle for this arc object.
        The EndAngle end angle is measured clockwise from the StartAngle start angle. 
        Use EndAngle in conjunction with StartAngle to specify how to draw this arc."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    StartAngle: float
    """float: Specifies the start angle for this arc object.
        The StartAngle start angle is measured clockwise from the x-axis. 
        Use StartAngle in conjunction with EndAngle to specify how to draw this arc.
        Notice that FMX.Controls.TControl.RotationAngle rotates the x-axis."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TArc.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TArc.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ArcDial(StyledControl):
    """Represents a general-purpose knob-style rotating button.
    Use a TArcDial button in applications wherever you need to provide the user with a rotating button that resembles a knob. This arc dial control variates its Value in degrees, so if you want to use it as a linear control for varying the progress of a progress bar, for instance, you need to programmatically make a conversion from degrees to linear movement.
    
    Control whether this arc dial component displays the value or not using the FMX.StdCtrls.TArcDial.ShowValue property."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Frequency: float
    """float: Specifies the number of positions this arc dial advances with each move.
        Use the Frequency property to specify how many steps at once this arc dial advances (rotates) with each move. For instance, if you set Frequency to 10, then rotating the arc dial to either the left or the right produces an advancement of only 10 divisions at a time (0 degrees, 10 degrees, 20 degrees, and so on)."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowValue: bool
    """bool: Specifies whether this arc dial component displays a text with the current value.
        Use the ShowValue property to enable or disable the display of a text in the middle of this arc dial component that contains the current value (in degrees) of this arc dial component."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Tracking: bool
    """bool: Specifies whether thumb tracking is active or not."""
    Value: float
    """float: Specifies the value (in degrees) of this arc dial component.
        Read or write the Value property to get or set the value (in degrees) of this arc dial component. Use the ShowValue property to enable or disable the display of this value inside the surface of this arc dial component."""
    ValueRange: ValueRange
    """ValueRange: Provides access to the Value and  Frequency properties."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed and loads the control presentation.
        FMX.StdCtrls.TArcDial.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
        Responds after the last constructor has executed and loads the control presentation.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TArcDial.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TArcDial.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TArcDial.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TArcDial.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseDown event dispatcher. 
        FMX.StdCtrls.TArcDial.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
        OnMouseDown event dispatcher. 
        A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:
        
        Button determines which mouse button is pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
        Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TArcDial.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        OnMouseMove event dispatcher. 
        FMX.StdCtrls.TArcDial.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
        OnMouseMove event dispatcher. 
        As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control's visual representation:
        
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TArcDial.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseUp event dispatcher. 
        FMX.StdCtrls.TArcDial.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
        OnMouseUp event dispatcher. 
        A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 
        
        Button determines which mouse button was previously pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseBindScopeComponent(Component):
    """Base class for the binding scope component. TBaseBindScopeComponent is the ancestor for the TCustomBindScope component. TBaseBindScopeComponent provides functionality for adding scope mappings, getting scope members and values, returning the scope itself or the scope of a member. It also provides properties for accessing the binding expressions in this scope and the scope mappings."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TBaseBindScopeComponent.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.Components.TBaseBindScopeComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.Components.TBaseBindScopeComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseImageList(Component):
    """Wrapper for Delphi TBaseImageList"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Count: int
    """int:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BeginUpdate(self, *args, **kwargs) -> Any: ...
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Change(self, *args, **kwargs) -> Any: ...
    def EndUpdate(self, *args, **kwargs) -> Any: ...
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseLinkingBindSource(BaseBindScopeComponent):
    """Wrapper for Delphi TBaseLinkingBindSource"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseObjectBindSource(BaseLinkingBindSource):
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Specifies whether the bind source adapter is active. 
        Read Active to determine whether the bind source adapter is active. By default, the Active property is set to True.
        When Active is False, the bind source does not have an adapter or its adapter is not active. When Active is True, the bind source has an active adapter."""
    AutoActivate: bool
    """bool: Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation."""
    BOF: Any
    """bool: Indicates whether the bind source adapter is positioned in the first record.
        Read BOF (beginning of file) to determine if ItemIndex is located in the first record. If BOF is True, the bind source has an adapter and the active record is the first one. BOF is also True if there is no active record. BOF is False in all other cases."""
    CanModify: bool
    """bool: Specifies whether the bind source has permission to modify the data.
        Check CanModify to determine if data can be edited. When CanModify is set to True, the bind source can edit the data. When CanModify is set to False, the bind source cannot edit the data."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Editing: bool
    """bool: Indicates whether the data is in edit mode. 
        Read Editing to determine whether the bind source adapter can currently edit the data. If the Editing property is True, the data provided by the bind source adapter is in editing mode. Otherwise, it is False."""
    Eof: Any
    """bool: Indicates whether the bind source adapter is positioned in the last record. 
        Read Eof (end of file) to determine if ItemIndex is located in the last record. If Eof is True, the bind source has an adapter and the active record is the last one or there are no records. Eof is False if the ItemIndex is located in any other position."""
    InternalAdapter: BindSourceAdapter
    """BindSourceAdapter: Returns the internal adapter of the bind source. 
        The InternalAdapter property holds the internal adapter of the bind source. InternalAdapter uses the GetInternalAdapter method to return the internal adapter of the bind source.
        
        Note:  The GetInternalAdapter method always returns nil. Descendant classes must override this method to return the internal adapter."""
    ItemIndex: int
    """int: Specifies the index of the current record. 
        ItemIndex holds the index of the current record of the dataset the bind source adapter is currently on. The first item has the index 0, the second item has the index 1, and so on. If no item is selected, the value of ItemIndex is -1."""
    Members: Object
    """Object:"""
    OnCreateAdapter: Callable[[Object,BindSourceAdapter],None]
    """Callable[[Object, BindSourceAdapter], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyUpdates(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Cancel(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def CancelUpdates(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TBaseObjectBindSource.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.ObjectScope.TBaseObjectBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Delete(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.ObjectScope.TBaseObjectBindSource.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Edit(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def First(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetFormatLink(self, AFieldName: str) -> IEditFormatLink:
        """TBaseObjectBindSource.GetFormatLink(AFieldName: str) -> IEditFormatLink
        Embarcadero Technologies does not currently have any additional information."""
    def GetMember(self, AMemberName: str) -> Object:
        """TBaseObjectBindSource.GetMember(AMemberName: str) -> Object
        Returns the member for the given member name.
        Data.Bind.ObjectScope.TBaseObjectBindSource.GetMember inherits from Data.Bind.Components.TBaseBindScopeComponent.GetMember. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.GetMember.
        Returns the member for the given member name.
        The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.
        
        Tip: This member object or its properties may be referenced by bindings expressions."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Insert(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def IsRequired(self, AFieldName: str) -> bool:
        """TBaseObjectBindSource.IsRequired(AFieldName: str) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def IsValidChar(self, AFieldName: str, AChar) -> bool:
        """TBaseObjectBindSource.IsValidChar(AFieldName: str, AChar: unicodechr(str)) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def Last(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Locate(self, KeyFields: str, KeyValues: Value) -> bool:
        """TBaseObjectBindSource.Locate(KeyFields: str, KeyValues: Value) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def Lookup(self, KeyFields: str, KeyValues: Value, ResultFields: str) -> Value:
        """TBaseObjectBindSource.Lookup(KeyFields: str, KeyValues: Value, ResultFields: str) -> Value
        Embarcadero Technologies does not currently have any additional information."""
    def Next(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Post(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Prior(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Refresh(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseValueRange(Persistent):
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Frequency: float
    """float: The step of possible Value variations. 
        Value can be multiple of Frequency, Min, or Max. For example, if
        
        Min = 0.1
        Max = 2.1
        ViewportSize = 0
        Frequency = 1
        
        then Value can be:
        
        0.1
        1
        2
        2.1
        
        but it cannot be:
        
        Value = 1.1"""
    Max: float
    """float: Maximum permissible value of the floating-point Value range."""
    Min: float
    """float: Minimum permissible value of the floating-point Value range."""
    Value: float
    """float: A changeable floating-point parameter. 
        The TBaseValueRange class associates a floating-point number Value to its Min and Max ranges."""
    ViewportSize: float
    """float: Used by controls such as TScrollBar to define the thumb size. 
        Note that the effective maximum value of Value decreases according to Max - ViewportSize."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Equals(self, Obj: Object) -> bool:
        """TBaseValueRange.Equals(Obj: Object) -> bool
        Checks whether the current instance and the Obj parameter are equal.
        FMX.StdActns.TBaseValueRange.Equals inherits from System.TObject.Equals. All content below this line refers to System.TObject.Equals.
        Checks whether the current instance and the Obj parameter are equal.
        The function has one Obj parameter of the TObject type.
        By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 
        
        
        Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
        For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def Same(self, Obj: BaseValueRange) -> bool:
        """TBaseValueRange.Same(Obj: BaseValueRange) -> bool
        Checks whether the values of all properties of the current object are close to the values of the corresponding properties of the specified Obj object. 
        This function is similar to Equals, but it uses the SameValue function to compare values. That is, if between the values there is a difference that is less than the possible rounding error, then the SameValue function estimates the values as equal and Same returns True."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BasicAction(Component):
    """TBasicAction is the ancestor class for all action objects.
    TBasicAction introduces the fundamental behavior for an action. Descendants of TBasicAction add functionality for containment in an action list, for being categorized, and for specializing their behavior tailored to particular clients such as controls or menu items. Use TBasicAction if you want to create an action for an object that is neither a menu item nor a control."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TBasicAction.Create(AOwner: Component) -> None
        Instantiates and initializes a TBasicAction object.
        Applications do not need to instantiate TBasicAction directly. Actions are created automatically when you choose New Action in the Action List editor.
        If you want to create an action at run time, you should call the Create constructor of a FireMonkey action (FMX.ActnList.TAction) or VCL action (Vcl.ActnList.TAction), or any of their subclasses. The Create constructors assign a TActionList component to the ActionList property of the created action.
        Create calls the inherited constructor and then creates a list of clients of the created action."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of an instance of a TBasicAction object.
        You do not need to call the destructor for an action. An action is a component and is automatically destroyed by its owner, which was passed to the constructor when it is created. If you must destroy an action manually, call Free instead, which safely invokes the destructor."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TBasicAction.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TBasicAction.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Suspended(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def UpdateTarget(self, Target: Object) -> None:
        """TBasicAction.UpdateTarget(Target: Object) -> None
        Introduces an interface for a method of notifying a client when the action updates itself.
        UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BasicBindComponent(Component):
    """Wrapper for Delphi TBasicBindComponent"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BindComponentDelegate(ContainedBindComponent):
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BindingsList(CustomBindingsList):
    """Implements the bindings list component. TBindingsList is built on the TCustomBindingsList component and publishes additional properties that can be accessed from within the Object Inspector."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Methods: Methods
    """Methods: Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic."""
    OutputConverters: OutputConverters
    """OutputConverters: Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic."""
    Owner: Any
    """Returns the Component Owner"""
    PromptDeleteUnused: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseAppManager: bool
    """bool: Specifies whether the bindings list uses the global application manager for managed bindings."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BitmapTrackBar(TrackBar):
    """Represents a track bar similar to that implemented by TTrackBar.
    TBitmapTrackBar is not registered to the IDE, thus it cannot be dragged and dropped from the tool palette. You can manually instantiate such component, override the constructor, and create a track bar that can display bitmaps.
    TBitmapTrackBar is intended for component designers as a base component for other custom track bars.
    Use TTrackBar in applications, instead."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TBitmapTrackBar.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TBitmapTrackBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TBitmapTrackBar.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Bounds(Persistent):
    """Specifies the bounds for a control.
    TBounds is used in the Margins and Padding properties of TControl and its descendants. TBounds help define the relative position between components on a form, and between the edges of the form and the component. For example, when you set the left bound for a component to 10 pixels, the component will not come closer than 10 pixels to the edge of the container, or to another component on the left edge. The number of pixels by which two components are separated is the sum of the pixels of both components.
    You can define the amount of margin that should surround the component on the Top, Left, Bottom, or Right by changing the pixel value for the Margins and Padding  properties in the Object Inspector.
    Margins and Padding depend on the Align property. To see the effect, set the Margins property on a parent control and set the Align property for the child control to vaClient."""
    __hash__: ClassVar[None] = ...
    Bottom: float
    """float: Specifies the bottom edge of the margin.
        Use the Bottom property to set and get the bottom edge of the margin."""
    DefaultValue: RectF
    """RectF: Specifies the default value for the margins.
        DefaultValue is automatically set when creating the TBounds instance."""
    Left: float
    """float: Specifies the left edge of the margin.
        Use the Left property to set and get the left edge of the margin."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Rect: Any
    """Provides access to the rect of a control"""
    Right: float
    """float: Specifies the right edge of the margin.
        Use the Right property to set and get the right edge of the margin."""
    Top: float
    """float: Specifies the top edge of the margin.
        Use the Top property to set and get the top edge of the margin."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Create(self, ADefaultValue: RectF) -> None:
        """TBounds.Create(ADefaultValue: RectF) -> None
        Constructs a TBounds object and initializes its data before the object is first used."""
    def Empty(self, *args, **kwargs) -> Any:
        """Returns True if either the Width or Height of the Rect are empty, and False otherwise."""
    def Equals(self, Obj: Object) -> bool:
        """TBounds.Equals(Obj: Object) -> bool
        Checks whether the current instance and the Obj parameter are equal.
        FMX.Types.TBounds.Equals inherits from System.TObject.Equals. All content below this line refers to System.TObject.Equals.
        Checks whether the current instance and the Obj parameter are equal.
        The function has one Obj parameter of the TObject type.
        By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 
        
        
        Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
        For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def Height(self, *args, **kwargs) -> Any:
        """Returns the height of the Rect, as the difference between the Bottom and Top values."""
    def MarginEmpty(self, *args, **kwargs) -> Any:
        """Returns True when the Left, Right, Top, and Bottom properties are simultaneously 0."""
    def MarginRect(self, R: RectF) -> RectF:
        """TBounds.MarginRect(R: RectF) -> RectF
        Returns a rectangle defined by the current Rect property and the R parameter.
        The MarginRect function returns a rectangle calculated by adding the Left and Top values and subtracting the Right and Bottom values of the current Rect to or from the corresponding values of the R rectangle.
        For example, if the current Rect is (10, 20, 50, 30) and R is (20, 10, 40, 50), the result of MarginRect is (30, 30, -10, 20). See also Margins."""
    def PaddingRect(self, R: RectF) -> RectF:
        """TBounds.PaddingRect(R: RectF) -> RectF
        Returns a rectangle defined by the current Rect property and the R parameter.
        The PaddingRect function returns a rectangle calculated by adding the Left and Top values and subtracting the Right and Bottom values of the current Rect to or from the corresponding values of the specified R rectangle.
        For example, if the current Rect is (10, 20, 50, 30) and R is (20, 10, 40, 50), the result of PaddingRect is (30, 30, -10, 20). See also Padding."""
    def ToString(self, *args, **kwargs) -> Any:
        '''Returns a string containing the class name.
        FMX.Types.TBounds.ToString inherits from System.TObject.ToString. All content below this line refers to System.TObject.ToString.
        Returns a string containing the class name.
        By default, the ToString returns a string containing the class name of the instance that is being called. 
        For example, calling ToString on a TButton instance returns a string containing "TButton". 
        
        Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.'''
    def Width(self, *args, **kwargs) -> Any:
        """Returns the width of the Rect, as the difference between the Right and Left values."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BufferedFileStream(FileStream):
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AFileName: str, Mode: int, BufferSize: int) -> None:
        """TBufferedFileStream.Create(AFileName: str, Mode: int, BufferSize: int) -> None"""
    def Destroy(self, *args, **kwargs) -> Any: ...
    def FlushBuffer(self, *args, **kwargs) -> Any:
        """FlushBuffer writes buffered and not yet written data to the file."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TBufferedFileStream.Read(Buffer, Count: int) -> int"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """TBufferedFileStream.Seek(Offset: int, Origin: SeekOrigin) -> int"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TBufferedFileStream.Write(Buffer, Count: int) -> int"""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BufferedLayout(CustomBufferedLayout):
    """A layout is a container for other graphical objects.
    FMX.BufferedLayout.TCustomBufferedLayout inherits from FMX.Layouts.TLayout. All content below this line refers to FMX.Layouts.TLayout.
    A layout is a container for other graphical objects. 
    Use the layouts when you need to organize multiple graphical controls under the same parent.
    For instance, you can use these layouts when you need to create rich FireMonkey applications with many graphical controls that are grouped on the same layer. You can set the visibility of all the controls on a layout at once by affecting the visibility of the layout."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Button(CustomButton):
    """Represents a push button that contains a text caption.
    A TButton is a general-purpose push button for use in applications. Buttons can be enabled, disabled, pressed, and can respond to control keys such as ESCAPE and ENTER. These buttons can receive TAB focus.
    Buttons can have a modal result attached, which is useful if these buttons are the main validating controls for a dialog box, for instance OK -- save and close; Cancel -- quit, no save; and so on.
    The Text property can be used to define an accelerator key to a control."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Cancel: bool
    """bool: Determines whether the button's OnClick event handler executes when the ESCAPE key is pressed.
        If Cancel is True, the button's OnClick event handler executes when you press the ESCAPE key. Although an application can have more than one Cancel button, the form calls the OnClick event handler only for the first visible button in the tab order."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Default: bool
    """bool: Determines whether the button's OnClick event handler executes when the ENTER key is pressed.
        If Default is True, the button's OnClick event handler executes when the you press the ENTER key. Although an application can have more than one Default button, the form calls the OnClick event handler only for the first visible button in the tab order. Moreover, any button that has focus becomes the Default button temporarily; hence, if you select another button before pressing ENTER, the selected button's OnClick event handler executes instead."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IconTintColor: int
    """int: Allows you to apply a tint to a button icon. 
        This property is a value of the TAlphaColor type.
        
        Note: Some buttons might not have the tint support. In the Object Inspector, the IDE automatically displays/hides the IconTintColor property as appropriate when you change the button's StyleLookup property. Currently, the IconTintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms."""
    IconTintObject: IintedObject
    """IintedObject: Embarcadero Technologies does not currently have any additional information."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    ModalResult: int
    '''int: Determines whether and how the button closes its (modal) parent form.
        Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
        For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).'''
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RepeatClick: bool
    """bool: Specifies whether to automatically repeat the button click after a preset time.
        Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
        The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
        Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button's OnClick event."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TintColor: int
    """int: Allows you to apply a tint to a button component. 
        This property is a value of the TAlphaColor type.
        
        Note: Some buttons might not have the tint support. In the Object Inspector, the RAD Studio IDE automatically displays/hides the TintColor property when you change the button's StyleLookup property. Currently, the TintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms."""
    TintObject: IintedObject
    """IintedObject: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BytesStream(MemoryStream):
    """Wrapper for Delphi TBytesStream"""
    __hash__: ClassVar[None] = ...
    Bytes: tuple
    """tuple:"""
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, ABytes: tuple) -> None:
        """TBytesStream.Create(ABytes: tuple) -> None"""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Calendar(CustomCalendar):
    """Wrapper for Delphi TCalendar"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Date: float
    """float:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FirstDayOfWeek: CalDayOfWeek
    """CalDayOfWeek:"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDateSelected: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDayClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TodayDefault: bool
    """bool:"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    WeekNumbers: bool
    """bool:"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CalloutPanel(Panel):
    '''A container for extra information relevant to another item, with a visual indicator pointing to that item.
    A call-out often takes the form of a pull-quote, in which a particular snippet of text in a document is duplicated to attract attention: in a larger size, with a different typeface, in a colored box, with stylized quote marks, etc. With illustrations, boxed text will refer to different elements of interest, and each box will be drawn with extra lines that point to its element.
    Use TCalloutPanel to create a call-out for elements in the user interface. The call-out may be transient, like a heavy-duty tool tip.
    The default style is a TCalloutRectangle, a rectangle with a triangular "peak" on one of four sides. A custom style that is not a TCalloutRectangle at the root should contain one with the ResourceName "background", so that the size and position properties for the triangle can be applied. The bounds of the control includes that peak: the longer the peak, the shorter the rectangle, and vice versa.'''
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CalloutLength: float
    """float: The length of the visual element that points at the area of interest.
        By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer as an isosceles triangle on one of its sides. CalloutLength is the height of this triangle. 
        The triangle is included in the bounding rectangle ShapeRect of the TCalloutPanel object; therefore, the longer CalloutLength is, the smaller the height (or width) of the callout panel itself is, and vice versa. Keeping the bounding rectangle the same size while changing the length of the triangle CalloutLength requires changing the height or width of the callout panel TCalloutPanel itself, depending on which side the triangle appears."""
    CalloutOffset: float
    """float: The position of the callout pointer, relative to the center or edges of the side on which it appears.
        By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer--visual element that points at the area of interest--as an isosceles triangle on one of its sides. The CalloutPosition defines the side on which the triangle appears.
        CalloutOffset is the offset of the callout pointer implemented according to the following conditions:
        
        If CalloutOffset is zero, then the callout pointer is centered on the specified side.
        If CalloutOffset is positive, then the closest point to a corner of the callout pointer has the CalloutOffset offset on the following sides:
        Top--offset to the right from the upper-left corner.
        Left--offset to the bottom from the upper-left corner.
        Right--offset to the bottom from the upper-right corner.
        Bottom--offset to the right from the lower-left corner.
        If CalloutOffset is negative, then the closest point to a corner of the callout pointer has the CalloutOffset offset on the following sides:
        Top--offset to the left from the upper-right corner.
        Left--offset to the top from the lower-left corner.
        Right--offset to the top from the lower-right corner.
        Bottom--offset to the left from the lower-right corner."""
    CalloutPosition: CalloutPosition
    """CalloutPosition: Defines the side where the callout pointer appears.
        Set CalloutPosition to one of the Top, Left, Bottom, or Right constants predefined in TCalloutPosition to define the side on which the callout pointer should appear.
        By default, the callout pointer appears on the top side CalloutPosition = Top.  
        By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer--the visual element that points at the area of interest--as an isosceles triangle on one of its four sides."""
    CalloutRectangle: CalloutRectangle
    """CalloutRectangle: A reference to a TCalloutRectangle style object."""
    CalloutWidth: float
    """float: The width of the visual element that points at the area of interest.
        By default, TCalloutPanel uses TCalloutRectangle, which renders its callout pointer as an isosceles triangle on one of its sides. 
        CalloutWidth is the length of the base of the triangle."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCalloutPanel.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCalloutPanel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CalloutRectangle(Rectangle):
    '''A rectangle with a triangular "peak" on one of four sides, used primarily to render a TCalloutPanel.
    Because TCalloutRectangle inherits from TRectangle, TCalloutRectangle provides all the properties (Corners, CornerType, Sides, XRadius, YRadius, and others) and methods to define the shape of the rectangle itself.  
    A call-out often takes the form of a pull-quote, in which a particular snippet of text in a document is duplicated to attract attention: in a larger size, with a different typeface, in a colored box, with stylized quote marks, and so on. With illustrations, boxed text will refer to different elements of interest, and each box will be drawn with extra lines that point to its element.
    TCalloutRectangle is a rectangle with an isosceles triangle on one of its four sides, used to point at something else. The triangle is included in the bounding rectangle of the object: the longer its length, the shorter the rectangle shape will be, and vice versa. Keeping the rectangle the same size while changing the length of the triangle requires changing the height or width of the object, depending on which side the triangle appears.'''
    __hash__: ClassVar[None] = ...
    CalloutLength: float
    """float: The length of the callout pointer.
        TCalloutRectangle renders the callout pointer as an isosceles triangle on one of its sides. CalloutLength is the height of this triangle. The triangle is included in the bounding rectangle ShapeRect of the TCalloutRectangle object; therefore, the longer CalloutLength is, the smaller the height (or width) of the callout rectangle itself is, and vice versa. Keeping the bounding rectangle the same size while changing the length of the triangle CalloutLength requires changing the height or width of the callout rectangle TCalloutRectangle itself, depending on which side the triangle appears."""
    CalloutOffset: float
    """float: The position of the callout pointer, relative to the center or edges of the side on which it appears.
        TCalloutRectangle renders the callout pointer as an isosceles triangle on one of its sides. The CalloutPosition defines the side on which the triangle appears.
        CalloutOffset is the triangle offset implemented according to the following conditions:
        
        If CalloutOffset is zero, then the triangle is centered on the specified side.
        If CalloutOffset is positive, then the closest point of the callout pointer to a corner of the triangle has the CalloutOffset offset on the following sides:
        Top--offset to the right from the upper-left corner.
        Left--offset to the bottom from the upper-left corner.
        Right--offset to the bottom from the upper-right corner.
        Bottom--offset to the right from the lower-left corner.
        If CalloutOffset is negative, then the closest point of the callout pointer to a corner of the triangle has the CalloutOffset offset on the following sides:
        Top--offset to the left from the upper-right corner.
        Left--offset to the top from the lower-left corner.
        Right--offset to the top from the lower-right corner.
        Bottom--offset to the left from the lower-right corner."""
    CalloutPosition: CalloutPosition
    """CalloutPosition: Specifies the side of the rectangle where the callout pointer appears.
        TCalloutRectangle renders its callout pointer as an isosceles triangle on one of its four sides.
        Set CalloutPosition to one of the Top, Left, Bottom, or Right constants predefined in TCalloutPosition to define the side on which the callout pointer should appear.
        By default, the callout pointer appears on the top side CalloutPosition = Top."""
    CalloutWidth: float
    """float: The width of the callout pointer.
        TCalloutRectangle renders its callout pointer as an isosceles triangle on one of its sides. 
        CalloutWidth is the length of the base of the triangle."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCalloutRectangle.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TCalloutRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the object instance and frees its memory.
        FMX.Objects.TCalloutRectangle.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
        Destroys the object instance and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CameraComponent(FmxObject):
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Enables and disables the camera device. 
        Set the Active property to True to enable the camera device, and set Active to False to disable it."""
    AvailableCaptureSettings: tuple
    """tuple: Array with the available capture settings.
        You can use CaptureSettingPriority to set the criterion to sort the Array.
        Use the CaptureSetting property to set the capture data resolution.
        See the Quality property for further details."""
    CaptureSetting: VideoCaptureSetting
    """VideoCaptureSetting: Current frame capture configuration.
        Use the CaptureSetting property to set the capture data resolution from the available ones.
        See the Quality property for further details."""
    CaptureSettingPriority: VideoCaptureSettingPriority
    """VideoCaptureSettingPriority: Priority criterion for sorting the result of the available frame settings.
        See the Quality property for further details."""
    FlashMode: FlashMode
    """FlashMode: Embarcadero Technologies does not currently have any additional information."""
    FocusMode: FocusMode
    """FocusMode: Embarcadero Technologies does not currently have any additional information."""
    HasFlash: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    HasTorch: bool
    """bool: Indicates whether the camera device has torch. 
        Use the HasTorch property to see whether the camera device has torch."""
    Kind: CameraKind
    """CameraKind: Selects the kind of camera device: default, front, or back camera. 
        The Kind property can take one of three values enumerated by TCameraKind: Default, FrontCamera, and BackCamera.
        For example, to select the back camera of the CameraComponent1 TCameraComponent you can use the following line:
        
        
        Delphi: 
        
        CameraComponent1.Kind := TCameraKind.BackCamera;
        
        
        
        C++: 
        
        CameraComponent1->Kind = TCameraKind::BackCamera;"""
    OnSampleBufferReady: Callable[[Object,int],None]
    """Callable[[Object, int], None]:"""
    Quality: VideoCaptureQuality
    """VideoCaptureQuality: States the quality of the video capture. 
        The Quality property of type TVideoCaptureQuality can take one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        PhotoQuality
        
        
        
        The captured data has high-resolution photo quality.
        
        
        
        
        HighQuality
        
        
        
        The captured data has high resolution (depending on the device). 
        
        
        
        
        MediumQuality
        
        
        
        The captured data has medium resolution (depending on the device). 
        
        
        
        
        LowQuality
        
        
        
        The captured data has low resolution (depending on the device).
        
        
        
        
        CaptureSettings
        
        
        
        This option allows you to set a customized capture data resolution. 
        
        
        By default, Quality is set to CaptureSettings and it uses the best available camera quality (best resolution and best frame rate) prioritizing first the Resolution.
        For example, to change the Quality of the CameraComponent1 TCameraComponent to LowQuality, you can use the following line:
        
        
        Delphi: 
        
        CameraComponent1.Quality := TVideoCaptureQuality.LowQuality;
        
        
        
        C++: 
        
        CameraComponent1->Quality = TVideoCaptureQuality::LowQuality;
        
        
        Setting a Custom Quality Capture Setting
        By setting the Quality to TVideoCaptureQuality.CaptureSettings you can set a customized capture data resolution:
        
        Use the AvailableCaptureSettings property to see the Array with the different supported configurations.
        You can use CaptureSettingPriority to set the criterion to sort the Array of the AvailableCaptureSettings to prioritize Resolution or FrameRate when sorting the Array. See TVideoCaptureSettingPriority for further information.
        Use the CaptureSetting property to set the capture data resolution from the available ones.
        To set the best available capture settings prioritizing the frame rate, you could for example use the following:
        
        
        Delphi: 
        
        procedure TForm1.SetMaxFrameRateClick(Sender: TObject);
        var
          LSettings: TArray<TVideoCaptureSetting>;
        begin
          CameraComponent1.CaptureSettingPriority := TVideoCaptureSettingPriority.FrameRate;
          LSettings := CameraComponent1.AvailableCaptureSettings;
          CameraComponent1.CaptureSetting := LSettings[0];
        end;
        
        
        
        C++: 
        
        void __fastcall TForm1::SetMaxFrameRateClick(TObject *Sender)
        {
        \tDynamicArray<TVideoCaptureSetting> LSettings;
        \tCameraComponent1->CaptureSettingPriority = TVideoCaptureSettingPriority::FrameRate;
        \tLSettings = CameraComponent1->AvailableCaptureSettings;
        \tCameraComponent1->CaptureSetting = LSettings[0];
        }
        
        
        Note: When you set a specific CaptureSetting, the Quality property is automatically set to TVideoCaptureQuality.CaptureSettings."""
    TorchMode: TorchMode
    """TorchMode: Selects the different modes for the torch: on, off, or auto. 
        The TorchMode property can take one of three values enumerated by TTorchMode: ModeOff, ModeOn, and ModeAuto.
        For example, to turn on the torch of the CameraComponent1 TCameraComponent, you can use the following line:
        
        
        Delphi: 
        
        CameraComponent.TorchMode := TTorchMode.ModeOn;
        
        
        
        C++: 
        
        CameraComponent->TorchMode = TTorchMode::ModeOn;
        
        
        Use the HasTorch property to see whether the camera device has a torch."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCameraComponent.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Media.TCameraComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Media.TCameraComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetAvailableCaptureSettings(self, ACanvasClass: CanvasClass) -> tuple:
        """TCameraComponent.GetAvailableCaptureSettings(ACanvasClass: CanvasClass) -> tuple
        Returns an array of available video capture settings."""
    def GetCaptureSetting(self, *args, **kwargs) -> Any:
        """Getter of CaptureSetting."""
    def GetDefaultCanvasCaptureSettings(self, *args, **kwargs) -> Any:
        """It returns the available capture settings.
        
        Note: The returning array is sorted with the CaptureSettingPriority criteria."""
    def SampleBufferToBitmap(self, ABitmap: Bitmap, ASetSize: bool) -> None:
        """TCameraComponent.SampleBufferToBitmap(ABitmap: Bitmap, ASetSize: bool) -> None
        Displays the captured data on a bitmap. 
        The SampleBufferToBitmap method displays the captured video data on a bitmap.
        
        The ABitmap parameter is the bitmap where the image is displayed.
        The ASetSize parameter specifies whether the video samples are resized to fit the current size of ABitmap, or whether ABitmap is resized to the windows sizes."""
    def SetCaptureSetting(self, ASetting: VideoCaptureSetting) -> bool:
        """TCameraComponent.SetCaptureSetting(ASetting: VideoCaptureSetting) -> bool
        Setter of CaptureSetting."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CaretRectangle(Rectangle):
    """TCaretRectangle is a TRectangle descendant that can additionally hold caret (cursor) information."""
    __hash__: ClassVar[None] = ...
    Caret: CustomCaret
    """CustomCaret: Caret is a TCustomCaret that describes the caret of this TCaretRectangle."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCaretRectangle.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TCaretRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the object instance and frees its memory.
        FMX.Objects.TCaretRectangle.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
        Destroys the object instance and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def UpdateState(self, *args, **kwargs) -> Any:
        """Updates the state of this TCaretRectangle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CheckBox(PresentedTextControl):
    """Represents a FireMonkey styled check box that can be either on (selected) or off (cleared).
    TCheckBox represents a FireMonkey styled check box that can be either on (selected) or off (cleared). A TCheckBox component presents you an option. Select the box to turn on the option, or clear it to turn off the option.
    A FireMonkey TCheckBox control supports linking to a Boolean database field. The Boolean field can be null, so there are actually three states: True, False, Null. The TCheckBox control treats the Null state as False.
    The Text property can be used to define an accelerator key to a control. The accelerator key behavior for TCheckBox is to check and uncheck the box control."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool: Specifies whether the default state of this check box is selected or cleared.
        Set the IsChecked property to True in order to force this check box's default state to be selected. The check box becomes cleared once you click it again."""
    IsPressed: bool
    """bool: Reads the pressed state of this check box.
        The IsPressed read-only property is True when this check box is pressed, False otherwise."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCheckBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCheckBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def KeyDown(self, Key: int, KeyChar, Shift: ShiftState) -> None:
        """TCheckBox.KeyDown(Key: int, KeyChar: unicodechr(str), Shift: ShiftState) -> None
        Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
        FMX.StdCtrls.TCheckBox.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
        Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
        The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.PresentationProxy
        FMX.Presentation.Messages.TMessageSender.SendMessage
        FMX.Controls.Presentation.TKeyInfo
        FMX.Controls.TControl.KeyDown
        FMX.Forms.TCommonCustomForm.KeyDown
        FMX.Controls.Presentation.TPresentedControl.KeyUp"""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TCheckBox.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseDown event dispatcher. 
        FMX.StdCtrls.TCheckBox.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
        OnMouseDown event dispatcher. 
        A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:
        
        Button determines which mouse button is pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
        Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TCheckBox.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        OnMouseMove event dispatcher. 
        FMX.StdCtrls.TCheckBox.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
        OnMouseMove event dispatcher. 
        As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control's visual representation:
        
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TCheckBox.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseUp event dispatcher. 
        FMX.StdCtrls.TCheckBox.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
        OnMouseUp event dispatcher. 
        A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 
        
        Button determines which mouse button was previously pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TCheckBox.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        Sets a new Scene for the current control.
        FMX.StdCtrls.TCheckBox.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CheckColumn(Column):
    """Represents a column in a grid, whose cells show check boxes."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    @classmethod
    def CreateBitmap(cls, Model: GridModel, Checked: bool, EditorMode: bool) -> Bitmap:
        """TCheckColumn.CreateBitmap(Model: GridModel, Checked: bool, EditorMode: bool) -> Bitmap
        Creates a check box picture, which can be used to paint cells in the current column.
        Model defines the grid model used to handle data.
        Checked defines whether the rendered check box is checked.
        EditorMode determines whether the check box picture is created in edit mode or not."""
    def DefaultDrawCell(self, Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None:
        """TCheckColumn.DefaultDrawCell(Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None
        Draws the default cell background.
        FMX.Grid.TCheckColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
        Draws the default cell background.
        DefaultDrawCell receives the following parameters:
        
        Canvas is the canvas where DefaultDrawCell paints the cell background.
        Bounds indicates the cell boundaries.
        Row is the row number.
        Value is the cell value.
        State is the drawing state of the cell.
        DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.
        
         See Also
        FMX.Grid.TColumn.DrawCell
        FMX.Grid.TColumn.BeforeDrawing
        FMX.Grid.TColumn.AfterDrawing"""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def TryGetAsBoolean(self, Value: Value, BoolValue: bool) -> bool:
        """TCheckColumn.TryGetAsBoolean(Value: Value, BoolValue: bool) -> bool
        Tries to fill BoolValue with the specified value, and returns True on success or False if Value is not a boolean."""
    def ValueToString(self, Value: Value) -> str:
        """TCheckColumn.ValueToString(Value: Value) -> str
        Draws the value of the column cell.
        FMX.Grid.TCheckColumn.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
        Draws the value of the column cell.
        Each column type defines its own implementation of this method to convert TValue into string value."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Circle(Ellipse):
    """TCircle defines 2D circles. It inherits TControl and can be used in styles to construct controls.
    The following TCircle properties define the circle size and position:
    
    The bounding rectangle ShapeRect of TCircle defines the bounding square for the circle:
    The length of the bounding square sides equals to Min(Width, Height) of the ShapeRect bounding rectangle.
    The bounding square center coincides with the center of the bounding rectangle.
    The TCircle shape is inscribed into the obtained bounding square.
    You can use the Scale scaling factors of the TCircle object to proportionally scale circle coordinates along local coordinate axes. Scaling moves the circle and changes its size.
    You can use the rotation axis RotationCenter and rotation angle RotationAngle of the TCircle object to modify the circle shape and position.
    TCircle draws the contour and fills the shape background with the Paint method. 
    Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TCircle object."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Collection(Persistent):
    """TCollection is a container for TCollectionItem objects.
    Each TCollection holds a group of TCollectionItem descendants. TCollection maintains an index of the collection items in its Items array. The Count property contains the number of items in the collection. Use the Add and Delete methods to add items to the collection and delete items from the collection.
    Objects descended from TCollection can contain objects descended from TCollectionItem. Thus, for each TCollection descendant, there is a corresponding TCollectionItem descendant. 
    The following table lists some typical descendants of TCollection with the corresponding TCollectionItem descendant and the component that uses each pair:
    
    
    
    TCollection descendant
    
    TCollectionItem descendant
    
    Component
    
    
    
    TBitmapLinks
    
    
    
    TBitmapLink
    
    
    
    TCustomStyleObject
    
    
    
    
    TAggregates
    
    
    
    TAggregate
    
    
    
    TClientDataSet
    
    
    
    
    TCookieCollection
    
    
    
    TCookie
    
    
    
    TWebResponse
    
    
    
    
    TCoolBands
    
    
    
    TCoolBand
    
    
    
    TCoolBar
    
    
    
    
    TDBGridColumns
    
    
    
    TColumn
    
    
    
    TDBGrid
    
    
    
    
    TDependencies
    
    
    
    TDependency
    
    
    
    TService
    
    
    
    
    THeaderSections
    
    
    
    THeaderSection
    
    
    
    THeaderControl
    
    
    
    
    TListColumns
    
    
    
    TListColumn
    
    
    
    TListView
    
    
    
    
    TParams
    
    
    
    TParam
    
    
    
    many datasets
    
    
    
    
    TStatusPanels
    
    
    
    TStatusPanel
    
    
    
    TStatusBar
    
    
    The controls that use TCollection and TCollectionItem descendants have a published property that holds a collection. (For example, the Panels property of TStatusBar holds a TStatusPanels.) A standard property editor, referred to generically as the Collection editor, can be invoked from the Object Inspector to edit the items in the collection. 
    
    Note: When writing a TCollection descendant that is used by another control, be sure to override the protected GetOwner method of the collection so that the descendant class instances can appear in the Object Inspector.
    Note: TCollection has the TOwnedCollection descendant that maintains information about its owner. TOwnedCollection implements the GetOwner method. Therefore, classes derived from TOwnedCollection do not need to add anything in order to appear in the Object Inspector."""
    __hash__: ClassVar[None] = ...
    Capacity: int
    """int: Provides access to the internal TList.Capacity property.
        The Capacity property specifies the allocated size of the array of pointers maintained by the TList object. This value is set to the number of pointers the list will need to contain."""
    Count: Any
    """Returns the count of collection items"""
    ItemClass: CollectionItemClass
    """CollectionItemClass: Indicates the class to which the collection's items belong.
        ItemClass is the class (descended from TCollectionItem) to which the items in the collection belong. For example, in an instance of the TCollection descendant THeaderSections, the value of the ItemClass property is THeaderSection."""
    Items: Any
    """Returns an iterator over the collection items"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self) -> Any:
        """TCollection.Add()
        Adds a collection item to the collection"""
    def Assign(self, Source: Persistent) -> None:
        """TCollection.Assign(Source: Persistent) -> None
        Copies the contents of the Source collection to the current object.
        Use Assign to copy the contents of one TCollection instance to another. The Assign method deletes all items from the destination collection (the object where it is executed), then adds a copy of each item in the source collection's Items array.
        Source is another object (typically another collection) that contains the items that replace this collection's items."""
    def BeginUpdate(self) -> Any:
        """TCollection.BeginUpdate()
        Suspends screen repainting."""
    def Clear(self) -> Any:
        """TCollection.Clear()
        Clears all collection items"""
    def ClearAndResetID(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, ItemClass: CollectionItemClass) -> None:
        """TCollection.Create(ItemClass: CollectionItemClass) -> None
        Creates and initializes a collection.
        Call Create to instantiate a TCollection object at run time. Typically, TCollection descendants are created by a component that uses the collection to implement a property.
        ItemClass identifies the TCollectionItem descendants that must be used to represent the items in the collection. The Add method uses this class to create items of the appropriate type."""
    def Delete(self, Index) -> Any:
        """TCollection.Delete(Index)
        Deletes a single item from the collection."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the collection and each item in it.
        Destroy uses the Clear method to free each item referenced in the Items array, then destroys the collection itself."""
    def EndUpdate(self) -> Any:
        """TCollection.EndUpdate()
        Re-enables screen repainting."""
    def FindItemID(self, ID: int) -> CollectionItem:
        """TCollection.FindItemID(ID: int) -> CollectionItem
        Returns the item with the specified ID.
        The FindItemID method returns the item in the collection whose ID property is passed to it as a parameter. If no item has the specified ID, FindItemID returns nil (Delphi) or NULL (C++)."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TCollection enumerator.
        GetEnumerator returns a TCollectionEnumerator reference, which enumerates all items in the collection. 
        To do so, call the TCollectionEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetItem(self, Index: int) -> CollectionItem:
        """TCollection.GetItem(Index: int) -> CollectionItem
        Returns a specified item in the collection.
        GetItem is the protected read implementation of the Items property."""
    def GetNamePath(self, *args, **kwargs) -> Any:
        '''Returns a string used by the Object Inspector.
        If the collection has no owner, GetNamePath returns the name of the collection\'s actual (runtime) type. If the collection is owned, GetNamePath returns the owner\'s name followed, if applicable, by a dot and the name of the owner\'s property that holds the collection. For example, GetNamePath might return "TreeView1.Items".
        
        Note:  For a collection to have an owner, it must override the GetOwner method.'''
    def Insert(self, Index) -> Any:
        """TCollection.Insert(Index)
        Inserts a new collection item to the collection at the Index position"""
    def Owner(self, *args, **kwargs) -> Any:
        """Returns the Owner of the collection.
        Call Owner to obtain a reference to the object that owns this collection. Typically, the owner uses the collection to implement one of its properties."""
    def SetItem(self, Index: int, Value: CollectionItem) -> None:
        """TCollection.SetItem(Index: int, Value: CollectionItem) -> None
        Copies the properties of another item to a specified item in the collection.
        SetItem is the protected write implementation of the Items property. It calls the Assign method of the item specified by Index, so that the properties of the item specified by Value are copied to that item."""
    def Sort(self, AComparer) -> None:
        """TCollection.Sort(AComparer: IComparer<System.Classes.CollectionItem>) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorBox(Control):
    """Represents a rectangular-shaped color indicator.
    A TColorBox is a visual component represented as a rectangular-shaped optical indicator whose color can be changed programmatically by means of the Color property, or by attaching it to one of the following color selector components:
    
    TColorPanel
    TColorQuad"""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TColorBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TColorBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorButton(CustomButton):
    """Represents a standard button that displays a color instead of a standard caption.
    A TColorButton behaves like a standard TButton. It can even have a modal result, just like typical standard buttons. The only difference between a standard button and a TColorButton is that the latter does not display a standard text caption, but a color in a rectangle that fills almost completely the surface of the button."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TColorButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.Colors.TColorButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.Colors.TColorButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorComboBox(CustomColorComboBox):
    """Represents a combo box that allows you to select a color from a color palette.
    A TColorComboBox behaves like a standard TComboBox, with the difference that, when in drop-down mode, it displays a list of colors from the standard Delphi palette that you can select. The colors appear in the drop-down list as small colored squares, along with their names.
    
    
    Note: The number of colors in the color palette is more than can be concurrently shown in the TListBoxItem list box. You can use the scroll bar to scroll the items shown in the list box. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll colors using the mouse wheel. To enforce the scroll bar to be shown by default,  you can use the code like following:
    ColorComboBox1.ListBox.AniCalculations.AutoShowing := false;"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    DropDownCount: int
    """int: Specifies the maximum number of items displayed in the drop-down list.
        By default, the drop-down list displays 8 items that are visible without requiring the user to scroll. To make the drop-down list smaller or larger, specify a number smaller or larger than eight as the DropDownCount value.
        If the DropDownCount value is larger than the number of items, the drop-down list will be only large enough to display the existing items. If the DropDownCount value is smaller than the number of items, the drop-down list displays a scroll bar."""
    DropDownKind: DropDownKind
    """DropDownKind: Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
        The TDropDownKind type is also used in the TComboEdit, 
        TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ItemHeight: float
    """float: Specifies the height of the items from the drop-down list.
        Use ItemHeight to specify the height, in pixels, of the items in the combo box list."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the combo box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1."""
    ItemWidth: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ListBoxResource: str
    """str: Specifies the name of the resource object to which the drop-down list of the combo box is linked.
        Use ListBoxResource to specify the style for the drop-down list component of the combo box."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    Placement: Placement
    """Placement: Specifies the position of the list box relative to the combo box button.
        For example, if Placement is set to TPlacement.Right, the drop-down list is displayed to the right of the combo box."""
    PlacementRectangle: Bounds
    """Bounds: Specifies the position of the drop-down list of the combo box.
        Use PlacementRectangle to specify the coordinates of the placement rectangle. The drop-down list will be displayed with the upper-left corner in the lower-left corner of the placement rectangle. The origin is considered to be the upper-left corner of the combo box button."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorListBox(CustomListBox):
    """Represents a combo box that allows you to select an alpha color from a color spectrum.
    A TColorListBox behaves like a standard TListBox, but instead of standard text items, it displays a list of colors under the form of small colored squares, along with the color names.
    The TColorComboBox component also displays this kind of list when in drop-down mode."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AllowDrag: bool
    """bool: Allows the dragging of items inside the list.
        AllowDrag allows you to change the order of the list items by dragging them."""
    AlternatingRowBackground: bool
    """bool: Specifies whether consecutive items should have different backgrounds.
        Set AlternatingRowBackground to True so that the background of items alternates."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultItemStyles: ListBoxItemStyleDefaults
    """ListBoxItemStyleDefaults: Embarcadero Technologies does not currently have any additional information."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    GroupingKind: ListGroupingKind
    """ListGroupingKind: Embarcadero Technologies does not currently have any additional information."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ItemHeight: float
    """float: Specifies the height of the items from the list box.
        Use ItemHeight to specify the height, in pixels, of the items in the list box."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the list box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1.
        To get the actual item that is selected, use the Selected property."""
    ItemWidth: float
    """float: Specifies the width of the items in the list box.
        The default value is 0. If you set another value for ItemWidth, all the items will be re-dimensioned to that value and displayed on multiple columns."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragChange: Callable[[ListBoxItem,ListBoxItem,bool],None]
    """Callable[[ListBoxItem, ListBoxItem, bool], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnItemClick: Callable[[CustomListBox,ListBoxItem],None]
    """Callable[[CustomListBox, ListBoxItem], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TColorListBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TColorListBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TColorListBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorPanel(Control):
    """Represents a color selector component complete with alpha channel selection.
    A TColorPanel component is a color selector that displays a color spectrum represented as a THueTrackBar, an alpha channel track bar selector, and a color quad. These make the TColorPanel component a great color selector.
    A similar color selector can be found in the drop-down mode of the TComboColorBox component."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    ColorBox: ColorBox
    """ColorBox: Specifies the color box attached to this color panel component.
        A color box is a visual component represented as a rectangular-shaped optical indicator that changes color according to the color selected in this color panel component."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    UseAlpha: bool
    """bool: Specifies whether this color panel component will display the alpha channel track bar.
        Set the UseAlpha property to True to make this color panel component display the alpha channel (transparency) track bar. Set UseAlpha to False to use solid non-alpha colors.
        The default value for the UseAlpha property is True."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TColorPanel.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TColorPanel.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TColorPanel.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def OwnerObserves(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorPicker(Control):
    """Represents a color selector that displays the entire color spectrum.
    A TColorPicker component is a color selector that displays a color spectrum and lets you pick any color by moving a dot-style selector. TColorPicker can be attached to a TColorQuad component.
    
    
    
    Note: The TColorPicker (Delphi) example describes how to implement a color picker as shown in the image.
    See Also
    FMX.Colors.THueTrackBar
    FMX.Colors.TColorQuad
    TColorPicker (Delphi)"""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    ColorQuad: ColorQuad
    """ColorQuad: Specifies the TColorQuad component that is attached to this color picker.
        Specify a TColorQuad component that is attached to this TColorPicker. In this way, every time you change the Color in this color picker, the color quad component automatically updates to the color selected in the color picker, further allowing you to tweak the saturation and luminance.
        
        In the picture above, a 0.5 alpha channel TColorBox component was also attached to the TColorQuad for a complete color selection application."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Hue: float
    """float: Specifies the color, by hue, from this color picker.
        Hue variates from 0 to 1 and spans the entire color spectrum drawn on this color picker. Programmatically set Hue to a specific value, or visually move the hue selector of this color picker, at run time, to obtain the color in the Color property."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TColorPicker.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TColorPicker.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TColorPicker.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TColorPicker.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        FMX.Colors.TColorPicker.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorQuad(Control):
    """Represents a three-color gradient color selector.
    A TColorQuad component is a color selector that displays a color spectrum drawn as a three-color gradient (black, white, and a specified color) that lets you fine-tune your color selection. TColorQuad can be attached to a TColorPicker component."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Alpha: float
    """float: Specifies the alpha channel (transparency) to apply to the selected color.
        Change the Alpha property to a value in the range from 0 through 1 to set the alpha channel (transparency) for the selected color."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ColorBox: ColorBox
    """ColorBox: Specifies the color box attached to this color quad component.
        A color box is a visual component represented as a rectangular-shaped optical indicator that changes color according to the color selected in this color quad component."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Hue: float
    """float: Specifies the hue of the selected color, in HSL color coordinates.
        Set or read Hue in conjunction with Sat and Lum in order to change or obtain the color selected in this color quad component."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Lum: float
    """float: Specifies the luminance of the selected color, in HSL color coordinates.
        Set or read Lum in conjunction with Hue and Sat in order to change or obtain the color selected in this color quad component."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Sat: float
    """float: Specifies the saturation of the selected color, in HSL color coordinates.
        Set or read Sat in conjunction with Hue and Lum in order to change or obtain the color selected in this color quad component."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TColorQuad.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TColorQuad.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TColorQuad.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TColorQuad.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        FMX.Colors.TColorQuad.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Column(Control):
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    DefaultTextSettings: TextSettings
    """TextSettings: Default text settings."""
    EditorState: Column.TEditorState
    """Column.TEditorState: Specifies the current state of the cell editor."""
    EffectiveVisible: bool
    """bool: Indicates whether this column is visible (True) or not (False)."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Header: str
    """str: Specifies the string in the header cell of the column."""
    HorzAlign: TextAlign
    """TextAlign: Embarcadero Technologies does not currently have any additional information."""
    HorzAlignModified: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    InEditMode: bool
    """bool: Determines what column is in edit mode.
        This property is left for compatibility."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Layout: TextLayout
    """TextLayout: The current text layout that is used to draw text in cells."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Model: GridModel
    """GridModel: The reference to the data model of the parent control.
        Model is set when changing the parent control. If a current column does not belong to the TPresentedControl, or the model of PresentedControl does not belong to the TGridModel, then this property contains nil."""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    OriginalIndex: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    Padding: Bounds
    """Bounds: The padding of any cells in this column"""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    PresentedControl: PresentedControl
    """PresentedControl: The reference to the control using this column and the data model."""
    ReadOnly: bool
    """bool: Specifies whether the cells in this column can be edited or not.
        Set ReadOnly to True to specify that the content of the cells can only be read."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanEdit(self, *args, **kwargs) -> Any:
        """Returns True if the column can show a value editor or False otherwise."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Changed(self, *args, **kwargs) -> Any:
        """This method is called when the column changes, and it notifies the model about those changes."""
    def Create(self, AOwner: Component) -> None:
        """TColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def DefaultDrawCell(self, Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None:
        """TColumn.DefaultDrawCell(Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None
        Draws the default cell background.
        DefaultDrawCell receives the following parameters:
        
        Canvas is the canvas where DefaultDrawCell paints the cell background.
        Bounds indicates the cell boundaries.
        Row is the row number.
        Value is the cell value.
        State is the drawing state of the cell.
        DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Grid.TColumn.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def EditingCancelled(self, *args, **kwargs) -> Any:
        """This virtual method is called from the EditingDone method if the parameter is False and some changes are made.
        You can override this method in the heir, but you do not have to call it manually.
        This method is used to interact with the LiveBinding."""
    def EditingDone(self, InplaceEdit: Object, Value: Value, Accept: bool) -> bool:
        """TColumn.EditingDone(InplaceEdit: Object, Value: Value, Accept: bool) -> bool
        Called when the user finishes using the specified column editor (InplaceEdit) on a cell.
        Value contains the value defined with the column editor.
        If Accept is True, EditingDone changes the value of the cell to Value and returns True on success or False otherwise.
        If Accept is False, EditingDone always returns True."""
    def EditorModified(self, *args, **kwargs) -> Any:
        """This method should be performed in the cell editor to notify the grid about changes."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PostEditorValue(self, InplaceEdit: Object, Value: Value) -> bool:
        """TColumn.PostEditorValue(InplaceEdit: Object, Value: Value) -> bool
        Sends the MM_POST_EDITOR_VALUE message to the presentation.
        This method is used in LiveBinding."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def RectPlaceIntoBounds(self, Source: RectF, Bounds: RectF) -> RectF:
        """TColumn.RectPlaceIntoBounds(Source: RectF, Bounds: RectF) -> RectF
        Stretches and aligns the Source rectangle, preserving its rectangle proportions, to best fit into the Bounds rectangle.
        RectPlaceIntoBounds calls PlaceInto to best fit the Source rectangle, preserving its rectangle proportions, into the Bounds rectangle. RectPlaceIntoBounds uses the default alignment parameters of the current column to align the stretched rectangle in the Bounds rectangle.
        RectPlaceIntoBounds returns Source if any of the Bounds rectangle dimensions is zero."""
    def RefreshEditor(self, InplaceEdit: Object, Value: Value) -> bool:
        """TColumn.RefreshEditor(InplaceEdit: Object, Value: Value) -> bool
        Changes the value of the column editor (InplaceEdit) to the specified value, and returns True on success or False otherwise.
        This function may return False, for example, if the target column is read-only and the editor does not support read-only values, which prevents the editor from working."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def UpdateCell(self, ARow: int) -> None:
        """TColumn.UpdateCell(ARow: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ValidChar(self, KeyChar) -> bool:
        """TColumn.ValidChar(KeyChar: unicodechr(str)) -> bool
        Returns True if the specified character is a valid character for a cell of this column or False otherwise.
        For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid."""
    @classmethod
    def ValueIsEmpty(cls, Value: Value) -> bool:
        """TColumn.ValueIsEmpty(Value: Value) -> bool
        Determines that the specified value should not be displayed in the cell and stored in the caches."""
    def ValueToString(self, Value: Value) -> str:
        """TColumn.ValueToString(Value: Value) -> str
        Draws the value of the column cell.
        Each column type defines its own implementation of this method to convert TValue into string value."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ComboBox(CustomComboBox):
    """A TComboBox is a button with a list box attached to it.
    Click the button to display the list.
    You can select an item from the list and it will appear as the button's text. You cannot type text directly into the combo box button.
    To add items, right-click the combo box on the form and choose Add Item. This creates a new TListBoxItem object that appears in the Structure pane and can be edited individually.
    You can also manage the items in the combo box by double-clicking the combo box control in the Form Designer. This opens the Items Designer dialog where you can add, delete, and change the order of the items.
    
    Note: When a number of items in a control is more than can be concurrently shown in the TListBoxItem list box, then you can use the scroll bar to scroll the items shown in the list box. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll items using the mouse wheel. To enforce the scroll bar to be shown by default, you can use the code like following:
    ComboBox1.ListBox.AniCalculations.AutoShowing := false;
    In Windows 8 style applications, you can create a Windows 8 style combo box by setting the value Native for the property DropDownKind.  For more information, see Creating a Metropolis UI ComboBox."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    DropDownCount: int
    """int: Specifies the maximum number of items displayed in the drop-down list.
        By default, the drop-down list displays 8 items that are visible without requiring the user to scroll. To make the drop-down list smaller or larger, specify a number smaller or larger than eight as the DropDownCount value.
        If the DropDownCount value is larger than the number of items, the drop-down list will be only large enough to display the existing items. If the DropDownCount value is smaller than the number of items, the drop-down list displays a scroll bar."""
    DropDownKind: DropDownKind
    """DropDownKind: Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
        The TDropDownKind type is also used in the TComboEdit, 
        TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    ItemHeight: float
    """float: Specifies the height of the items from the drop-down list.
        Use ItemHeight to specify the height, in pixels, of the items in the combo box list."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the combo box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1."""
    ItemWidth: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Items: Strings
    """Strings: Specifies the items in the drop-down list.
        Use Items to get or set the list of items in the drop-down as strings.
        Use the ListItems property to access an item as a TListBoxItem object."""
    ListBoxResource: str
    """str: Specifies the name of the resource object to which the drop-down list of the combo box is linked.
        Use ListBoxResource to specify the style for the drop-down list component of the combo box."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    Placement: Placement
    """Placement: Specifies the position of the list box relative to the combo box button.
        For example, if Placement is set to TPlacement.Right, the drop-down list is displayed to the right of the combo box."""
    PlacementRectangle: Bounds
    """Bounds: Specifies the position of the drop-down list of the combo box.
        Use PlacementRectangle to specify the coordinates of the placement rectangle. The drop-down list will be displayed with the upper-left corner in the lower-left corner of the placement rectangle. The origin is considered to be the upper-left corner of the combo box button."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ComboColorBox(StyledControl):
    """Represents a combo box that allows you to select an alpha color from a color spectrum.
    A TComboColorBox behaves like a standard TComboBox, with the difference that, while in drop-down mode, it displays a color spectrum represented as a THueTrackBar, an alpha channel track bar, a color quad, a HEX color value edit box, and a color box. These make the TComboColorBox a great color selector."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: Any
    """Returns a integer with the color value"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    UseAlpha: bool
    """bool: Specifies whether this combo color box component will display the alpha channel track bar when in drop-down mode.
        Set the UseAlpha property to True to make this combo color box display the alpha channel (transparency) track bar, when it is in drop-down mode. Set UseAlpha to False to use solid non-alpha colors."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TComboColorBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TComboColorBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TComboColorBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DropDown(self, *args, **kwargs) -> Any:
        """Makes this combo color box expand its color selection display.
        Call DropDown in applications to make this combo color box expand its contents, allowing you to select a new color from the drop-down list."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ComboEdit(CustomComboEdit):
    """An edit box with a list of predefined choices.
    TComboEdit stores the predefined choices in its Items property, which can be edited at design time. 
    TComboEdit encapsulates TComboEditListBox, which is displayed in the drop-down box when the right arrow icon is clicked. Although the ListBox object is fully exposed, we recommend that you use Items to access the list of items."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Caret: CustomCaret
    """CustomCaret: Represents the caret of the control.
        Caret is of type TCaret."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    DropDownCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    DropDownKind: DropDownKind
    """DropDownKind: Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
        The TDropDownKind type is also used in the TComboEdit, 
        TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ItemHeight: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ItemIndex: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ItemWidth: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Items: Strings
    """Strings: Embarcadero Technologies does not currently have any additional information."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Determines the type of the virtual keyboard.
        Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
        Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).
        
        Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions."""
    KillFocusByReturn: bool
    """bool: Specifies whether to hide the virtual keyboard by clicking the Return key.
        When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard."""
    ListBoxResource: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTyping: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Determines whether you can change the text of this edit control.
        To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
        Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    """str: Contains the text displayed by this edit control.
        Use the Text property to read the text of this edit control or to specify a new string to be displayed."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ComboEditBase(CustomEdit):
    """The base class for edit boxes having a list of predefined choices.
    TComboEditBase extends TCustomEdit defining the DropDown method."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CloseDropDown(self, *args, **kwargs) -> Any:
        """Tries to close the drop-down list.
        CloseDropDown sends a PM_CLOSE_DROPDOWN message to the presentation layer through its presentation proxy."""
    def Create(self, AOwner: Component) -> None:
        """TComboEditBase.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.ComboEdit.TComboEditBase.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def DropDown(self, *args, **kwargs) -> Any:
        """Executes internally when the edit control is left-clicked.
        DropDown is overridden by edit controls that have pop-up windows that open and close when the edit control is left-clicked.
        If the pop-up window is open, then DropDown closes the pop-up window. Else, it opens it."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CommonCustomForm(FmxObject):
    """TCommonCustomForm represents the base class for all forms, whether they are 2D or 3D.
    TCommonCustomForm is the base class for all TCustomForm and TCustomForm3D, and all their derived objects such as TForm and TForm3D."""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Specifies whether the form has focus.
        Use Active to determine whether the form has focus. The Active form receives all keyboard input. If it has a title bar, it is drawn using the active colors specified by the operating system.
        If Active is True, the form has focus; if Active is False, the form does not have focus."""
    BiDiMode: BiDiMode
    """BiDiMode: Indicates the layout of this form when running under Middle Eastern versions of the operating system.
        Use BiDiMode to specify the bi-directional mode for the application. The bi-directional mode controls the direction in which text appears (left-to-right or right-to-left), the placement of vertical scroll bars, and the default alignment of text when the application runs in Middle Eastern locales."""
    Border: FormBorder
    """FormBorder: Embarcadero Technologies does not currently have any additional information."""
    BorderIcons: BorderIcons
    """BorderIcons: Specifies which icons appear on the title bar of the form.
        Use BorderIcons to get or set the icons that appear on the title bar of the form. BorderIcons can include any of the following TBorderIcons values:
        
        
        
        Value
        
        Meaning
        
        
        
        biSystemMenu
        
        
        
        The form has a Control menu (also known as a System menu).
        
        
        
        
        biMinimize
        
        
        
        The form has a Minimize button.
        
        
        
        
        biMaximize
        
        
        
        The form has a Maximize button.
        
        
        
        
        biHelp
        
        
        
        Has no effect in FireMonkey."""
    BorderStyle: FmxFormBorderStyle
    """FmxFormBorderStyle: Specifies the appearance and behavior of the form border.
        Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TFmxFormBorderStyle values:
        
        
        
        Value
        
        Meaning
        
        
        
        Single
        
        
        
        Not resizable; minimize/maximize menu
        
        
        
        
        None
        
        
        
        Not resizable; no visible border line
        
        
        
        
        Sizeable
        
        
        
        Standard resizable border
        
        
        
        
        ToolWindow
        
        
        
        Similar to Single, but with a smaller caption
        
        
        
        
        SizeToolWin
        
        
        
        Similar to Sizeable, but with a smaller caption
        
        
        Notes:
        
        In iOS applications, None makes your form run in fullscreen mode. With any other value, your iOS app shows the iOS status bar.
        In Android applications, the BorderStyle property does not control fullscreen display. Instead, you should set the theme property on the  Project > Options > Version Info  page of your Android project:
        Setting the theme = TitleBar means that your Android app includes a title or status bar.
        Setting the theme = NoTitleBar means that your Android app runs in fullscreen mode, without a title or status bar."""
    Bounds: Rect
    """Rect: Bounds of form - position and size."""
    BoundsF: RectF
    """RectF: Embarcadero Technologies does not currently have any additional information."""
    Caption: str
    """str: Specifies a text string that identifies the form to the user.
        Use Caption to specify the text string that labels the form, identifying it to the user."""
    Captured: IControl
    """IControl: Specifies the control that has captured the mouse. Captured is read-only."""
    ClientHeight: int
    """int: Specifies the height (in pixels) of the form's client area.
        Use ClientHeight to determine the height (in pixels) of the form's client area. The client area is the usable area inside the form's border, excluding the title bar, scroll bars, and so on.
        Set ClientHeight to change the height of the form's window based on the desired client area. To change the height of the form's window based on the total size of the window (including the border, menu, status bar and so on), use the Height property instead."""
    ClientWidth: int
    """int: Specifies the width (in pixels) of the form's client area.
        Use ClientWidth to determine the width (in pixels) of the form's client area. The client area is the usable area inside the form's border. Set ClientWidth to change the width of the form's window based on the desired client area. To change the width of the form's window based on the total size of the window (including the border, status bar, and so on), use the Width property instead."""
    Constraints: SizeConstraints
    """SizeConstraints: Embarcadero Technologies does not currently have any additional information."""
    Cursor: int
    """int: Specifies the mouse cursor that will be used on this form."""
    Designer: IDesignerHook
    """IDesignerHook: Specifies the designer interface for the form.
        The Designer property is used internally at design time. Never assign a value to this property. This is done automatically by the form designer. Only use this property when designing classes for use in the form designer, such as property editors and component editors."""
    Focused: IControl
    """IControl: Specifies the control that has the focus set on it."""
    FormFactor: FormFactor
    """FormFactor: Specifies the form factor for this FireMonkey form, that is, the TFormFactor properties: width, height, orientations, and devices."""
    FormFamily: str
    """str: Is a string property that specifies the form family this form is part of. 
        The logic can choose a different form as the main form depending on size, if an app has several forms with the same .FormFamily value as the app's main form."""
    FormState: FmxFormStates
    """FmxFormStates: Indicates transitional state information about the form.
        Read FormState to determine the state of the form. FormState indicates when the form is in various transitional states or when certain operations have occurred. The following table lists the values that can be included in a form's state:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        Recreating
        
        
        
        The form is recreating its handle and its window is being shown on the screen.
        
        
        
        
        Modal
        
        
        
        The form was created as a modal window."""
    FormStyle: FormStyle
    """FormStyle: Determines the form style.
        FormStyle is one of the Normal, Popup, or StayOnTop values defined in TFormStyle."""
    FullScreen: bool
    """bool: Indicates whether the form is in fullscreen mode.
        Use FullScreen to specify whether the form is in fullscreen mode."""
    Handle: WindowHandle
    """WindowHandle: Specifies the handle of this form."""
    Height: int
    """int: Specifies the vertical size of the form (in pixels).
        Use the Height property to read or change the height of the form."""
    Hovered: IControl
    """IControl: Identifies the control over which the mouse pointer is hovering.
        Used internally for mouse hovering-over purposes."""
    Left: int
    """int: Specifies the X coordinate of the upper-left corner of the form, relative to the screen.
        Use Left to locate the top of the form or reposition the form to a different X coordinate. The Left property, like the Top property, is the position of the form relative to its container (the screen), in pixels."""
    ModalResult: int
    '''int: Represents the return value of a form that is used as a modal dialog box.
        Use ModalResult to close the form when it is displayed modally.
        By default, ModalResult is mrNone. Set ModalResult to any nonzero value to close the form. The ModalResult value  becomes the return value of the ShowModal function called to display the form.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value  using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding simple buttons (Ok, No, or Yes). 
        
        Note: This property can be modified automatically setting corresponding ModalResult properties of controls in the modal form.'''
    OnActivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClose: Callable[[Object,CloseAction],None]
    """Callable[[Object, CloseAction], None]:"""
    OnCloseQuery: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnConstrainedResize: Callable[[Object,float,float,float,float],None]
    """Callable[[Object, float, float, float, float], None]:"""
    OnCreate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeactivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDestroy: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFocusChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnHide: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSaveState: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTap: Callable[[Object,PointF],None]
    """Callable[[Object, PointF], None]:"""
    OnTouch: Callable[[Object,tuple,TouchAction],None]
    """Callable[[Object, tuple, TouchAction], None]:"""
    OnVirtualKeyboardHidden: Callable[[Object,bool,Rect],None]
    """Callable[[Object, bool, Rect], None]:"""
    OnVirtualKeyboardShown: Callable[[Object,bool,Rect],None]
    """Callable[[Object, bool, Rect], None]:"""
    OriginalContainerSize: PointF
    """PointF: Embarcadero Technologies does not currently have any additional information."""
    Padding: Bounds
    """Bounds: Specifies the padding of the form. 
        The Padding of a form specifies how close, in pixels, the child of the form can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the form.
        The child of the form is repositioned and resized, if necessary, to fit the Padding."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    ParentForm: CommonCustomForm
    """CommonCustomForm: Specifies the parent form of this form.
        The ParentForm parent form must be an instance of a TCommonCustomForm descendant. ParentForm contains the parent component of the current TCommonCustomForm form. ParentForm is responsible for deleting the current TCommonCustomForm form.
        The value of ParentForm is set when you change the Parent property. If Parent is a form, then ParentForm is set to the value of Parent. Otherwise, ParentForm is set to the value of the form, to which the Parent belongs."""
    Position: FormPosition
    """FormPosition: Represents the size and placement of the form.
        Use Position to get or set the size and placement of the form. Position can have one of the following TFormPosition values:
        
        
        
        Value
        
        Meaning
        
        
        
        Designed
        
        
        
        The form appears positioned on the screen and with the same height and width as it had at design time.
        
        
        
        
        Default
        
        
        
        The form appears in a position on the screen and with a height and width determined by the operating system. Each time you run the application, the form moves slightly down and to the right. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
        On OS X, the default position for new windows is the upper-left corner of the screen.
        
        
        
        
        DefaultPosOnly
        
        
        
        The form displays with the size you created it at design time, but the operating system chooses its position on the screen. Each time you run the application, the form moves slightly down and to the right. When the form can no longer move down and to the right and keep the same size while remaining entirely visible on the screen, the form displays in the upper-left corner of the screen.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
        On OS X, the default position for new windows is the upper-left corner of the screen.
        
        
        
        
        DefaultSizeOnly
        
        
        
        The form appears in the position you left it at design time, but the operating system chooses its size. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        
        
        
        
        ScreenCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen.
        
        
        
        
        DesktopCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen. No adjustments are made for multi-monitor applications.
        
        
        
        
        MainFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the application's main form. No adjustments are made for multi-monitor applications. This position should only be used with secondary forms. If set for a main form, it acts like ScreenCenter.
        
        
        
        
        OwnerFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the owner form. If there is no owner form, this position acts like MainFormCenter.
        
        
        Note that, if Position is set to Default, DefaultPosOnly, or DefaultSizeOnly, and BorderStyle is set to None, the form will be positioned at (0,0)."""
    SaveState: FormSaveState
    """FormSaveState: Specifies the save state of the FireMonkey form.  
        The SaveState property is an instance of the TFormSaveState class, used to save the state of a form so this state can be restored once the application is restarted."""
    ShowFullScreenIcon: bool
    """bool: Indicates whether the Mac fullscreen icon is visible.
        Use ShowFullScreenIcon to specify whether the Mac fullscreen icon  or  is visible. 
        
        Note: ShowFullScreenIcon has no visible effect in Windows."""
    ShowHint: bool
    """bool: Determines whether help hints are enabled or disabled for first level child controls in the form.
        For more information about the rules for enabling hints for a control, see   Using Hints to Show Contextual Help in a FireMonkey Application.
         TCommonCustomForm.ShowHint is a Boolean property set as True by default. When you place a child control in the form, and set the  TControl.Hint property, the hint is displayed because the TControl.ParentShowHint is True by default.
        If the  TCommonCustomForm.ShowHint property of the form is set to False, the hint is not displayed in the child control.
        To show the hint for a control, even when the  TCommonCustomForm.ShowHint property of the form is set to False, set  TControl.ShowHint for the control to True."""
    StyleBook: StyleBook
    """StyleBook: Specifies the style book for this form. For more information on how to customize the looks of a FireMonkey application with styles, refer to the Customizing FireMonkey Applications with Styles help topic."""
    SystemStatusBar: FormSystemStatusBar
    """FormSystemStatusBar: System status bar settings on mobile platforms."""
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of the form, relative to the screen.
        Use Top to locate the top of the form or reposition the form to a different Y coordinate. The Top property, like the Left property, is the position of the form relative to its container (the screen), in pixels."""
    Touch: TouchManager
    """TouchManager: Embarcadero Technologies does not currently have any additional information."""
    Transparency: bool
    """bool: Indicates whether the form is transparent or not.
        Use Transparency to determine whether the form is displayed as a totally transparent one. However, note that in this situation, all the controls will not be transparent and will be displayed normally. Only the form's background will be set to a transparent state.
        If you set Transparency to True, the form will not display its title bar, nor its border. This means that you need to apply programmatic methods (involving setting of the Top and Left properties) to move the form on the screen surface."""
    Visible: bool
    """bool: Indicates whether the form is visible.
        Use Visible to determine whether the form is visible.
        If Visible is True, the form is visible unless it is completely obscured by other forms. If Visible is False, the form is not visible.
        The Show and ShowModal methods set Visible to True and bring the form to the front of all open windows."""
    Width: int
    """int: Specifies the horizontal size of the form (in pixels).
        Use the Width property to read or change the width of the form."""
    WindowState: WindowState
    """WindowState: Represents how the form appears on the screen.
        Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state.
        Possible values for the WindowState property are:
        
        wsMaximized
        wsMinimized
        wsNormal"""
    WindowStyle: WindowStyles
    """WindowStyles: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Activate(self, *args, **kwargs) -> Any:
        """Activation event dispatcher.
        The form component calls Activate when it gets the focus either because of a change in the active windows within an application or because of the application becoming active. Activate fires an OnActivate event."""
    def AddRecognizer(self, Recognizer: InteractiveGesture) -> None:
        """TCommonCustomForm.AddRecognizer(Recognizer: InteractiveGesture) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        FMX.Forms.TCommonCustomForm.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
        Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        FMX.Forms.TCommonCustomForm.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BeginUpdate(self, *args, **kwargs) -> Any:
        """Starts updating all the child controls in this form.
        BeginUpdate starts updating all the child controls placed on this form, thus speeding any operations you might perform on the form or on multiple children. BeginUpdate signals the beginning of an update operation and must be followed by EndUpdate when all the updates have been completed."""
    def BringToFront(self, *args, **kwargs) -> Any:
        """Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
        FMX.Forms.TCommonCustomForm.BringToFront inherits from FMX.Types.TFmxObject.BringToFront. All content below this line refers to FMX.Types.TFmxObject.BringToFront.
        Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
        You can call BringToFront at run time as in the following code snippet:
        
          Label1.BringToFront;
        
        or, at design time, by right-clicking the FMX visual control and selecting Control > Bring to Front from the pop-up menu."""
    def CanShow(self, *args, **kwargs) -> Any:
        """Retrieves whether the form is not visible.
        CanShow returns True if  Visible is False (when the form is not visible)."""
    def ClientRect(self, *args, **kwargs) -> Any:
        """Returns a TRectF with the coordinates of the client area. The width of the rectangle is the same as ClientWidth and the height of the rectangle is ClientHeight."""
    def ClientToScreen(self, AFormPoint: PointF) -> PointF:
        """TCommonCustomForm.ClientToScreen(AFormPoint: PointF) -> PointF
        Converts the given mouse coordinates to screen coordinates. The local coordinates on the surface of this form are given through the Point parameter."""
    def Close(self, *args, **kwargs) -> Any:
        """Closes the form and returns the close action that the form uses.
        Call Close to close a form.
        Attempts to close a form can be aborted by the CloseQuery event dispatcher or the OnCloseQuery event handler.
        
        Note: When the main form of the application closes, the application terminates."""
    def CloseModal(self, *args, **kwargs) -> Any:
        """Prepares a modal form for closing and returns the close action that the form uses.
        Do not call CloseModal in your application. CloseModal is used by the the FireMonkey framework when a modal form needs to be closed. CloseModal does not close the form by itself; it simply calls the registered close events and updates the ModalResult property."""
    def CloseQuery(self, *args, **kwargs) -> Any:
        """Close-attempt event dispatcher.
        CloseQuery is called automatically when an attempt is made to close the form. CloseQuery can allow the form to close by returning True, or prevent the form from closing by returning False.
        As implemented in TCommonCustomForm, CloseQuery calls the OnCloseQuery event handler, if it exists. If no such event handler exists, CloseQuery returns True."""
    def Create(self, AOwner: Component) -> None:
        """TCommonCustomForm.Create(AOwner: Component) -> None
        Creates and initializes this form.
        Create calls the inherited Create to create this form. Create
        retrieves the IFMXWindowService,  IFMXCursorService,  
        IFMXFullScreenWindowService, and
        IFMXWindowsTouchService services.  
        Create calls  InitializeNewForm to initialize such form parameters as bounds, width and height, border icons, style, border style, and client size for the form. 
        AOwner specifies the owner of this form. 
        An AOwner (usually the application) is responsible for freeing the created form.
        Most applications do not call this constructor, but rather instantiate a descendant of TForm that is defined in the forms designer. Forms added to an application at design time are created automatically."""
    def CreateChildFormList(self, Parent: FmxObject, List) -> None:
        """TCommonCustomForm.CreateChildFormList(Parent: FmxObject, List: List<FMX.Forms.TCommonCustomForm>) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def CreateNew(self, AOwner: Component, Dummy: int) -> None:
        """TCommonCustomForm.CreateNew(AOwner: Component, Dummy: int) -> None"""
    def Deactivate(self, *args, **kwargs) -> Any:
        """Deactivation event dispatcher.
        The form component calls Deactivate when it loses the focus either because of a change in the active windows within an application or because of the application becoming inactive. Deactivate fires an OnDeactivate event."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Forms.TCommonCustomForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DragDrop(self, Data: DragObject, Point: PointF) -> None:
        """TCommonCustomForm.DragDrop(Data: DragObject, Point: PointF) -> None
        Executes when you drop an object over the surface of this form.
        Override DragDrop to add additional code that executes when you drop an object over the surface of this form.
        The Data parameter is the object that was dropped onto this form. The Point parameter has the mouse coordinates where the object was dropped."""
    def DragEnter(self, Data: DragObject, Point: PointF) -> None:
        """TCommonCustomForm.DragEnter(Data: DragObject, Point: PointF) -> None
        Executes when you drag an object while entering the surface of this form.
        Override DragEnter to add additional code that executes when you enter the surface of this form while dragging an object.
        Data is the object being dragged.
        Point is the position of the mouse."""
    def DragLeave(self, *args, **kwargs) -> Any:
        """Executes when you drag an object while leaving the surface of this form.
        Override DragLeave to add additional code that executes when you leave the surface of this form while dragging an object."""
    def DragOver(self, Data: DragObject, Point: PointF, Operation: DragOperation) -> None:
        """TCommonCustomForm.DragOver(Data: DragObject, Point: PointF, Operation: DragOperation) -> None
        Executes when you drag an object over the surface of this form.
        Override DragOver to add additional code that executes when you drag an object over the surface of this form. DragOver sets the Accept parameter to True to indicate that you can drop the dragged object on this form. It sets Accept to False to indicate that you cannot drop the dragged object on this form.
        The Data parameter is the object being dragged. 
        Point indicates the current position of the mouse."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Ends updating all the child controls in this form.
        EndUpdate ends updating all the child controls placed on this form, finalizing any updates you might have performed on the form or on multiple children. EndUpdate signals the end of an update operation and must be preceded by BeginUpdate and by the updates themselves."""
    def EnterMenuLoop(self, *args, **kwargs) -> Any:
        """Starts the menu loop for the main menu bars that this form might contain.
        EnterMenuLoop iterates through all the child controls of this form and, if one of them is a TMenuBar, then starts its menu loop."""
    def GetBounds(self, *args, **kwargs) -> Any:
        """Bounds of form - position and size."""
    def GetBoundsF(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetRecognizers(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def HandleNeed(self, *args, **kwargs) -> Any: ...
    def HandleNeeded(self, *args, **kwargs) -> Any:
        """The HandleNeeded method requests the form to create its handle at this moment and all the resources associated to it."""
    def Hide(self, *args, **kwargs) -> Any:
        """Hides the form.
        Hide sets the Visible property to False."""
    def InitializeNewForm(self, *args, **kwargs) -> Any:
        """Performs several initializations required by this form.
        These initializations include bounds, width and height, border icons, border style, and client size for the form. InitializeNewForm is used by the form constructors."""
    def Invalidate(self, *args, **kwargs) -> Any:
        """Schedules a repaint of this form.
        Invalidate informs the form that its entire surface needs to be repainted. Calling Invalidate can prevent flicker caused by a series of partial repaints. There is no performance penalty for calling Invalidate multiple times before the form is actually repainted."""
    def IsHandleAllocated(self, *args, **kwargs) -> Any:
        """Returns true only if the handle is allocated."""
    def IsPopupForm(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information.\r
        Embarcadero Technologies does not currently have any additional information."""
    def KeyDown(self, Key: int, KeyChar, Shift: ShiftState) -> None:
        '''TCommonCustomForm.KeyDown(Key: int, KeyChar: unicodechr(str), Shift: ShiftState) -> None
        Executed when a key is pressed while this form has the input focus.
        In FireMonkey framework KeyDown is the main method to process pressing of keys in forms. KeyDown is executed each time a key is pressed, when this form has the input focus. KeyDown is used internally: to activate menus and actions and to treat TAB requests to cycle through the children controls of this form. Editors can use KeyDown to add symbols into a text being edited. 
        You can override KeyDown to provide additional key treating in subclasses.
        KeyDown has the following parameters:
        
        
        
        Parameters
        
        Descriptions
        
        
        
        Key
        
        
        
        Is the scan code of the pressed keyboard key or $0.
        The UITypes unit defines Virtual Keys providing symbolic constants for scan codes of keyboard keys.
        Physical scan codes of the same key can differ under different platforms (Windows or iOS). Under FireMonkey framework, platform-specific units (for example FMX.Platform.Mac.pas) should translate native (iOS for FMX.Platform.Mac.pas unit) scan codes to the corresponding Windows codes defined in the UITypes unit. As the result Key always has scan code values defined by vkXXXX constants in UITypes. For example, 
        
        vkReturn = $0D;  {  13 } corresponds to the RETURN keyboard key
        vkEscape = $1B;  {  27 } corresponds to the ESCAPE
        vkSpace  = $20;  {  32 } corresponds to the SPACE
        vkF2     = $71;  { 113 } corresponds to the F2 keyboard key
        Keys of digits and letters -- independently of the selected input language and case of alphabetic keys -- have values corresponding to the \'0\'..\'9\' and  \'A\'..\'Z\' symbols. For example, Key = vkP = $50 corresponds to the \'P\' keyboard key.
        If Key = $0, then KeyChar contains a pressed symbol according to the current keyboard\'s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and Input Method Editor (IME) state.  
        Combinations of the Key and Shift parameters can be translated to shortcut key combinations.    
        
        
        
        
        KeyChar
        
        
        
        Is the pressed character (digit) or #0.
        If a pressed key combination can be handled as a printable character or digit, then Key = 0 and KeyChar contains a pressed symbol according to the current keyboard\'s input language, keyboard mode (CAPS LOCK and NUM LOCK keys), keyboard Shift state, and IME state. Editors can use this symbol to add into a text being edited. 
        
        
        
        
        Shift
        
        
        
        Determines the state of the CTRL, ALT, SHIFT, and CMD (only for Mac) keys at the moment you press the key.
        
        
        
        KeyDown processes pressed keys according to the following algorithm: 
        
        KeyDown first calls the IsDialogKey with the same parameters as those specified for KeyDown. The IsDialog parameter returns True if KeyChar < \' \' or Shift is any of the CTRL, ALT or CMD keys. That is, if the KeyChar and Shift combination identifies some control combination -- not a printable character. Otherwise, it returns False. The \' \' character has the $20 ASCII value. ASCII values less than $20 identify control combinations.
        If IsDialogKey returns True in the IsDialog parameter, then the pressed key combination is passed, in the following order, to all child controls, menus and action lists in the form until this key combination is processed:
        To the control having focus.
        To the context menu of the control having focus.
        To all other menus and context menus in the form.
        To all other controls (not having focus) in the form.
        To action lists in the form and in all child components having assigned action list elements.
        To menus and action lists in all other forms.
        If the pressed key combination was processed during one of the previous steps, then KeyDown sets Key = 0 and KeyChar = #0 and terminates.
        If Key = vkTab, then KeyDown moves the focus to the next control in the controls "tab order" and terminates.
        If Key <> 0 or KeyChar <> #0, then KeyDown calls the KeyDown method of the control having focus and then calls the OnKeyDown event handler of the form if one is assigned.
        In the finally block, KeyDown stores the current date and time in the LastKeyPress and LastUserActive properties of the current application.'''
    def KeyUp(self, Key: int, KeyChar, Shift: ShiftState) -> None:
        """TCommonCustomForm.KeyUp(Key: int, KeyChar: unicodechr(str), Shift: ShiftState) -> None
        Is executed each time when a key is released while this form has the input focus.
        First, KeyUp calls the OnKeyUp event handler (if one is defined) of the control having input focus, then KeyUp calls the OnKeyUp event handler. In the finally block, KeyUp stores the current date and time in the LastKeyPress and LastUserActive properties of the current application.
        KeyUp has the following parameters:
        
        Key is the scan code of the pressed keyboard key. The UITypes unit defines Virtual Keys providing symbolic constants for scan codes of keyboard keys.
        KeyChar is the character representation of the pressed key.
        Shift determines the state of the CTRL, ALT, SHIFT, and CMD (only for Mac) keys at the moment you press the key.
        You can override KeyUp to provide additional ways to handle keys in subclasses."""
    def LoadProps(self) -> Any:
        """TCommonCustomForm.LoadProps()
        Load properties from a .pydfm file"""
    def MouseCapture(self, *args, **kwargs) -> Any:
        """Sets the mouse capture to this window, which belongs to the current thread."""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, AFormX: float, AFormY: float) -> None:
        """TCommonCustomForm.MouseDown(Button: MouseButton, Shift: ShiftState, AFormX: float, AFormY: float) -> None
        Executes each time you press a mouse button.
        MouseDown has the following parameters:
        
        Button specifies the mouse button that has been pressed.
        Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you press the mouse button.
        X specifies the horizontal position of the mouse.
        Y specifies the vertical position of the mouse."""
    def MouseLeave(self, *args, **kwargs) -> Any:
        """Executes each time the mouse leaves the surface of this form."""
    def MouseMove(self, Shift: ShiftState, AFormX: float, AFormY: float) -> None:
        """TCommonCustomForm.MouseMove(Shift: ShiftState, AFormX: float, AFormY: float) -> None
        Executes each time you move the mouse over the surface of this form.
        MouseMove has the following parameters:
        
        Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
        X specifies the horizontal position of the mouse.
        Y specifies the vertical position of the mouse."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, AFormX: float, AFormY: float, DoClick: bool) -> None:
        """TCommonCustomForm.MouseUp(Button: MouseButton, Shift: ShiftState, AFormX: float, AFormY: float, DoClick: bool) -> None
        Executes each time you release a mouse button.
        MouseUp has the following parameters:
        
        Button specifies the mouse button that has been released.
        Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
        X specifies the horizontal position of the mouse.
        Y specifies the vertical position of the mouse."""
    def MouseWheel(self, Shift: ShiftState, WheelDelta: int, Handled: bool) -> None:
        """TCommonCustomForm.MouseWheel(Shift: ShiftState, WheelDelta: int, Handled: bool) -> None
        Executes each time you roll the mouse wheel.
        MouseWheel has the following parameters:
        
        Shift determines the state of the CTRL, ALT, and SHIFT keys at the moment you released the mouse button.
        WheelDelta indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, and negative if the mouse was rotated downward.
        Handled specifies whether this form handles the mouse wheel, or other child controls do this."""
    def ObjectAtPoint(self, AScreenPoint: PointF) -> IControl:
        """TCommonCustomForm.ObjectAtPoint(AScreenPoint: PointF) -> IControl
        Returns the object located at the given coordinates.
        ObjectAtPoint iterates through all the children of this form and returns the component situated at the coordinates given through the AScreenPoint TPointF parameter.
        If the object at the specified coordinates was not found, or is not an IControl, or its state is csDesigning, ObjectAtPoint returns nil. Otherwise the object is returned as IControl."""
    def RecreateOsMenu(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def RecreateResources(self, *args, **kwargs) -> Any:
        """Recreates the context where the form renders itself."""
    def Release(self, *args, **kwargs) -> Any:
        """Warning: Release is deprecated.  
        
        
        Marks this TFmxObject object  for delayed deletion."""
    def ReleaseCapture(self, *args, **kwargs) -> Any:
        """Releases the mouse capture from this window that belongs to the current thread and restores normal mouse input processing."""
    def RemoveRecognizer(self, Recognizer: InteractiveGesture) -> None:
        """TCommonCustomForm.RemoveRecognizer(Recognizer: InteractiveGesture) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ScreenToClient(self, AScreenPoint: PointF) -> PointF:
        """TCommonCustomForm.ScreenToClient(AScreenPoint: PointF) -> PointF
        Transforms the global screen coordinates to local client area coordinates. The global screen coordinates are given through the Point parameter."""
    def SendToBack(self, *args, **kwargs) -> Any:
        """Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
        FMX.Forms.TCommonCustomForm.SendToBack inherits from FMX.Types.TFmxObject.SendToBack. All content below this line refers to FMX.Types.TFmxObject.SendToBack.
        Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
        You can call SendToBack at run time as in the following code snippet:
        
          Label1.SendToBack;
        
        or, at design time by right-clicking the FMX visual control and selecting  Control > Send To Back from the pop-up menu."""
    def SetBounds(self, ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None:
        """TCommonCustomForm.SetBounds(ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None
        Sets the boundaries for this form.
        SetBounds has the following parameters:
        
        ALeft--the left boundary
        ATop--the top boundary
        AWidth--the right boundary
        AHeight--the bottom boundary\r
        Sets the boundaries for this form.
        SetBounds has the following parameters:
        
        ALeft--the left boundary
        ATop--the top boundary
        AWidth--the right boundary
        AHeight--the bottom boundary"""
    def SetBoundsF(self, ALeft: float, ATop: float, AWidth: float, AHeight: float) -> None:
        """TCommonCustomForm.SetBoundsF(ALeft: float, ATop: float, AWidth: float, AHeight: float) -> None
        Embarcadero Technologies does not currently have any additional information.\r
        Embarcadero Technologies does not currently have any additional information."""
    def Show(self, *args, **kwargs) -> Any:
        """Displays the form onscreen. 
        The form is displayed onscreen, with the specified Position.
        
        
        Attention: On macOS, the Secondary window created by a modal windows must also be shown using ShowModal. Do not call Show for a window that is being shown from a window shown using ShowModal."""
    def ShowModal(self, *args, **kwargs) -> Any:
        """Shows the form as a modal dialog box.
        Use ShowModal to show the form as a modal dialog box. When a modal form is opened the application cannot continue to run until the modal form is closed. Thus, ShowModal does not return until the form has closed. When the form has closed, it returns the value of the ModalResult property.
        To close a modal form, set its ModalResult property to a nonzero value.
        
        
        Tip: If the form contains buttons with a ModalResult property set to a value other than mrNone, the form automatically closes when the user clicks one of these buttons and returns the ModalResult value as the return value of ShowModal.
        Warning: Modal dialog boxes are not supported in Android apps. We recommend do not use modal dialog boxes on either of the mobile platforms (iOS and Android) because unexpected behavior can result. Avoiding usage of modal dialog boxes eliminates potential problems in debugging and supporting your mobile apps.
        Attention: On macOS, secondary windows shown from a modal window must also be shown modally using ShowModal, otherwise secondary windows do not gain focus."""
    def StartWindowDrag(self, *args, **kwargs) -> Any:
        """Signals that this form's window is about to be dragged. StartWindowDrag exits if this form has a csDesigning component state."""
    def StartWindowResize(self, *args, **kwargs) -> Any:
        """Signals that this form's window is about to be resized. StartWindowResize exits if this form has a csDesigning component state."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Component(Persistent):
    """TComponent is the common ancestor of all component classes.
    TComponent is the base class for all components. Components are persistent objects that have the following capabilities:
    
    IDE integration. The ability to appear on an IDE palette and be manipulated in a Form Designer.
    Ownership. The ability to manage other components. If component A owns component B, then A is responsible for destroying B when A is destroyed.
    Streaming and filing. Enhancements of the persistence features inherited from TPersistent.
    COM support. Components can be converted into ActiveX controls or other COM objects using wizards provided with Windows products. Components can serve as wrappers for COM objects.
    Note: COM features are present in all implementations of TComponent, including those provided for compatibility with OS X. However, COM features are Windows only and cannot be used in multi-device (cross-platform) applications.
    TComponent does not provide any user interface or display features. These features are provided by two classes that directly descend from TComponent:
    
    TControl, in the FMX.Types unit, is the base class for visual components in applications built with the FireMonkey (FMX) framework.
    TControl, in the Vcl.Controls unit, is the base class for visual components in Windows-only (VCL) applications.
    Note: Only the FMX.Types unit and other FireMonkey-specific units can be used with OS X applications. That is, you cannot use VCL units in multi-device applications.
    Components that can be visible at run time are sometimes called visual components. Other components, which are never visible at run time, are sometimes called non-visual components. However it is more common to refer to visual components as controls and non-visual components simply as components.
    Do not create instances of TComponent. Use TComponent as a base class when declaring non-visual components that can appear on the component palette and be used in the Form Designer. Properties and methods of TComponent provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    ComObject: IInterface
    """IInterface: Specifies the interface reference implemented by the component.
        Use ComObject to assign a COM interface implemented by a component to an interface reference. This property is used by components that support COM interfaces. 
        If the component is not a wrapper for a COM component, trying to read ComObject causes TComponent to raise an EComponentError exception."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentIndex: int
    """int: Indicates the position of the component in its owner's Components property array.
        Use ComponentIndex when iterating through the Components list of the component's owner to perform an action on owned components. It can be used in conjunction with ComponentCount. ComponentIndex is used internally for iterative assignment procedures. 
        
        Note:  The first component in the list has a ComponentIndex value of 0, the second has a value of 1, and so on. Therefore, when using ComponentIndex with ComponentCount, note that ComponentCount is always 1 more than the highest Components index."""
    ComponentState: ComponentState
    """ComponentState: Describes the current state of the component, indicating when a component needs to avoid certain actions.
        ComponentState is a set of constants defined in the TComponentState type.
        Components use the ComponentState property to detect states in which certain kinds of actions are allowed or disallowed. For example, if a component needs to avoid certain behaviors at design time that it performs at run time, it can check for the csDesigning flag. 
        ComponentState is read-only and its flags are set automatically when appropriate."""
    ComponentStyle: ComponentStyle
    """ComponentStyle: Governs the behavior of the component.
        ComponentStyle governs how the component interacts with the streaming system and the Object Inspector. ComponentStyle is a read-only property. Typically, the value of the various component style flags are part of a component definition, specified in a component constructor. The one exception to this is the csSubComponent style, which can be set by calling the SetSubComponent method."""
    Components: Any
    """Returns an iterator over the owned components"""
    DesignInfo: int
    """int: Contains information used by the Form designer.
        DesignInfo is used internally. Do not use this property in applications."""
    Name: str
    """str: Specifies the name of the component as referenced in code.
        Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as 'Button1', 'Button2', and so on.
        Use Name to refer to the component in code.
        
        Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception."""
    Observers: Observers
    """Observers: Indicates the TObservers object added to the TComponent.
        Observers is a read-only property that returns the TObservers added to the TComponent, in order to use the notifications provided by the observers either with LiveBindings or for the developers' own purposes."""
    Owner: Any
    """Returns the Component Owner"""
    Tag: int
    """int: Stores a NativeInt integral value as a part of a component.
        Tag has no predefined meaning. The Tag property can store any additional integer value for the convenience of developers. Often, Tag stores a pointer. A Tag value can be typecast to the appropriate pointer type. Notice that on 64-bit platforms, all  pointer types are 8 bytes in size, while on 32-bit platforms, pointer types are 4 bytes. These pointer sizes correspond to sizes of NativeInt integral values on 64-bit and 32-bit platforms."""
    VCLComObject: Pointer
    """Pointer: Represents information used internally by components that support COM.
        VCLComObject is for internal use only."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BeginInvoke(self, AProc: Proc, AContext: Object) -> IAsyncResult:
        """TComponent.BeginInvoke(AProc: Proc, AContext: Object) -> IAsyncResult
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TComponent.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DestroyComponents(self, *args, **kwargs) -> Any:
        """Destroys all owned components.
        DestroyComponents iterates through the components owned by the component, removing each from the list of owned components and destroying it.
        It is not necessary to call DestroyComponents directly. DestroyComponents is automatically called when the component is destroyed."""
    def Destroying(self, *args, **kwargs) -> Any:
        """Indicates that the component and its owned components are about to be destroyed.
        Destroying sets the csDestroying flag in the ComponentState property. It then calls the Destroying method for each owned component so that its csDestroying flag is also set. If csDestroying is already set, Destroying does nothing.
        It is not necessary to call Destroying directly. Destroying is automatically called when the component is destroyed."""
    def EndFunctionInvoke(self, AsyncResult: IAsyncResult) -> Object:
        """TComponent.EndFunctionInvoke(AsyncResult: IAsyncResult) -> Object
        Blocks the caller until the specified ASyncResult completes.
        Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. The result type corresponds to a TObject class type.
        EndInvoke raises any exception that may occur while the asynchronous method executes."""
    def EndInvoke(self, ASyncResult: IAsyncResult) -> None:
        """TComponent.EndInvoke(ASyncResult: IAsyncResult) -> None
        Blocks the caller until the specified ASyncResult completes.
        Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
        EndInvoke raises any exception that may occur while the asynchronous method executes."""
    def ExecuteAction(self, Action: BasicAction) -> bool:
        """TComponent.ExecuteAction(Action: BasicAction) -> bool
        Executes an action.
        ExecuteAction executes an action for the component. Action is a TBasicAction or any descendant of TBasicAction. 
        ExecuteAction first checks whether the provided action is compatible with the component and then executes the action. The return value is a Boolean. A value of True is returned if the action was executed; otherwise, False is returned. 
        Derived classes can override this method to implement a distinct way of handling actions."""
    def FindComponent(self, AName: str) -> Component:
        """TComponent.FindComponent(AName: str) -> Component
        Indicates whether a given component is owned by the component.
        FindComponent returns the component in the Components property array with the name that matches the string in the AName parameter. Use FindComponent to determine whether a given component is owned by another.
        Component name matches are not case sensitive."""
    def FreeNotification(self, AComponent: Component) -> None:
        """TComponent.FreeNotification(AComponent: Component) -> None
        Ensures that AComponent is notified that the component is going to be destroyed.
        Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
        For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed."""
    def FreeOnRelease(self, *args, **kwargs) -> Any:
        """Frees the interface reference for components that were created from COM classes.
        FreeOnRelease is called when an interface implemented by the component is released. FreeOnRelease is used internally and calls the corresponding interface method. It should not be necessary to call FreeOnRelease directly."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetNamePath(self, *args, **kwargs) -> Any:
        """Returns a string used by the Object Inspector.
        GetNamePath is used to determine the text to display in the Object Inspector for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. TComponent overrides GetNamePath to return the component's name. Do not call GetNamePath directly."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def InsertComponent(self, AComponent: Component) -> None:
        """TComponent.InsertComponent(AComponent: Component) -> None
        Establishes the component as the owner of a specified component.
        InsertComponent adds the component passed in the AComponent parameter to the end of the Components array property. The inserted component must have no name (no specified Name property value), or the name must be unique among all others in the Components list.
        When the owning component is destroyed, AComponent is also destroyed.
        Components are automatically inserted and removed when visually manipulating them in the form designer. Use InsertComponent when manually adding components to another Owner component's Components list."""
    def IsImplementorOf(self, I: IInterface) -> bool:
        """TComponent.IsImplementorOf(I: IInterface) -> bool
        Indicates whether the component implements a specified interface.
        Call IsImplementorOf to determine whether the component (or, if the component aggregates its interface with other components, whether the controlling component) supports the interface specified by I. IsImplementorOf is similar to the QueryInterface method, but it can handle a request for a nil (Delphi) or NULL (C++) interface, and it does not return an interface pointer.
        The streaming system that loads and saves components uses IsImplementorOf to resolve property values that are interfaces."""
    def ReferenceInterface(self, I: IInterface, Operation: Operation) -> bool:
        """TComponent.ReferenceInterface(I: IInterface, Operation: Operation) -> bool
        Establishes or removes internal links that cause this component to be notified when the implementer of a specified interface is destroyed.
        Component writers use ReferenceInterface to ensure that properties whose values are interfaces are informed when the objects that implement those interfaces are destroyed. This notification must be in place for a property whose value is an interface to be saved with the component in a form file (that is, for such a property to persist as a published property).
        I is an interface pointer that is the value of the published property of interest.
        Operation indicates whether the notification link to the implementer of the interface should be established (opInsert) or removed (opRemove).
        ReferenceInterface returns True if it is successful in establishing or removing the notification link. If ReferenceInterface returns False when called with Operation set to opInsert, the specified interface cannot be stored as the value of a published property.
        
        Note: A result of False does not necessarily indicate an error, merely that the interface cannot be stored by the property streaming system. For example, ReferenceInterface returns False when the specified interface employs true reference counting, independent of component lifetimes."""
    def RemoveComponent(self, AComponent: Component) -> None:
        """TComponent.RemoveComponent(AComponent: Component) -> None
        Removes a specified component specified from the component's Components list.
        Components are automatically inserted and removed when visually manipulating them in the form designer. Use RemoveComponent to programmatically delete the component specified by AComponent from its Owner component."""
    def RemoveFreeNotification(self, AComponent: Component) -> None:
        """TComponent.RemoveFreeNotification(AComponent: Component) -> None
        Disables the destruction notification that was enabled by FreeNotification.
        RemoveFreeNotification removes the component specified by the AComponent parameter from the internal list of objects to be notified that the component is about to be destroyed. AComponent is added to this list by a previous call to the FreeNotification method.
        Most applications have no need to call RemoveFreeNotification. It is used by TComponent to detect loops where two components are notifying each other of their impending destruction."""
    def SafeCallException(self, ExceptObject: Object, ExceptAddr: Pointer) -> int:
        """TComponent.SafeCallException(ExceptObject: Object, ExceptAddr: Pointer) -> int
        Handles exceptions in methods declared using the safecall calling convention.
        SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle errors that might occur. TComponent calls the implementation of this method for the interface supported by the component, if it exists. If the component does not support interfaces, this method calls the SafeCallException method inherited from TObject, which returns E_UNEXPECTED. This is a default return value that is appropriate for classes that do not support any interfaces."""
    def SetSubComponent(self, IsSubComponent: bool) -> None:
        """TComponent.SetSubComponent(IsSubComponent: bool) -> None
        Identifies whether the component is a subcomponent.
        Call SetSubComponent to indicate whether this component is a subcomponent. A subcomponent is a component whose Owner is a component other than the form or data module in which it resides. Unless such a component calls SetSubComponent with IsSubComponent set to True, its published properties will not be saved to the form file.
        IsSubComponent indicates whether the component is a subcomponent (True) or not (False).
        SetSubComponent is called at design time:
        
        Either from the constructor of a component that always acts as a subcomponent. In this case, the component calls its own SetSubComponent method from the constructor with IsSubComponent set to True.
        Or immediately after constructing an instance of the subcomponent. In this case, the Owner calls the SetSubComponent method of a component it has just instantiated, with IsSubComponent set to True."""
    def UpdateAction(self, Action: BasicAction) -> bool:
        """TComponent.UpdateAction(Action: BasicAction) -> bool
        Updates the state of an action.
        UpdateAction is used to update the state of an action. Action is a TBasicAction or any descendant. 
        UpdateAction first checks whether the provided action is compatible with the component and then updates it. The return value is a Boolean. A value of True is returned if the action was updated, and a value of False, otherwise. 
        Derived classes can override this method to implement a distinct way of handling action updates."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedAction(BasicAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ActionList: ContainedActionList
    """ContainedActionList: Holds the action list to which the action belongs."""
    AutoCheck: bool
    """bool: Controls whether the Checked property toggles when the action executes.
        AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
        If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client."""
    Caption: str
    """str: Represents the caption of the action.
        Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action."""
    Category: str
    """str: Group or category where the action belongs.
        IDE editors for actions group together actions that share the same category. In the VCL, if you are using an action manager, you can generate user interface elements that correspond to action categories.
        Action categories group actions by similarities, usually of behavior or functionality. Standard categories are Edit, Format, Help, Windows, and others. At design time you can modify or set the Category for an action by selecting the action from the action list or object tree view, and choosing Category in the Object Inspector."""
    Checked: bool
    """bool: Indicates whether client controls and menu items appear checked.
        Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.
        
        Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
        Tip: Use the AutoCheck property to ensure that the action's Checked property toggles when the action executes."""
    DisableIfNoHandler: bool
    """bool: Indicates whether the action's clients should be disabled if no OnExecute event handler is found.
        DisableIfNoHandler defines whether to set the Enabled property of the action to False if no OnExecute event handler is set for the action. Setting Enabled to False disables all the action's clients.
        See, for example, how FMX.Forms.TApplication.UpdateAction uses DisableIfNoHandler to define whether to set Enabled to False if the OnExecute event handler is not defined to the action.
        For example, setting DisableIfNoHandler to False can be useful when managing submenus. In this case, pointing to a command on the main menu, which causes the submenu to open, does not need any OnExecute event handler. Then, if DisableIfNoHandler is True, this main menu command becomes disabled and the submenu cannot be opened. In such cases it can be convenient to use actions of types FMX.Controls.TControlAction and Vcl.Controls.TControlAction.  Objects of these classes have the value of DisableIfNoHandler set to False, by default."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    GroupIndex: int
    """int: Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
        The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
        When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.
        
        Note:  All actions in a group must be listed by the same action list."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    Index: int
    """int: Specifies the index of the action in its action list.
        Index indicates the position of the action in its action list. You can change the action's Index at design time using one of the IDE editors to handle actions.
        The index of actions determines the order in which they appear in user interface elements such as menus and tool bars.
        Index is zero-based. When Index is -1, this means that the ActionList property does not contain any list."""
    OnHint: Callable[[str,bool],None]
    """Callable[[str, bool], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    StatusAction: StatusAction
    """StatusAction: Stores the status for an input field in an action.
        StatusAction holds the status for an input field in the action, when it is set. 
        The value of StatusAction  can be propagated to all client controls and client menu items linked to the action."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TContainedAction.Create(AOwner: Component) -> None
        Instantiates and initializes a TContainedAction object.
        Applications do not need to call Create directly. Actions are created automatically when you choose New Action in the Action List editor. 
        Create calls the inherited System.Classes.TBasicAction.Create constructor and then 
        initializes the Enabled (setting it to True), Visible (setting it to True), and ImageIndex (setting it to -1) properties."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the instance of the contained action.
        If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method."""
    def DoHint(self, HintStr: str) -> bool:
        """TContainedAction.DoHint(HintStr: str) -> bool
        Calls the OnHint event handler.
        Typically, applications do not call the DoHint method. It is called automatically when the user pauses the mouse on one of the action's client controls or menu items. DoHint is called by the action's client when the client asks to show the hint.
        
        DoHint checks for an OnHint event handler and passes HintStr to it, if the event handler exists. The OnHint event handler can change the specified hint string HintStr. DoHint returns True if no event handler is assigned or if OnHint returns True. DoHint can be used to determine which hint text should be shown. For example, Vcl.Controls.TControlActionLink.DoShowHint calls DoHint internally, and if DoHint returns True, then Vcl.Controls.TControlActionLink.DoShowHint appends the action's shortcut specification to the hint text to display."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def GetParentComponent(self, *args, **kwargs) -> Any:
        """Returns the action list containing the action.
        GetParentComponent returns the action list containing the action. This action list is stored in the ActionList property. If ActionList stores nil, then GetParentComponent calls the inherited System.Classes.TComponent.GetParentComponent method."""
    def HasParent(self, *args, **kwargs) -> Any:
        """Indicates whether the action is contained in an action list.
        HasParent returns True if the action is contained in an action list stored in the  ActionList property. If ActionList stores nil, then HasParent calls the inherited System.Classes.TComponent.HasParent method."""
    def SetParentComponent(self, AParent: Component) -> None:
        """TContainedAction.SetParentComponent(AParent: Component) -> None
        Sets the action list containing the action.
        SetParentComponent sets the specified AParent action list as the action list containing the action. This action list is stored in the ActionList property."""
    def Suspended(self, *args, **kwargs) -> Any:
        """Returns True if the action list of the action is suspended."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedActionList(Component):
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    OnStateChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    State: ActionListState
    """ActionListState: Indicates whether the actions in the action list respond when the user triggers a client object. 
        State can be one of the constants defined in the TActionListState type: 
        asNormal, asSuspended, and asSuspendedEnabled."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TContainedActionList.Create(AOwner: Component) -> None
        Creates an instance of TContainedActionList.
        This creator is inherited from TComponent, see TComponent.Create for more information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TContainedActionList.
        This destructor is inherited from TComponent, see TComponent.Destroy for more information."""
    def EnumByCategory(self, Proc: Callable[[ContainedAction,bool],None], Category: str, IncludeSubCategory: bool) -> bool:
        """TContainedActionList.EnumByCategory(Proc: Callable[[ContainedAction, bool], None], Category: str, IncludeSubCategory: bool) -> bool
        Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
        IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
        Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.\r
        Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
        IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
        Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely."""
    def ExecuteAction(self, Action: BasicAction) -> bool:
        """TContainedActionList.ExecuteAction(Action: BasicAction) -> bool
        Generates an OnExecute event.
        Typically, applications do not call the ExecuteAction method. Instead, the action indicated by the Action parameter calls ExecuteAction in response to a user command. It is possible, however, to call ExecuteAction to generate an OnExecute event even though no client control has been triggered.
        ExecuteAction invokes the OnExecute event handler for the action list. It returns True if the event handler handles the action, False otherwise."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TContainedActionList.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Calls a specified method for each child action of the action list.
        GetChildren is used by the component streaming system. For each action in the action list, GetChildren calls the method passed in Proc. The actions are passed to the callback in the order that they are loaded or saved by the component streaming system."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TContainedActionList enumerator, a TActionListEnumerator reference that enumerates the actions in the list.
        To process all actions, read Current from the enumerator within a   while MoveNext do   loop."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def UpdateAction(self, Action: BasicAction) -> bool:
        """TContainedActionList.UpdateAction(Action: BasicAction) -> bool
        Generates an OnUpdate event.
        Typically, applications do not call the UpdateAction method. Instead, the action indicated by the Action parameter calls UpdateAction when informed by the application that it can update itself. It is possible, however, to call UpdateAction to generate an OnUpdate event even though this has not been initiated by the application.
        UpdateAction invokes the OnUpdate event handler for the action list. It returns True if the event handler updates the action, False otherwise."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedBindComponent(BasicBindComponent):
    """Base class for all common binding components descending from it.
    TContainedBindComponent is an abstract class that is the base class for TCommonBindComponent."""
    __hash__: ClassVar[None] = ...
    BindingsList: CustomBindingsList
    """CustomBindingsList: Specifies a list that holds the binding expressions."""
    Category: str
    """str: Specifies a category for this component.
        For example, for a binding expression called BindExpressionForm121, of type TBindExpression, the following code:
        
          ShowMessage(BindExpressionForm121.Category);
        
        shows the following message: Binding Expressions."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    ControlComponent: Component
    """Component: Specifies the component that will be bound to the source component, by means of LiveBindings."""
    DisplayName: str
    """str: Returns a string containing the name of this component."""
    Index: int
    """int: Returns the index of this component in the bindings list."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanSetControlComponent(self, Value: Component) -> bool:
        """TContainedBindComponent.CanSetControlComponent(Value: Component) -> bool
        Returns whether the control component can be set a given value.
        As implemented in TContainedBindComponent, CanSetControlComponent always returns True, but in descendants it actually returns whether the given Value (that is itself a TComponent) can be assigned to the control component."""
    def Create(self, AOwner: Component) -> None:
        """TContainedBindComponent.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def SetParentComponent(self, AParent: Component) -> None:
        """TContainedBindComponent.SetParentComponent(AParent: Component) -> None
        Sets the parent component of this component.
        SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Control(FmxObject):
    """TControl is the base class for FMX on-screen components. Subclasses are roughly divided into primitive shapes and styleable controls.
    TControl extends TFmxObject to present objects that are seen, by adding properties and methods for:
    
    Size and position
    Margins and padding
    Alignment with others
    Visibility, opacity, scale, and rotation
    Mouse interaction and hit testing
    Keyboard interaction
    Focus and tab order
    Triggers for animations and effects
    Painting"""
    __hash__: ClassVar[None] = ...
    AbsoluteClipRect: RectF
    """RectF: Specifies the absolute rectangle of the control after all its parent controls clip it."""
    AbsoluteEnabled: bool
    """bool: Specifies whether the control is absolutely enabled. 
        AbsoluteEnabled is True only if Enabled is True and the parent also reports AbsoluteEnabled as True. Therefore, this logic climbs the parent hierarchy to determine whether the control is truly enabled or not.
        If Parent is set and the parent's AbsoluteEnabled property is False, AbsoluteEnabled is set to False, otherwise it has the value of the Enabled property."""
    AbsoluteHeight: float
    """float: Specifies the absolute height of the control. 
        Usually, it has the same value as the Height property. The value can be affected by the transformations applied over the control."""
    AbsoluteMatrix: Matrix
    """Matrix: Specifies the absolute transformation matrix of the control. 
        AbsoluteMatrix is calculated using FLocalMatrix and AbsoluteMatrix of its parent.
        The calculation only takes place if FRecalcAbsolute is True and the result is then cached in the FAbsoluteMatrix field.
        If the calculation is not taking place during an update session and InPaintTo is not set, it initiates Repaint.
        AbsoluteMatrix is used when the control is painted or needs to be repainted."""
    AbsoluteOpacity: float
    """float: Specifies the absolute opacity of the control. 
        If the control has another TControl as parent, AbsoluteOpacity depends on the absolute opacity of its parent. 
        To explicitly set the opacity of a control, use the Opacity property."""
    AbsoluteRect: RectF
    """RectF: Specifies the absolute rectangle that bounds the control.  It returns the bounding rectangle of the control in absolute coordinates (relative to the main form)."""
    AbsoluteScale: PointF
    """PointF: Specifies the absolute scale of the control. 
        The absolute scale of a control is the scale relative to the scale of its parent.
        AbsoluteScale is kept as a TPointF. The X coordinate is the scale for the X axis and Y is the scale for the Y axis."""
    AbsoluteWidth: float
    """float: Specifies the absolute width of the control. 
        Usually, it has the same values as the Width property. The value can be affected by the transformations applied over the control."""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ApplyingEffect: bool
    """bool: A flag that signals when a control is in the process of applying an effect.
        The ApplyEffect method uses this flag to correctly render a control."""
    AutoCapture: bool
    """bool: Specifies whether the control captures mouse events.
        When a control captures the mouse, all subsequent mouse events go to that control until the user releases the mouse button."""
    AxisAlignedRect: RectF
    """RectF: A TRectF defined by the width and height of the control.
        This TRectF is normalized. DoGetUpdateRect uses this property."""
    BoundsRect: RectF
    """RectF: Specifies the bounding rectangle of the control. 
        The coordinates of the upper-left corner of the bounding rectangle are X and Y coordinates of the control Position. The coordinates of the lower-right corner are X+Width and Y+Height. 
        For example:
        
        R:=Control.BoundsRect;
        
        The coordinates of the R rectangle are:
        
        R.Left = Control.Position.X;
        R.Top = Control.Position.Y;
        R.Right = Control.Position.X + Control.Width;
        R.Bottom = Control.Position.Y + Control.Height;
        
        When BoundsRect is set, the Position property is set to be the upper-left corner of the given bound rectangle, and the Width and Height of the control receive the values of the width and height of the given bound rectangle.
        For example:
        
        Control.BoundsRect:=R;
        
        The controls have the following properties:
        
        Control.Position.X= R.Left;
        Control.Position.Y= R.Top;
        Control.Width= R.Width;
        Control.Height= R.Height;"""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Canvas: Canvas
    """Canvas: Provides the drawing surface of the control. 
        Canvas defines an area within which you can explicitly position child elements by using coordinates that are relative to the drawing area.
        For more details, see TCanvas."""
    ChildrenRect: RectF
    """RectF: Specifies the bigger rectangle area occupied by parent and children controls. 
        ChildrenRect is a rectangle obtained by performing a union operation between the rectangles occupied by the parent control and the children controls. 
        
        Use the ChildrenRect.Width property on the parent, to obtain the width of the rectangle.
        Use the ChildrenRect.Height property on the parent, to obtain the height of the rectangle.
        Note: They are read-only properties."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ClipRect: RectF
    """RectF: Specifies the bound rectangle to be clipped. 
        The values of ClipRect are specified by:
        
        Left and Top, equal to 0.
        Right, equal to Width.
        Bottom, equal to Height."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    CustomSceneAddRect: Callable[[Control,RectF],None]
    """Callable[[Control, RectF], None]:"""
    DefaultSize: SizeF
    """SizeF: Embarcadero Technologies does not currently have any additional information."""
    DisableDisappear: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FixedSize: Size
    """Size: Embarcadero Technologies does not currently have any additional information."""
    HasAfterPaintEffect: bool
    """bool: Specifies whether the control has an effect that is applied after the control is painted.
        HasAfterPaintEffect is True if the control has an effect that is applied after the control is painted, and False otherwise."""
    HasClipParent: Control
    """Control: Control that is a direct child of this control and has clipped this control."""
    HasDisablePaintEffect: bool
    """bool: Specifies whether the control's effect is painted.
        HasDisablePaintEffect is True if the control has disabled the painting effect, and False otherwise."""
    HasEffect: bool
    """bool: Specifies whether the control has an applied effect.
        HasEffect is False if an effect was applied to the control, and True otherwise."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    InPaintTo: bool
    """bool: Specifies whether the control is currently being painted.
        InPaintTo is True if the current control is being painted."""
    InheritedCursor: int
    """int: Image used to represent the mouse pointer when it passes into the region covered by the control.
        The value of the read-only InheritedCursor property is the value of the Cursor property unless Cursor has the default value, in which case InheritedCursor contains the first non-default InheritedCursor value of its ancestors (parent, grand-parent, and so on until the parent form). If every ancestor of this control has InheritedCursor set to the default value, InheritedCursor has the default value in this control as well.
        Changing the value of Cursor in this control or in any ancestor of this control may affect the value of InheritedCursor in this control."""
    InvertAbsoluteMatrix: Matrix
    """Matrix: Specifies the inverse matrix of AbsoluteMatrix."""
    IsDragOver: bool
    """bool: Specifies whether a dragged object is over the area of the current control.
        IsDragOver is True when the dragged object is over the current control.
        For effect triggers, setting IsDragOver to True triggers the effect when the dragged object is over the current control."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    IsInflated: bool
    """bool: Whether the current style of this control has been actually applied to the control.
        IsInflated is  True if the current style of the control has been applied to the control. It is False otherwise.
        For example, if you change the style of a control at run time, IsInflated is False until the control is updated to show its new style."""
    IsMouseOver: bool
    """bool: Specifies whether the mouse cursor is over the control.
        IsMouseOver is True when the mouse is passing over the control.
        For effect triggers, setting IsMouseOver to True triggers the effect while the mouse passes over the control."""
    IsVisible: bool
    """bool: Specifies whether the control is visible.
        IsVisible is True when the control is visible. Use Visible in applications to allow write access.
        For effect triggers, setting IsVisible to True triggers the effect when the control is visible on the form."""
    LocalRect: RectF
    """RectF: Specifies the local rectangle for painting the control. 
        The coordinates of the upper-left corner of the rectangle are (0,0) and the coordinates of the bottom right corner are (Width, Height)."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnActivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeactivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTap: Callable[[Object,PointF],None]
    """Callable[[Object, PointF], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentControl: Control
    """Control: Specifies the parent control of this control.
        
        Tip: You cannot set the parent control of this control as the control itself (Self (Delphi) or this (C++Builder))."""
    ParentedRect: RectF
    """RectF: Specifies the bounding rectangle of the control within its parent."""
    ParentedVisible: bool
    """bool: Specifies whether all the control's parents are visible. 
        A control can be set to visible if all its parents are also visible.
        ParentedVisible returns True if the control's parents are visible, and False otherwise."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Pressed: bool
    """bool: Indicates whether the control is currently pressed.
        Mouse action event handlers use this property as a flag to determine how to proceed in some cases."""
    PressedPosition: PointF
    """PointF: A point that indicates where exactly on the control the click occured.
        MouseDown sets PressedPosition if Button is mbLeft."""
    Scene: IScene
    """IScene: Specifies the current scene in which the control is drawn.  
        The Scene of the control is also the scene of its children."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the standard gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    UpdateRect: RectF
    """RectF: Specifies the rectangle area of the control that needs to be updated. 
        UpdateRect is a union between the rectangle areas that need to be painted over the control when:
        
        The control receives focus.
        The control gets new effects.
        The control's children are updated.
        The control's parent is updated."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def AbsoluteToLocalVector(self, Vector: Vector) -> Vector:
        """TControl.AbsoluteToLocalVector(Vector: Vector) -> Vector
        Transforms and returns a specified vector from the absolute perspective to the local perspective. 
        Use AbsoluteToLocalVector to get the transposed coordinates of a vector from the absolute context to the local context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
        P is the vector to be transformed.
        AbsoluteToLocalVector returns the transformed vector.
        To have the inverse effect over a point, use LocalToAbsoluteVector."""
    def ApplyTriggerEffect(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TControl.ApplyTriggerEffect(AInstance: FmxObject, ATrigger: str) -> None
        Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
        ApplyTriggerEffect iterates through all the children of this FMX object and, if one of them is of type TEffect, applies the mouse trigger given through the ATrigger parameter (which can be 'IsMouseOver', 'IsMouseOver', 'IsDragOver', and so on).
        AInstance specifies the instance of the FMX object to which the trigger effect is applied."""
    def BeginUpdate(self, *args, **kwargs) -> Any:
        """Marks the start of an update session of the control and its children. 
        It increases the value of the FUpdating semaphore. A call to BeginUpdate must be complemented by calls to EndUpdate after the update is finished.
        FUpdating is an internal semaphore used to mark the process of control updating. Painting of a control is disabled while FUpdating is higher than 0."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def ConvertLocalPointFrom(self, AControl: Control, AControlLocalPoint: PointF) -> PointF:
        """TControl.ConvertLocalPointFrom(AControl: Control, AControlLocalPoint: PointF) -> PointF
        Embarcadero Technologies does not currently have any additional information."""
    def ConvertLocalPointTo(self, AControl: Control, ALocalPoint: PointF) -> PointF:
        """TControl.ConvertLocalPointTo(AControl: Control, ALocalPoint: PointF) -> PointF
        Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Controls.TControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Marks the end of an update session of the control and its children.
        The update session must be started first by calling BeginUpdate.
        EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes."""
    def EnumControls(self, function(Control:TControl)) -> Any:
        """TControl.EnumControls(Proc: Func<FMX.Controls.TControl,FMX.Types.TEnumProcResult>) -> None
        Loops through the controls that are children of this control, and runs the specified procedure once per control, with a different control as the first parameter in each call.
        
        Warning: EnumControls is deprecated as a function. You should use it as a procedure instead. This page describes the syntax and use of the EnumControls procedure.
        EnumControls loops not only through direct children of this control, but also through their children (grand-children), and so on, using a depth-first search algorithm.
        Each time EnumControls visits a control during the search, it executes the Proc procedure. This procedure receives the visited control as argument, and it returns a value of type TEnumControlsResult. The return value defines what EnumControls does next. You may return any of the following values:
        
        Continue lets EnumControls keep searching the controls as usual.
        Discard makes the search skip the children of the current control (the control in the first parameter), as well as their children (grand-children) and so on.
        Stop interrupts the search loop. If EnumControls were a language-level control loop, Stop would be the Break keyword.
        Example
        The following is an example call to EnumControls that loops through the children of a panel (Panel1) and fills a list (ListOfVisibleControls) with all the controls that are visible:
        
        
        In Delphi:
        
        Panel1.EnumControls(function (Control: TControl): TEnumControlsResult
          begin
            if not Control.Visible then
              Result := TEnumControlsResult.Discard
            else
              begin
                ListOfVisibleControls.Add(Control);
                Result := TEnumControlsResult.Continue;
              end;
          end);
        
        
        
        In C++:
        
        1. Define a class that implements the TFunc__2 interface:
        class TMethodReference : public TCppInterfacedObject<TFunc__2<TControl*,TEnumControlsResult> >
        {
        public:
            TEnumControlsResult __fastcall Invoke(TControl* Control)
            {
                if (!Control->Visible)
                    return TEnumControlsResult::Discard;
                else {
                    TForm2::ListOfVisibleControls->Add(Control);
                    return TEnumControlsResult::Continue;
                }
            }
        };
        
        2. Then pass an instance of this class to EnumControls:
        Panel1->EnumControls(new TMethodReference);"""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def InvalidateRect(self, ARect: RectF) -> None:
        """TControl.InvalidateRect(ARect: RectF) -> None
        Adds a rectangle to the update region of the scene.
        ARect specifies the rectangle to be invalidated.
        InvalidateRect transposes ARect to the local perspective and then adds it to the update region of the Scene."""
    def IsUpdating(self, *args, **kwargs) -> Any:
        """Returns True if this control is in the middle of one or more update sessions. It returns False otherwise."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def LocalToAbsoluteVector(self, Vector: Vector) -> Vector:
        """TControl.LocalToAbsoluteVector(Vector: Vector) -> Vector
        Transforms and returns a specified vector from the local perspective to the absolute perspective. 
        Use LocalToAbsoluteVector to get the transposed coordinates of a vector from the local context to the absolute context of the current control. The absolute context for a control is the parent form area, and the local context is the control area.
        P is the vector to be transformed.
        LocalToAbsoluteVector returns the transformed vector.
        To have the inverse effect over a vector, use AbsoluteToLocalVector."""
    def LocalToScreen(self, ALocalPoint: PointF) -> PointF:
        """TControl.LocalToScreen(ALocalPoint: PointF) -> PointF
        Transforms and returns a specified point from the local perspective to the screen perspective. 
        P is the point to be transformed.
        LocalToScreen is used internally when applying a certain placement."""
    def Lock(self, *args, **kwargs) -> Any:
        """Locks the current control, so it cannot be changed at design time. Lock also locks the current control's children."""
    def MakeScreenshot(self, *args, **kwargs) -> Any:
        """Takes and returns a screenshot of the control.
        MakeScreenshot creates a new TBitmap, draws on it the image of the current control by calling PaintTo, and returns it."""
    def PaintTo(self, ACanvas: Canvas, ARect: RectF, AParent: FmxObject) -> None:
        """TControl.PaintTo(ACanvas: Canvas, ARect: RectF, AParent: FmxObject) -> None
        Paints the current control to a specified canvas. 
        ACanvas specifies the canvas to draw on.
        ARect specifies the rectangle area of the ACanvas to draw on.
        AParent specifies the Parent of the control. By default, it is empty.
        PaintTo is called in the process of applying effects on the control in ApplyEffect, in which the control is first painted on the effect's canvas using PaintTo and then the effect is processed. It is also used in MakeScreenshot in order to produce a screenshot bitmap.
        Descendants of TControl override PaintTo to provide specific rendering of the respective controls."""
    def PointInObject(self, X: float, Y: float) -> bool:
        """TControl.PointInObject(X: float, Y: float) -> bool
        Checks whether the point, specified by the absolute coordinates, belongs to the control area.
        PointInObject returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the absolute coordinates (relative to the main form) of the point to be checked (compare with PointInObjectLocal):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The points of the control boundary specified by BoundsRect belong to the control and PointInObject returns True for them.
        
        Note: PointInObject simply converts absolute coordinates of the point to local coordinates and calls PointInObjectLocal."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TControl.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def RecalcAbsolute(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate the AbsoluteMatrix property.  RecalcAbsolute also forces the control's children to recalculate their AbsoluteMatrix."""
    def RecalcAbsoluteNow(self, *args, **kwargs) -> Any:
        """Recalculates AbsoluteMatrix.
        It is used in the painting process. Do not call RecalcAbsoluteNow in an application."""
    def RecalcEnabled(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its enabled state.  RecalcEnabled also forces the control's children to recalculate their enabled state."""
    def RecalcHasClipParent(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its HasClipParent property."""
    def RecalcHasEffect(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its HasEffect property.  RecalcHasEffect also forces the control's parent to recalculate its HasEffect property."""
    def RecalcOpacity(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its Opacity property.  RecalcOpacity also forces the control's children to recalculate their Opacity property."""
    def RecalcSize(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def RecalcUpdateRect(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its UpdateRect property.  RecalcUpdateRect also forces the control's parent--if necessary--and children to recalculate their UpdateRect property."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def ScreenToLocal(self, AScreenPoint: PointF) -> PointF:
        """TControl.ScreenToLocal(AScreenPoint: PointF) -> PointF
        Transforms and returns a specified point from the screen perspective to the local perspective. 
        P is the point to be transformed.
        ScreenToLocal is used internally."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TControl.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def ShouldTestMouseHits(self, *args, **kwargs) -> Any:
        """Indicates whether a control should be ignored in ObjectAtPoint.
        False if the control should be ignored in ObjectAtPoint. ShouldTestMouseHits normally returns the same value as the value of Visible property of the control.
        TFrame overrides this method to allow itself to be painted in design time regardless of the value of its Visible property."""
    def ShowInDesigner(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def StartTriggerAnimation(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TControl.StartTriggerAnimation(AInstance: FmxObject, ATrigger: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def StartTriggerAnimationWait(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TControl.StartTriggerAnimationWait(AInstance: FmxObject, ATrigger: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def UpdateEffects(self, *args, **kwargs) -> Any:
        """Updates the effects of the current control and of the control's parent.
        UpdateEffects is called every time the current control is changed (repainted, realigned, resized). UpdateEffects is also used when a new child is added to the control by calling AddObject."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ControlSize(Persistent):
    """Used for storing the size of FireMonkey components.
    A TControlSize object is used for managing the size of the component. This can be specified through the Size, Width, Height, and PlatformDefault attributes."""
    __hash__: ClassVar[None] = ...
    DefaultValue: SizeF
    """SizeF: Represents the default values of the TControlSize Height, Width, and PlatformDefault variables."""
    Height: float
    """float: Describes the height of a TControlSize.
        Use this property to set or get the height for a TControlSize."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    PlatformDefault: bool
    """bool: When this property is set to True, the size and width of the control are set automatically based on pre-defined sizes for the active platform.
        Explicitly setting the Width or Height properties  automatically sets the PlatformDefault setting to False.
        
        Note: Changing the value of PlatformDefault  triggers an OnChange notification."""
    Size: Any
    """Provides access to the size of a control"""
    Width: float
    """float: Describes the width of a TControlSize.
        Use this property to set or get the width for a TControlSize."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Create(self, ASize: SizeF) -> None:
        """TControlSize.Create(ASize: SizeF) -> None
        Creates an instance of TControlSize."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def SetPlatformDefaultWithoutNotification(self, Value: bool) -> None:
        """TControlSize.SetPlatformDefaultWithoutNotification(Value: bool) -> None
        Sets the value of the PlatformDefault property without triggering the OnChange notification. This method should be used only in cases where the OnChange notification is triggered by some other mechanism."""
    def SetSizeWithoutNotification(self, Value: SizeF) -> None:
        """TControlSize.SetSizeWithoutNotification(Value: SizeF) -> None
        Sets the Size property to the height and width values of TSizeF and the PlatformDefault property to False. 
        These changes do not cause any notification. You can change instead the Size and PlatformDefault properties directly, what calls the OnChange event.
        This method should be used only in cases where the OnChange notification is triggered by some other mechanism."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CornerButton(CustomCornerButton):
    """Represents a button with customizable corners.
    Use the Corners property to choose the corners to be customized and the CornerType, XRadius, and YRadius  properties to customize the corners."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    CornerType: CornerType
    """CornerType: Specifies the type of the corner customization in the TCustomCornerButton control.
        Values of CornerType are defined in the TCornerType: Round, Bevel, InnerRound, and InnerLine. These values define the following types of corner shape customizations: 
        
        
        CornerType applies to corners specified in the Corners set.
        XRadius and YRadius specify the distance from a corner to the start point of the corner customization, on the horizontal and vertical sides. 
        
        Note: If Corners is an empty set, or any of the XRadius and YRadius properties is zero, modifying the CornerType property has no visual effect."""
    Corners: Corners
    """Corners: Specifies which corners are customized by the CornerType, XRadius, and YRadius properties.
        By default, all four corners are customized. 
        Corners contains a set of values defined in the TCorner type: TopLeft, TopRight, BottomLeft, and BottomRight. Use the AllCorners constant to select all corners. 
        If Corners is an empty set, then no corner shape customization is used."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    ModalResult: int
    '''int: Determines whether and how the button closes its (modal) parent form.
        Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
        For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).'''
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RepeatClick: bool
    """bool: Specifies whether to automatically repeat the button click after a preset time.
        Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
        The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
        Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button's OnClick event."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Sides: Sides
    """Sides: Specifies which sides of the control to display.
        A side is a button boundary between two adjacent corners or end points of corner customizations. End points of corner customizations are defined by XRadius and YRadius. A corner customization applies to corners included into the Corners set.
        By default, all sides of the control are displayed.
        Sides can contain a set of values defined in TSide: Top, Left, Bottom, and Right. 
        Use the AllSides constant to select all sides."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    XRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the horizontal sides of the button.
        How corners are customized is defined by the Corners,
        CornerType, XRadius, and YRadius properties."""
    YRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the vertical sides of the button.
        How corners are customized is defined by the Corners,
        CornerType, XRadius, and YRadius properties."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CurrencyColumn(CustomNumberColumn):
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    DecimalDigits: int
    """int: The number of decimal places when displaying float numbers."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShowThousandSeparator: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCurrencyColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TCurrencyColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomAction(ContainedAction):
    """TCustomAction is a base class for FireMonkey actions intended to be used with menu items and controls.
    TCustomAction introduces support for the properties, events, and methods of menu items and controls that are clients of actions.
    Most properties and events introduced in TCustomAction are public; therefore, use TCustomAction as a base class when deriving your own actions that publish specific subset of properties of associated controls. 
    Actions centralize responses to user commands (user actions). An action is associated with the user interface elements (components) in an application that uses this action. Actions provide an easy way to synchronize values of properties of an action and of associated components (clients), for example, the enabled state and caption of an action and of an associated speed button and a menu item, and handle the response when the user clicks these components. Each component, which is called the client, has its properties dynamically updated by the associated action and forwards user commands to the action for a response.
    The Text property can be used to set an accelerator key to the action. Notice that & and _ are seen and can be used only for Windows.
    At design time, you can work in the Action List editor with actions contained in an action list. The action list is a container for actions, organized into categories (File, Edit, and others).
    Public properties and events of a component and control that are supported in TCustomAction, either directly or through an ancestor, are the following:
    
    Properties: Caption, Checked, Enabled, HelpType, HelpContext, HelpKeyword, Hint, ImageIndex, ShortCut, Visible.
    Events: OnHint, OnUpdate, OnExecute.
    TCustomAction is the base class for TAction and TCustomViewAction.
    TCustomAction acts as the base class for several predefined action classes. For predefined actions that augment the behavior of TCustomAction, see the action classes in the FMX.StdActns unit.
    
    Code Examples
    FMX.ActionsDemo Sample
    FMX.KeyboardToolbar Sample
    FMX.ScrollableForm Sample"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ActionList: CustomActionList
    """CustomActionList: Holds the action list to which the action belongs.
        FMX.ActnList.TCustomAction.ActionList inherits from System.Actions.TContainedAction.ActionList. All content below this line refers to System.Actions.TContainedAction.ActionList.
        Holds the action list to which the action belongs."""
    Caption: str
    """str: Represents the caption of the action.
        Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action."""
    HideIfUnsupportedInterface: bool
    """bool: Defines whether the UnSupported action can be visible and accessible. 
        If HideIfUnsupportedInterface is True, then the 
        IsSupportedInterface function is used for retrieving the value of the Supported property. In this case, if IsSupportedInterface returns False, then this action is always inaccessible and invisible. 
        If HideIfUnsupportedInterface is False, then this action can be visible or invisible depending on other properties. In this case, descendant classes or application objects should call IsSupportedInterface to retrieve the visibility and accessibility of the action."""
    ShortCutPressed: bool
    """bool: Specifies that the action is fired by pressing a keyboard key, not by clicking with the mouse.
        ShortCutPressed is a read-only property. When ShortCutPressed is True, it specifies that the action is fired by pressing a keyboard key, and not by clicking a control with the mouse."""
    Supported: bool
    """bool: Defines whether the action can work on the current platform and CPU architecture. 
        Supported is a read-only property. Supported defines whether the action can work on the current platform and CPU architecture. The value of this property is defined by the UnsupportedArchitectures  and UnsupportedPlatforms  properties and also by the IsSupportedInterface function. If Supported is False, then this action is always inaccessible and invisible."""
    Target: Component
    """Component: Defines the component for which the action is executed.
        Target is a read-only property. Target defines the component for which the action is executed. It can be nil. In the case where several controls can be called with one shortcut, Target corresponds to the first matched control."""
    Text: str
    """str: Represents the caption of the action.
        Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action's clients.
        Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
        In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+<accelerator_letter> key combination.  To show a single ampersand & character in a Text property specify doubled ampersand && characters.  Notice that & and _ are seen and can be used only under Windows."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomAction.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def IsDialogKey(self, Key: int, Shift: ShiftState) -> bool:
        """TCustomAction.IsDialogKey(Key: int, Shift: ShiftState) -> bool
        Checks whether the specified keyboard key corresponds to one of the action's shortcuts.
        IsDialogKey returns True if the keyboard key specified by the combination of Key and Shift corresponds to one of the action's shortcuts. Here:
        
        Key is a keyboard scan code. You can find constants for keyboard scan codes in the Constants section of the System.UITypes unit. These are vkXXXX constants (vkEscape, vkReturn, vkF1, and others).
        Shift specifies the combination of the ALT, CTRL, SHIFT, and CMD (only Mac) keys.
        The action's shortcuts are listed in the ShortCut and SecondaryShortCuts properties."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomActionList(ContainedActionList):
    """The base class for list of actions, without the published properties.
    FMX.ActnList.TCustomActionList inherits from System.Actions.TContainedActionList. All content below this line refers to System.Actions.TContainedActionList.
    The base class for list of actions, without the published properties.
    Implement TContainedActionList to work with common properties for all GUI application frameworks.
    Actions lists the actions maintained by the action list.
    The ActionCount property returns the number of actions in the list.
    OnStateChange sends a notification when the State changes."""
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Images: BaseImageList
    """BaseImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TContainedActionList.
        FMX.ActnList.TCustomActionList.Destroy inherits from System.Actions.TContainedActionList.Destroy. All content below this line refers to System.Actions.TContainedActionList.Destroy.
        Destroys an instance of TContainedActionList.
        This destructor is inherited from TComponent, see TComponent.Destroy for more information.
        
         See Also
        System.Actions.TContainedActionList.Create
        System.Classes.TComponent.Destroy"""
    def DialogKey(self, Key: int, Shift: ShiftState) -> bool:
        """TCustomActionList.DialogKey(Key: int, Shift: ShiftState) -> bool
        Evaluates an input key combination to determine whether it is a shortcut for one of the actions in the list.
        Typically, your applications do not need to call DialogKey explicitly. When the form's KeyDown method does not evaluate a shortcut key by some other means (such as an event handler), it calls DialogKey for every associated action list until it finds an action that can handle the shortcut.
        The action list's DialogKey method, in turn, checks the specified keystroke against the ShortCut property and SecondaryShortCuts properties of each action in the list. If it finds a match, it tells the action to handle the shortcut, and then returns True. If DialogKey cannot find an action to handle the shortcut, it returns False.
        DialogKey has the following parameters: 
        
        
        
        Parameter
        
        Description
        
        
        Key
        
        Is the key code for the potential shortcut key.
        
        
        Shift
        
        Specifies the state of the Shift, Alt, and Ctrl keys that may be combined with Key."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomBindingsList(Component):
    """Represents the base class for the binding list.
    The TCustomBindingsList class implements a list of binding expressions, output converters, method scopes, and other binding list-related functionality."""
    __hash__: ClassVar[None] = ...
    BindCompCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    BindComps: ContainedBindComponent
    """ContainedBindComponent:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DependencyList: IDependencyList
    """IDependencyList: Embarcadero Technologies does not currently have any additional information."""
    Methods: Methods
    """Methods: Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic."""
    OutputConverters: OutputConverters
    """OutputConverters: Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic."""
    Owner: Any
    """Returns the Component Owner"""
    PromptDeleteUnused: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseAppManager: bool
    """bool: Specifies whether the bindings list uses the global application manager for managed bindings."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TCustomBindingsList.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.Components.TCustomBindingsList.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.Components.TCustomBindingsList.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TCustomBindingsList.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Enumerates all child components.
        Data.Bind.Components.TCustomBindingsList.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
        Enumerates all child components.
        GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
        GetChildren expects a TGetChildProc routine that receives all enumerated components. 
        Root represents the owner of the components that will be enumerated.
        This method does nothing in TComponent and is expected to be overridden in descendants."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        Data.Bind.Components.TCustomBindingsList.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
        Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetMethodsScope(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetOutputConverter(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Notify(self, AObject: Object, AProperty: str) -> None:
        """TCustomBindingsList.Notify(AObject: Object, AProperty: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomBufferedLayout(Layout):
    """Wrapper for Delphi TCustomBufferedLayout"""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomBufferedLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Controls.TControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomButton(PresentedTextControl):
    """Represents the base class for all buttons.
    TCustomButton is the base class for all button components such as TButton. If you need to create a custom button for your application, then you should consider deriving your component from TCustomButton, as it already implements basic button drawing and operating functionality."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    ModalResult: int
    '''int: Determines whether and how the button closes its (modal) parent form.
        Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
        For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).'''
    RepeatClick: bool
    """bool: Specifies whether to automatically repeat the button click after a preset time.
        Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
        The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
        Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button's OnClick event."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCustomButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TCustomButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TCustomButton.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        Sets a new Scene for the current control.
        FMX.StdCtrls.TCustomButton.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomCalendar(StyledControl):
    """Wrapper for Delphi TCustomCalendar"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Date: float
    """float:"""
    DateTime: float
    """float:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    FirstDayOfWeek: CalDayOfWeek
    """CalDayOfWeek:"""
    Model: CalendarModel
    """CalendarModel:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDateSelected: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDayClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TodayDefault: bool
    """bool:"""
    WeekNumbers: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomCalendar.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TStyledControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomColorComboBox(CustomComboBox):
    """A TCustomComboBox is the base class for combo box components.
    FMX.Colors.TCustomColorComboBox inherits from FMX.ListBox.TCustomComboBox. All content below this line refers to FMX.ListBox.TCustomComboBox.
    A TCustomComboBox is the base class for combo box components.
    Inherit from TCustomComboBox to create a control that represents a specialized combo box."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Color: Any
    """Returns a integer with the color value"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DropDownKind: DropDownKind
    """DropDownKind: Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
        The TDropDownKind type is also used in the TComboEdit, 
        TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomColorComboBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TCustomColorComboBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomComboBox(StyledControl):
    """A TCustomComboBox is the base class for combo box components.
    Inherit from TCustomComboBox to create a control that represents a specialized combo box."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Count: int
    """int: Returns the total number of items in the drop-down list associated with the combo box."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DroppedDown: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsPressed: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the combo box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1."""
    Items: Strings
    """Strings: Specifies the items in the drop-down list.
        Use Items to get or set the list of items in the drop-down as strings.
        Use the ListItems property to access an item as a TListBoxItem object."""
    ListBox: ComboListBox
    """ComboListBox: Gets the drop-down list component of the combo box.
        The returned object is a TComboListBox."""
    ListItems: ListBoxItem
    """ListBoxItem:"""
    Selected: ListBoxItem
    """ListBoxItem: Gets the item that is currently selected in the combo box.
        Selected returns the selected item in the combo box as a TListBoxItem instance."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Clear(self, *args, **kwargs) -> Any:
        """Deletes all the items from the Items list.
        Call Clear to empty the combo box at run time."""
    def Create(self, AOwner: Component) -> None:
        """TCustomComboBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.ListBox.TCustomComboBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.ListBox.TCustomComboBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DropDown(self, *args, **kwargs) -> Any:
        """Opens the list of items.
        DropDown makes visible the list of items of the combo box."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TCustomComboBox.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        Sets a new Scene for the current control.
        FMX.ListBox.TCustomComboBox.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def Sort(self, Compare: FmxObjectSortCompare) -> None:
        """TCustomComboBox.Sort(Compare: FmxObjectSortCompare) -> None
        Sorts the children in the children list using the specified sorting procedure.
        FMX.ListBox.TCustomComboBox.Sort inherits from FMX.Types.TFmxObject.Sort. All content below this line refers to FMX.Types.TFmxObject.Sort.
        Sorts the children in the children list using the specified sorting procedure."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomComboEdit(ComboEditBase):
    """The base class, implementing the basic functionality, for edit boxes having a list of predefined choices.
    TCustomComboEdit extends TComboEditBase implementing the basic functionality for edit boxes having a list of predefined choices.
    TCustomComboEdit is a presented control. Its data model is TComboEditModel and presentation is TStyledComboEdit."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Count: int
    """int: Count returns the number of items contained by the ListBox object."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DropDownCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    DropDownKind: DropDownKind
    """DropDownKind: Defines whether to use TCustomListPicker pickers providing platform-specific drop-down lists to select string items.
        The TDropDownKind type is also used in the TComboEdit, 
        TComboBox, and TPopupBox controls to define whether to use the TCustomListPicker picker to provide platform-specific controls to select string items from drop-down lists."""
    DroppedDown: bool
    """bool: Returns whether the drop-down box associated with the current TComboEdit object is visible."""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    ItemHeight: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ItemIndex: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ItemWidth: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Items: Strings
    """Strings: Embarcadero Technologies does not currently have any additional information."""
    ListBoxResource: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Model: ComboEditModel
    """ComboEditModel: The data model representing the data used by the presentation of the current control.
        FMX.ComboEdit.TCustomComboEdit.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
        The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.
        
         See Also
        FMX.Controls.Model.TDataModel
        FMX.Controls.Presentation.TPresentedControl.Presentation
        FMX.Controls.Presentation.TPresentedControl.Create
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass"""
    OnClosePopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how this edit control  displays the text in terms of horizontal alignment. TextAlign can have one of the following, defined in TTextAlign, values:
        
        Center (default) aligns the text at the middle of the edit control.
        Leading aligns the text at the leftmost position inside the edit control.
        Trailing aligns the text at the rightmost position inside the edit control.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Clear(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TCustomComboEdit.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.ComboEdit.TCustomComboEdit.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomControlAction(CustomAction):
    """TCustomControlAction is the base class for the actions that can be associated with some of the controls.
    You can add a control action to a control by setting the Action property of the control, if it is supported. In the Object Inspector choose New Standard Action > No Category > TControl Action for the Action property."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomControlAction.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.Controls.TCustomControlAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomCornerButton(CustomButton):
    """Represents a TCustomButton control and, additionally, provides the tools to customize shapes of TCustomCornerButton control's corners.
    Use Corners to specify the corners to be customized. Use CornerType, XRadius, and YRadius to customize corners. See also TRectangle."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CornerType: CornerType
    """CornerType: Specifies the type of the corner customization in the TCustomCornerButton control.
        Values of CornerType are defined in the TCornerType: Round, Bevel, InnerRound, and InnerLine. These values define the following types of corner shape customizations: 
        
        
        CornerType applies to corners specified in the Corners set.
        XRadius and YRadius specify the distance from a corner to the start point of the corner customization, on the horizontal and vertical sides. 
        
        Note: If Corners is an empty set, or any of the XRadius and YRadius properties is zero, modifying the CornerType property has no visual effect."""
    Corners: Corners
    """Corners: Specifies which corners are customized by the CornerType, XRadius, and YRadius properties.
        By default, all four corners are customized. 
        Corners contains a set of values defined in the TCorner type: TopLeft, TopRight, BottomLeft, and BottomRight. Use the AllCorners constant to select all corners. 
        If Corners is an empty set, then no corner shape customization is used."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Sides: Sides
    """Sides: Specifies which sides of the control to display.
        A side is a button boundary between two adjacent corners or end points of corner customizations. End points of corner customizations are defined by XRadius and YRadius. A corner customization applies to corners included into the Corners set.
        By default, all sides of the control are displayed.
        Sides can contain a set of values defined in TSide: Top, Left, Bottom, and Right. 
        Use the AllSides constant to select all sides."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    XRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the horizontal sides of the button.
        How corners are customized is defined by the Corners,
        CornerType, XRadius, and YRadius properties."""
    YRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the vertical sides of the button.
        How corners are customized is defined by the Corners,
        CornerType, XRadius, and YRadius properties."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomCornerButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCustomCornerButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TCustomCornerButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomDateEdit(CustomDateTimeEdit):
    """Wrapper for Delphi TCustomDateEdit"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DateFormatKind: DTFormatKind
    """DTFormatKind:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    FirstDayOfWeek: CalDayOfWeek
    """CalDayOfWeek:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TodayDefault: bool
    """bool:"""
    WeekNumbers: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CopyToClipboard(self, *args, **kwargs) -> Any: ...
    def Create(self, AOwner: Component) -> None:
        """TCustomDateEdit.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TTextControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomDateTimeEdit(TextControl):
    """Wrapper for Delphi TCustomDateTimeEdit"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Date: float
    """float:"""
    DateTime: float
    """float:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Format: str
    """str:"""
    IsChecked: bool
    """bool:"""
    IsEmpty: bool
    """bool:"""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCheckChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnOpenPicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    ReadOnly: bool
    """bool:"""
    ShowCheckBox: bool
    """bool:"""
    ShowClearButton: bool
    """bool:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    Time: float
    """float:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CanInput(self, *args, **kwargs) -> Any: ...
    def CanObserve(self, ID: int) -> bool:
        """TCustomDateTimeEdit.CanObserve(ID: int) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def CanUsePicker(self, *args, **kwargs) -> Any: ...
    def ClosePicker(self, *args, **kwargs) -> Any: ...
    def CopyToClipboard(self, *args, **kwargs) -> Any: ...
    def Create(self, AOwner: Component) -> None:
        """TCustomDateTimeEdit.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TTextControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Controls.TTextControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def HasPicker(self, *args, **kwargs) -> Any: ...
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def IsPickerOpened(self, *args, **kwargs) -> Any: ...
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ObserverAdded(self, ID: int, Observer: IObserver) -> None:
        """TCustomDateTimeEdit.ObserverAdded(ID: int, Observer: IObserver) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ObserverToggle(self, AObserver: IObserver, Value: bool) -> None:
        """TCustomDateTimeEdit.ObserverToggle(AObserver: IObserver, Value: bool) -> None"""
    def OpenPicker(self, *args, **kwargs) -> Any: ...
    def PasteFromClipboard(self, *args, **kwargs) -> Any: ...
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomEdit(StyledControl):
    """TCustomEdit is the base class from which all FireMonkey edit boxes and memo controls are derived.
    TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:
    
    Basic text editing functions such as selecting text, modifying selected text, and case conversions.
    Ability to respond to changes in the contents of the text.
    Access control of the text for making it read-only or introducing a password character to hide the actual value.
    When not in focus, TCustomEdit does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.
    Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit, as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ButtonsContent: ContentEdit
    """ContentEdit: Returns the control that contains the edit buttons associated with the edit control."""
    Caret: CustomCaret
    """CustomCaret: Represents the caret of the control.
        Caret is of type TCaret."""
    CaretPosition: int
    """int: Provides access to the caret position in this edit control.
        Use CaretPosition to determine the position of the cursor in the edit control.
        CaretPosition indicates the horizontal character coordinate of the cursor, indexed from zero.
        Modify the value of the CaretPosition property to change the position of the cursor within the edit control. For the cursor to be visible, the edit control must have focus.
        For example, if CaretPosition is set to 4, then the cursor is at the fifth character. If the length of text in the edit control is shorter than 5, the cursor moves to the end of the string."""
    CharCase: EditCharCase
    """EditCharCase: It defines whether to implement the UPPER or lower case conversion to the memo's text."""
    CheckSpelling: bool
    """bool: Defines whether the spell-checking feature of the edit control is on or off.
        This property enables spell checking on the TEdit component. When set to True a red squiggly line appears underlining the words misspelled.  
        The spell checking is performed by an operating system service. It is only supported on iOS and OS X."""
    ControlType: ControlType
    """ControlType:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DefaultTextSettings: TextSettings
    """TextSettings: Stores a TTextSettings type object keeping the default values of the text representation properties.
        DefaultTextSettings is initialized in Create with the following values: 
        
        Font.Size := 11 ;          // depends on the platform     
        Font.Family = 'Tahoma';    // depends on the platform
        Font.Style := [] ;
        FontColor := TAlphaColorRec.Black;
        TextAlign := TTextAlign.Leading;
        VertTextAlign := TTextAlign.Center;
        
        The ApplyStyle method might load from a style the values of the following 
        DefaultTextSettings properties: FontColor, Font, 
        TextAlign, and VertTextAlign."""
    FilterChar: str
    """str: Specifies which characters are allowed to be typed into this edit control.
        The FilterChar property specifies a string containing individual characters that are allowed to be typed into this edit control.
        For instance, if you set FilterChar to '123abc', then only the a, b, and c letters and the 1, 2, and 3 numerals are allowed to be typed into this edit control. All other characters are ignored. However, note that the uppercase version of a, b, and c are not allowed by this filter string. If you want to add uppercase variants, then FilterChar should be set to '123abcABC'.
        To allow for all characters, set FilterChar to an empty string ('')."""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    FontColor: int
    """int: Specifies the color of the text in the edit control."""
    ImeMode: ImeMode
    """ImeMode: For internal use only.
        Do not use this member. It is for internal use only."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Determines the type of the virtual keyboard.
        Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
        Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).
        
        Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions."""
    KillFocusByReturn: bool
    """bool: Specifies whether to hide the virtual keyboard by clicking the Return key.
        When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard."""
    MaxLength: int
    """int: Specifies the maximum length of the text entered in this edit control.
        Set the MaxLength property in order to limit the maximum length of the text held by this edit control. For instance, if you want to be able to input strings of maximum 5 characters, set MaxLength to 5.
        Note that setting MaxLength to a value lower than the length of the actual display text does not affect the display. It only limits the number of characters while typing."""
    Model: CustomEditModel
    """CustomEditModel: The data model representing the data used by the presentation of the current control.
        FMX.Edit.TCustomEdit.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
        The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.
        
         See Also
        FMX.Controls.Model.TDataModel
        FMX.Controls.Presentation.TPresentedControl.Presentation
        FMX.Controls.Presentation.TPresentedControl.Create
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTyping: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnValidate: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnValidating: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    Password: bool
    """bool: Specifies whether this edit control shows its characters or not.
        Set the Password property to True to make this edit control hide its characters for password-like input. Set Password to False to make this edit control show all its characters."""
    ReadOnly: bool
    """bool: Determines whether you can change the text of this edit control.
        To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
        Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    ResultingTextSettings: TextSettings
    """TextSettings: Keeps final values of text representation properties. These values are really used to draw texts in a control. 
        ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
        To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        RecalculateTextSettings updates the ResultingTextSettings."""
    ReturnKeyType: ReturnKeyType
    """ReturnKeyType: Indicates the type of action that the edit control performs when you are editing the text of the control and you press the return key on the virtual keyboard. The run-time platform uses this value to determine the type of return button that it displays on the virtual keyboard for the edit control.
        The value of ReturnKeyType does not affect the actual action that the edit control performs when you press the return key. To define that action, use the OnKeyUp event.
        
        Platform Support
        This property only has effect on Android and iOS."""
    SelLength: int
    """int: Specifies the number of characters that are selected.
        Read SelLength to determine the length, in bytes, of the selected text. This is the same as the number of characters, unless you are using a multibyte character set. Set SelLength to change the selection to consist of the first SelLength bytes starting at SelStart.
        
        Tip: Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set."""
    SelStart: int
    """int: Specifies the position of the first selected character in the text.
        Read SelStart to determine the position of the first selected character, where 0 indicates the first character. If there is no selected text, SelStart indicates the position of the cursor. Set SelStart to remove the current selection and to position the cursor just before the indicated character.
        To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection."""
    SelText: str
    """str: Specifies the selected portion of the edit control's text.
        Read SelText to determine the value of the selected text. Set SelText to replace the selected text with a new string. If there is no selection, but the edit control has focus, set SelText to insert a new string into the text, at the cursor."""
    SelectionFill: Brush
    """Brush: Specifies the color and pattern used to fill the font of the selected text or to stroke the outline of it.
        Read the SelectionFill property to get a TBrush object with the color and pattern used to fill the font of selected text displayed, or to stroke the outline of it."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Contains the text displayed by this edit control.
        Use the Text property to read the text of this edit control or to specify a new string to be displayed."""
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how this edit control  displays the text in terms of horizontal alignment. TextAlign can have one of the following, defined in TTextAlign, values:
        
        Center (default) aligns the text at the middle of the edit control.
        Leading aligns the text at the leftmost position inside the edit control.
        Trailing aligns the text at the rightmost position inside the edit control.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextContentRect: RectF
    """RectF: Embarcadero Technologies does not currently have any additional information."""
    TextPrompt: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextPrompt to cue the user about the kind of entry that is expected in the text field. The TextPrompt is grayed (like a watermark), cannot be scrolled at run time, and is cleared from the entry field as soon as the user begins to type into the edit field.
        The following image contains a design-time preview of setting the TextPrompt property:"""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Typing: bool
    """bool: Specifies whether the user is typing something in this edit control.
        The Typing property is True if the user is typing something into this edit control, False otherwise.
        When any printable character is typed, the Typing property is set to True. A printable character is any character that is not a control character.
        When the ENTER key is pressed, the Typing property is set to False."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of vertical alignment.
        The VertTextAlign property specifies how the TCustomEdit control displays the text in terms of vertical alignment. VertTextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a vertical axis, at the middle of the TCustomEdit object.
        Leading--aligns the text on a vertical axis, at the topmost position inside the TCustomEdit object.
        Trailing--aligns the text on a vertical axis, at the bottommost position inside the TCustomEdit object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that VertTextAlign corresponds to VertAlign."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CopyToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text in the edit control to the Clipboard, in plain text format.
        Use CopyToClipboard to replace the contents of the Clipboard with the selected text. CopyToClipboard does not clear the Clipboard if no text is selected. If no text is selected, CopyToClipboard does nothing."""
    def Create(self, AOwner: Component) -> None:
        """TCustomEdit.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.Edit.TCustomEdit.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def CutToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text to the Clipboard, in plain text format, and then deletes the selection.
        Use CutToClipboard to replace the contents of the Clipboard with the selected text while clearing the selected text. If no text is selected, CutToClipboard does nothing."""
    def DeleteSelection(self, *args, **kwargs) -> Any:
        """Removes the selected text from the edit control.
        Use DeleteSelection to delete the selected text from the edit control. If no text is selected, DeleteSelection does nothing. If all the text is selected, DeleteSelection clears all the text."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.Edit.TCustomEdit.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def GoToTextBegin(self, *args, **kwargs) -> Any:
        """Moves the cursor to the beginning of the text in the edit control."""
    def GoToTextEnd(self, *args, **kwargs) -> Any:
        """Moves the cursor to the end of the text in the edit control."""
    def HasSelection(self, *args, **kwargs) -> Any:
        """Returns true if any selection exists in the edit box, false otherwise.
        Use HasSelection in order to check if any part of the text is selected."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def PasteFromClipboard(self, *args, **kwargs) -> Any:
        """Pastes the plain text contents of the Clipboard text into the edit control.
        Use PasteFromClipboard to paste the plain text contents held by the Clipboard into the edit control. If the Clipboard does not have a plain text content, PasteFromClipboard does nothing. PasteFromClipboard does not clear the contents of this edit control."""
    def Replace(self, AStartPos: int, ALength: int, AStr: str) -> None:
        """TCustomEdit.Replace(AStartPos: int, ALength: int, AStr: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ResetSelection(self, *args, **kwargs) -> Any:
        """Resets the selection from an edit box.
        ResetSelection sets the CaretPosition property with the start position of the selection and resets the value of the SelLength property to 0. If no text is selected, the ResetSelection property does nothing."""
    def SelectAll(self, *args, **kwargs) -> Any:
        """Selects all the characters of the displayed Text at once.
        Equivalent to the CTRL+A key combination on Windows, or Command+A on OS X.
        SelectAll does not change the current CaretPosition."""
    def SelectWord(self, *args, **kwargs) -> Any:
        """SelectWord assigns to the FMX.Edit.TCustomEdit.SelLength property the length of the first word found if this exists. 
        If several words exist in the text, the procedure SelectWord checks if the cursor position is the start position of a word. If not, it searches for the closest word from the left of cursor position."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomEditBox(CustomEdit):
    """Base class for all edit boxes that manipulate only numerical values.
    TCustomEditBox is the base class for all edit boxes that manipulate only numerical values, such as a TNumberBox. TCustomEditBox implements functionality to set the minimum and maximum value that this edit box can display, and also the possibility to specify the number of decimal digits of the displayed value.
    If you want to create your own custom edit box control that manipulates number data, then you should derive from TCustomEditBox."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DecimalDigits: int
    """int: Specifies the number of decimal positions of the displayed Value.
        This property has effect only if the ValueType property is set to Float."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    FontColor: int
    """int: Specifies the color of the text in the edit control."""
    HorzIncrement: float
    """float: Represents the value with which the number is incremented or decremented when, while holding down the mouse button, you move the mouse horizontally.
        HorzIncrement represents the value added or decreased from the number when, while holding down the mouse button, you move the mouse to the left or to the right."""
    Max: float
    """float: Contains the maximum value the number displayed by an edit control can show.
        Max sets the maximum value that can be displayed by edit controls that manipulate only numerical values."""
    Min: float
    """float: Contains the minimum value the number displayed by an edit control can show.
        Min sets the minimum value that can be displayed by edit controls that manipulate only numerical values."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    Text: str
    """str: Contains the text displayed by this edit control.
        Use the Text property to read the text of this edit control or to specify a new string to be displayed."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Value: float
    """float: Contains the default number displayed by an edit control."""
    ValueRange: ValueRange
    """ValueRange: Provides access to the Value and its Min and Max boundaries."""
    ValueType: NumValueType
    """NumValueType: Defines the integer or float type of the Value number displayed by the edit box control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed and loads the control presentation.
        FMX.EditBox.TCustomEditBox.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
        Responds after the last constructor has executed and loads the control presentation.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomEditBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.EditBox.TCustomEditBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ValueDec(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def ValueInc(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomForm(CommonCustomForm):
    """TCustomForm represents the base class from which you derive other windows such as dialog boxes and forms.
    Create a subclass derived from TCustomForm if you want to create new forms such as dialog boxes. A derived form can contain one or more FireMonkey objects, such as TLabel, TComboBox, and so on.
    Note that every descendant of TCustomForm is a 2D FireMonkey form or dialog box."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    ActiveControl: Control
    """Control: Specifies the active control on the form.
        Use ActiveControl to get or set the active control (having the focus) on the form. Only one control can have the focus at a given time, in an application.
        If the form does not have the focus, ActiveControl is the control, on the form, that receives the focus when the form itself receives the focus."""
    Canvas: Canvas
    """Canvas: Provides access to the drawing area of the form.
        Use Canvas to draw directly on the client area of the form."""
    Fill: Brush
    """Brush: Specifies the way the background on this form is filled.
        Use Fill to get or set the brush that defines the way the background of this form is painted (gradient, solid, and so on).
        
        Tip: Using a brush for Fill overrides the functionality of the Transparency property."""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    Quality: CanvasQuality
    """CanvasQuality: Embarcadero Technologies does not currently have any additional information."""
    StyleLookup: str
    """str: Specifies the name of the style to look up and apply to this form. The FireMonkey Component Design help topic shows, among other useful things related to component designing, how to apply a style to a TPanel component."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomForm.Create(AOwner: Component) -> None
        Creates and initializes this form.
        FMX.Forms.TCustomForm.Create inherits from FMX.Forms.TCommonCustomForm.Create. All content below this line refers to FMX.Forms.TCommonCustomForm.Create.
        Creates and initializes this form.
        Create calls the inherited Create to create this form. Create
        retrieves the IFMXWindowService,  IFMXCursorService,  
        IFMXFullScreenWindowService, and
        IFMXWindowsTouchService services.  
        Create calls  InitializeNewForm to initialize such form parameters as bounds, width and height, border icons, style, border style, and client size for the form. 
        AOwner specifies the owner of this form. 
        An AOwner (usually the application) is responsible for freeing the created form.
        Most applications do not call this constructor, but rather instantiate a descendant of TForm that is defined in the forms designer. Forms added to an application at design time are created automatically."""
    def CreateNew(self, AOwner: Component, Dummy: int) -> None:
        """TCustomForm.CreateNew(AOwner: Component, Dummy: int) -> None"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Forms.TCustomForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Ends updating all the child controls in this form.
        FMX.Forms.TCustomForm.EndUpdate inherits from FMX.Forms.TCommonCustomForm.EndUpdate. All content below this line refers to FMX.Forms.TCommonCustomForm.EndUpdate.
        Ends updating all the child controls in this form.
        EndUpdate ends updating all the child controls placed on this form, finalizing any updates you might have performed on the form or on multiple children. EndUpdate signals the end of an update operation and must be preceded by BeginUpdate and by the updates themselves."""
    def InitializeNewForm(self, *args, **kwargs) -> Any:
        """Performs several initializations required by this form.
        FMX.Forms.TCustomForm.InitializeNewForm inherits from FMX.Forms.TCommonCustomForm.InitializeNewForm. All content below this line refers to FMX.Forms.TCommonCustomForm.InitializeNewForm.
        Performs several initializations required by this form.
        These initializations include bounds, width and height, border icons, border style, and client size for the form. InitializeNewForm is used by the form constructors."""
    def LoadProps(self) -> Any:
        """TCommonCustomForm.LoadProps()
        Load properties from a .pydfm file"""
    def PaintTo(self, Canvas: Canvas) -> None:
        """TCustomForm.PaintTo(Canvas: Canvas) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def RecreateResources(self, *args, **kwargs) -> Any:
        """Recreates the canvas  where the form renders itself."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomGrid(CustomPresentedScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AniCalculations: AniCalculations
    """AniCalculations: Returns the instance to the class that provides scrolling physics calculations.
        AniCalculations is only available for style presentation. For native presentation, it returns null/nil."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    BottomRow: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    Col: int
    """int: The column number of the selected cell, or -1 if there is no cell selected."""
    ColumnCount: int
    """int: Specifies the number of columns in the grid.
        Read ColumnCount to determine the number of entries in the Columns array."""
    ColumnIndex: int
    """int: Specifies the index of the column that contains the selected cell.
        Use ColumnIndex at run time to determine the current column in the grid. Setting ColumnIndex moves the focus to the cell in the current row that is in the new column. The first column has an index of 0, the second column has an index of 1, and so on."""
    Columns: Column
    """Column:"""
    DefaultDrawing: bool
    """bool: Determines whether cells are drawn using the default drawing method (True) or using a user-defined drawing method (False)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    EditorMode: bool
    """bool: Determines whether the grid control is in the edit mode (True) or not (False)."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Images: CustomImageList
    """CustomImageList: Specifies the list of images associated with this grid control. 
        Images from the Images collection can be shown in cells of the TGlyphColumn type column."""
    IsUsedInBinding: bool
    """bool: This property is set by the LiveBinding.
        If this property is True, you cannot change the  OnSetValue and the  OnCallbackGetValue."""
    LeftColumn: int
    """int: Number of the first column that is visible, either completely or partially, from the left-hand side of the grid."""
    Model: GridModel
    """GridModel: The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns."""
    OnCallbackGetValue: Any
    """Callable[[Object, int, int, Proc<System.Rtti.TValue>], None]:"""
    OnCellClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnCellDblClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnColumnMoved: Callable[[Column,int,int],None]
    """Callable[[Column, int, int], None]:"""
    OnCreateCustomEditor: Callable[[Object,Column,StyledControl],None]
    """Callable[[Object, Column, StyledControl], None]:"""
    OnDrawColumnBackground: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnCell: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnHeader: Callable[[Object,Canvas,Column,RectF],None]
    """Callable[[Object, Canvas, Column, RectF], None]:"""
    OnEditingDone: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnGetValue: Callable[[Object,int,int,Value],None]
    """Callable[[Object, int, int, Value], None]:"""
    OnHeaderClick: Callable[[Column],None]
    """Callable[[Column], None]:"""
    OnSelChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectCell: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnSetValue: Callable[[Object,int,int,Value],None]
    """Callable[[Object, int, int, Value], None]:"""
    Options: GridOptions
    """GridOptions: Defines how grid controls look like and how they behave."""
    ReadOnly: bool
    """bool: Specifies whether the cells in this grid can be modified or not.
        Use ReadOnly at run time to determine whether the cells in this grid can be edited. If ReadOnly is True, then you can only read and view the contents of the cells without the ability to affect the grid in any way."""
    RightColumn: int
    """int: Number of the first column that is visible, either completely or partially, from the right-hand side of the grid."""
    Row: int
    """int: Number of the selected row."""
    RowCount: int
    """int: Specifies the number of rows in the grid.
        The value of RowCount includes the scrollable rows in the grid, but not the fixed row with the headers.
        
        Read RowCount to determine the number of rows in the grid.
        Set RowCount to add or delete rows at the bottom of the grid."""
    RowHeight: float
    """float: Specifies the height of each row of this grid, in pixels.
        Read RowHeight to determine the size of each row in the grid. If the underlying grid is too tall to appear in the control, then the user must scroll to see the entire content of the grid."""
    Selected: int
    """int: Specifies the row where you are currently positioned within the grid.
        Set the Selected property to any positive numerical value to make the specific row selected. Read Selected to obtain the index of the row where you are currently positioned within the grid.
        The first row has an index of 0, the second one has an index of 1, and so on."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TopRow: int
    """int: Specifies the index of the first visible scrollable row in the grid.
        Read TopRow to determine the index of the first row in the scrollable region that is visible. Set TopRow to scroll the rows in the grid so that the row with the TopRow index is the first row after the fixed rows."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    VisibleColumnCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    VisibleRows: int
    """int: Indicates the number of scrollable rows that are visible in the grid.
        Use VisibleRows to determine the number of scrollable rows that are fully visible in the grid. VisibleRows includes any partially visible rows on the top and bottom of the grid."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        Performs any necessary actions before the first destructor is called.
        FMX.Grid.TCustomGrid.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def CanEdit(self, *args, **kwargs) -> Any:
        """Determines whether the selected cell can be edited (True) or not (False) based on the current configuration of the corresponding column and the grid."""
    def CellByPoint(self, X: float, Y: float, ACol: int, ARow: int) -> bool:
        """TCustomGrid.CellByPoint(X: float, Y: float, ACol: int, ARow: int) -> bool
        Fills ACol and ARow with the column and row numbers that identify the cell located at the specified X and Y coordinates, and returns True on success or False otherwise."""
    def CellRect(self, ACol: int, ARow: int) -> Rect:
        """TCustomGrid.CellRect(ACol: int, ARow: int) -> Rect
        Returns the coordinates of the cell at the specified row and column.
        ACol and ARow are 0-based. You can specify values equal to ColumnCount or RowCount to get the coordinates of an non-existent cell that is next to an existing cell.
        If the specified column or row numbers are not valid, CellRect returns coordinates (-1, -1, -1, -1)."""
    def ClearColumns(self, *args, **kwargs) -> Any:
        """Removes and destroys all columns."""
    def ColumnByIndex(self, Idx: int) -> Column:
        """TCustomGrid.ColumnByIndex(Idx: int) -> Column
        Returns the column with the given index.
        If the column does not exist, ColumnByIndex returns nil."""
    def ColumnByPoint(self, X: float, Y: float) -> Column:
        """TCustomGrid.ColumnByPoint(X: float, Y: float) -> Column
        Returns the column at the given left and top coordinates.
        If the column does not exist, ColumnByPoint returns nil."""
    def Create(self, AOwner: Component) -> None:
        """TCustomGrid.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.Grid.TCustomGrid.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.Grid.TCustomGrid.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def DisplayCells(self, TopLeft: GridModel.TCoord, BottomRight: GridModel.TCoord) -> bool:
        """TCustomGrid.DisplayCells(TopLeft: GridModel.TCoord, BottomRight: GridModel.TCoord) -> bool
        Determines the cells that are visible, either completely or partially, fills TopLeft with the coordinates of the top-left visible cell, fills BottomRight with the coordinates of the bottom-right visible cell, and returns True on success or False otherwise."""
    def GetUnusedViewportWidth(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def RowByPoint(self, X: float, Y: float) -> int:
        """TCustomGrid.RowByPoint(X: float, Y: float) -> int
        Returns the index of row at the given left and top coordinates.
        If the row does not exist, RowByPoint returns -1, otherwise a positive numerical value is returned. Keep in mind that 0 is the first row, 1 is the second row, and so on."""
    def ScrollToSelectedCell(self, *args, **kwargs) -> Any:
        """Changes the viewport position so that the selected cell is visible."""
    def SelectCell(self, Col: int, Row: int) -> None:
        """TCustomGrid.SelectCell(Col: int, Row: int) -> None
        Selects the cell with the specified index of column and rows.
        The DoSelectCell method occurs before the change and the DoSelChanged method occurs after the change."""
    def SelectColumn(self, Value: int) -> None:
        """TCustomGrid.SelectColumn(Value: int) -> None
        Selects the cell with the specified column index and old row index."""
    def SelectRow(self, Value: int) -> None:
        """TCustomGrid.SelectRow(Value: int) -> None
        Selects the cell with the specified row index and old column index."""
    def SetTopLeft(self, ACol: int, ARow: int) -> None:
        """TCustomGrid.SetTopLeft(ACol: int, ARow: int) -> None
        Changes the viewport position so that the cell at the specified column number and row number is located on the top-left corner."""
    def TextWidthToColWidth(self, ATextLength: int, ACaption: str) -> float:
        """TCustomGrid.TextWidthToColWidth(ATextLength: int, ACaption: str) -> float
        Embarcadero Technologies does not currently have any additional information."""
    def UnloadPresentation(self, *args, **kwargs) -> Any:
        """Unloads the previously-loaded presentation of your control.
        FMX.Grid.TCustomGrid.UnloadPresentation inherits from FMX.Controls.Presentation.TPresentedControl.UnloadPresentation. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.UnloadPresentation.
        Unloads the previously-loaded presentation of your control.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.LoadPresentation
        FMX.Controls.Presentation.TPresentedControl.ReloadPresentation"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomImageList(BaseImageList):
    """Wrapper for Delphi TCustomImageList"""
    __hash__: ClassVar[None] = ...
    CacheSize: int
    """int:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Destination: DestinationCollection
    """DestinationCollection:"""
    Dormant: bool
    """bool:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Source: SourceCollection
    """SourceCollection:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AddOrSet(self) -> Any:
        """TCustomImageList.AddOrSet()
        Adds or replaces several files in the source collection, and adds the item to the destination collection if it does not exist."""
    @overload
    def Assign(self, Source: Persistent) -> None:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    @overload
    def Assign(self, Source) -> Any:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    @overload
    def Assign(self, Source) -> Any:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BestSize(self) -> Any:
        """TCustomImageList.BestSize()
        Tries to find, in the source collection, the bitmap item specified by name. This method trying to determine the maximum size of layer, which less than input size. If TLayer.MultiResBitmap has multiple images for different scales, then the search is performed among all images."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Bitmap(self, Size: SizeF, Index: int) -> Bitmap:
        """TCustomImageList.Bitmap(Size: SizeF, Index: int) -> Bitmap"""
    def BitmapExists(self, Index: int) -> bool:
        """TCustomImageList.BitmapExists(Index: int) -> bool"""
    def BitmapItemByName(self) -> Any:
        """TCustomImageList.BitmapItemByName()
        Tries to find, in the source collection, the bitmap item specified by name."""
    def ClearCache(self, Index: int) -> None:
        """TCustomImageList.ClearCache(Index: int) -> None"""
    def Create(self, AOwner: Component) -> None:
        """TCustomImageList.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Draw(self, Canvas: Canvas, Rect: RectF, Index: int, Opacity: float) -> bool:
        """TCustomImageList.Draw(Canvas: Canvas, Rect: RectF, Index: int, Opacity: float) -> bool"""
    def DrawBitmapToCanvas(self, Canvas: Canvas, Bitmap: Bitmap, SrcRect: Rect, DstRect: Rect, Fast: bool) -> None:
        """TCustomImageList.DrawBitmapToCanvas(Canvas: Canvas, Bitmap: Bitmap, SrcRect: Rect, DstRect: Rect, Fast: bool) -> None"""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def UpdateImmediately(self, *args, **kwargs) -> Any: ...
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkControlToField(LinkControlToFieldDelegate):
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Binding: ExpressionsBindComponent
    """ExpressionsBindComponent: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    ControlMemberName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Owner: Any
    """Returns the Component Owner"""
    Track: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def ClearExpressionProperties(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkControlToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
        Destroys an instance of the TContainedBindComponent class."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkControlToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
        Data.Bind.Components.TCustomLinkControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
        Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkListControlToField(LinkControlToFieldDelegate):
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoBufferCount: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    BindLink: CustomBindGridListLink
    """CustomBindGridListLink: Embarcadero Technologies does not currently have any additional information."""
    BufferCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    ControlMemberName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    FillBreakCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional."""
    FillBreakFieldName: str
    """str: Specifies the field used to determine a break. This property is optional."""
    FillBreakGroups: FillBreakGroups
    """FillBreakGroups: Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional."""
    FillExpressions: FormatExpressions
    """FormatExpressions: Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
        For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property."""
    FillHeaderCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional."""
    FillHeaderExpressions: FormatExpressions
    """FormatExpressions: Specifies a collection of expressions to fill a list header. This property is optional."""
    FillHeaderFieldName: str
    """str: Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking."""
    ListItemStyle: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnFilledList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFilledListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    OnFillingList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFillingListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def ClearExpressionProperties(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkListControlToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkListControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkListControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
        Destroys an instance of the TContainedBindComponent class."""
    def FillList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkListControlToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkListControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
        Data.Bind.Components.TCustomLinkListControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
        Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkPropertyToField(LinkPropertyToFieldDelegate):
    """Wrapper for Delphi TCustomLinkPropertyToField"""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool:"""
    AutoActivate: bool
    """bool:"""
    BindLink: CustomBindLink
    """CustomBindLink:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    CustomFormat: str
    """str:"""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource:"""
    LookupKeyFieldName: str
    """str:"""
    LookupValueFieldName: str
    """str:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanActivate(self, Sender: Component) -> bool:
        """TCustomLinkPropertyToField.CanActivate(Sender: Component) -> bool
        Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
        The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise."""
    def ClearGeneratedExpressions(self, Sender: Component) -> None:
        """TCustomLinkPropertyToField.ClearGeneratedExpressions(Sender: Component) -> None
        Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkPropertyToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkPropertyToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Loaded(self, *args, **kwargs) -> Any:
        """Initializes the component after the form file has been read into memory.
        Do not call the protected Loaded method. The streaming system calls this method after it loads the component's form from a stream.
        When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.
        
        Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
        As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.
        
        Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call."""
    def RequiresControlHandler(self, *args, **kwargs) -> Any:
        """Used internally for observing purposes."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomListBox(ScrollBox):
    """A TCustomListBox is the base class for list box components.
    Inherits from TCustomListBox to create a control that represents a specialized list box.
    
    List Box Events
    TCustomListBox has events that are generic to the list box control, and other events that are specific to the items:
    
    Events that are generic to the list box control: Events such as OnClick, OnDblClick, OnEnter, and OnMouseDown are inherited events, and they refer to the event that occurs in the list box control.
    Events that are specific to the items of the list box: Events such as OnItemClick, OnChange, OnChangeCheck, OnCompare, and OnDragChange are specific to the list box item, and they refer to events that occur in the items of the list box.
    Therefore it is important to see, for example, the difference between OnClick that occurs when the list box is clicked, and OnItemClick that occurs when a list box item is clicked.
    See the full list of TCustomListBox events in FMX.ListBox.TCustomListBox_Events."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    BorderHeight: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Count: int
    """int: Determines the number of items in the list box."""
    DefaultItemStyles: ListBoxItemStyleDefaults
    """ListBoxItemStyleDefaults: Embarcadero Technologies does not currently have any additional information."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    FilterPredicate: Any
    """Predicate<System.string>: Embarcadero Technologies does not currently have any additional information."""
    GroupingKind: ListGroupingKind
    """ListGroupingKind: Embarcadero Technologies does not currently have any additional information."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    ItemDown: ListBoxItem
    """ListBoxItem: Embarcadero Technologies does not currently have any additional information."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the list box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1.
        To get the actual item that is selected, use the Selected property."""
    Items: Strings
    """Strings: Specifies the items in the list box.
        Use Items to get or set the list of items in the list box as strings.
        Use the ListItems property to access an item by specifying its index. This property returns the item as a TListBoxItem object.
        
        Adding Items
        To add items as TListBoxItem at design-time, see ListBox Items Editor.
        To add items as TStrings at design-time, see String List editor."""
    ListItems: ListBoxItem
    """ListBoxItem:"""
    MultiSelect: bool
    """bool: Specifies whether multiple items can be selected in the list.
        If MultiSelect is set to True, you can select more than one item from the list, otherwise you are limited to one item."""
    OnItemClick: Callable[[CustomListBox,ListBoxItem],None]
    """Callable[[CustomListBox, ListBoxItem], None]:"""
    Selected: ListBoxItem
    """ListBoxItem: Returns the item that is currently selected.
        If no item is selected, it returns nil.
        To obtain the index of the item that is currently selected, use the ItemIndex property."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Assign(self, Source: Persistent) -> None:
        """TCustomListBox.Assign(Source: Persistent) -> None
        Assigns the Source object to the current object.
        Assign copies the elements from Source to the current object, if Source is a TStrings object."""
    def Clear(self, *args, **kwargs) -> Any:
        """Deletes all the items from the list.
        Clear removes the items from the list box and also frees the memory allocated for them. The items in the list box are stored as TListBoxItem objects."""
    def ClearSelection(self, *args, **kwargs) -> Any:
        """Deselects all the selected items from the list box.
        If no items are selected before calling ClearSelection, nothing happens."""
    def Create(self, AOwner: Component) -> None:
        """TCustomListBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.ListBox.TCustomListBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.ListBox.TCustomListBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DragChange(self, SourceItem: ListBoxItem, DestItem: ListBoxItem) -> bool:
        """TCustomListBox.DragChange(SourceItem: ListBoxItem, DestItem: ListBoxItem) -> bool
        Generates an OnDragChange event.
        DragChange is called automatically after a drag-and-drop operation."""
    def FirstSelectedItemFrom(self, Item: ListBoxItem) -> ListBoxItem:
        """TCustomListBox.FirstSelectedItemFrom(Item: ListBoxItem) -> ListBoxItem
        Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def ItemByIndex(self, Idx: int) -> ListBoxItem:
        """TCustomListBox.ItemByIndex(Idx: int) -> ListBoxItem
        Returns the item at the index specified by Idx."""
    def ItemByPoint(self, X: float, Y: float) -> ListBoxItem:
        """TCustomListBox.ItemByPoint(X: float, Y: float) -> ListBoxItem
        Returns the item at the specified point.
        Call ItemByPoint to get the item that contains in its bounds the point specified by X and Y."""
    def ItemsExchange(self, Item1: ListBoxItem, Item2: ListBoxItem) -> None:
        """TCustomListBox.ItemsExchange(Item1: ListBoxItem, Item2: ListBoxItem) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def LastSelectedItemFrom(self, Item: ListBoxItem) -> ListBoxItem:
        """TCustomListBox.LastSelectedItemFrom(Item: ListBoxItem) -> ListBoxItem
        Embarcadero Technologies does not currently have any additional information."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def NotifyInflated(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def ScrollToItem(self, Item: ListBoxItem) -> None:
        """TCustomListBox.ScrollToItem(Item: ListBoxItem) -> None
        Scrolls the content so that the Item is visible."""
    def SelectAll(self, *args, **kwargs) -> Any:
        """Selects all the items in the list.
        SelectAll works only if MultiSelect is set to True."""
    def SelectRange(self, Item1: ListBoxItem, Item2: ListBoxItem) -> None:
        """TCustomListBox.SelectRange(Item1: ListBoxItem, Item2: ListBoxItem) -> None
        Selects all the items between two given items.
        SelectRange selects the items between Item1 and Item2 (including Item1 and Item2)  and deselects any other previously selected items.
        SelectRange works only if MultiSelect is set to True."""
    def Sort(self, Compare: FmxObjectSortCompare) -> None:
        """TCustomListBox.Sort(Compare: FmxObjectSortCompare) -> None
        Sorts components of the layout based on the comparison function Compare. 
        FMX.ListBox.TCustomListBox.Sort inherits from FMX.Layouts.TCustomScrollBox.Sort. All content below this line refers to FMX.Layouts.TCustomScrollBox.Sort.
        Sorts components of the layout based on the comparison function Compare. 
        TFmxObjectSortCompare is declared as:
        
        TFmxObjectSortCompare = function(item1, item2: TFmxObject): Integer;"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomListView(AppearanceListView):
    """Wrapper for Delphi TCustomListView"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMediaCodec(Object):
    """Base class for media codecs.
    TCustomMediaCodec is an abstract class that defines a media codec.
    Use TMediaCodecManager to register custom media codecs to extend FireMonkey audio/video features."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CreateFromFile(self, AFileName: str) -> Media:
        """TCustomMediaCodec.CreateFromFile(AFileName: str) -> Media
        Creates a TMedia from a specified file.
        The AFileName parameter specifies the name of the file from which the TMedia is created.
        Do not use CreateFromFile explicitly in applications. Use TMediaCodecManager to access and manage media codecs."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMediaPlayerAction(CustomAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    CustomText: str
    """str: CustomText is a user text.
        Some actions can, by default, automatically set the Text property. For example, in the TFileExit standard action, the Text property has the Quit <Application.Title> value. To set your own value, set the value of the Text property to the value of the CustomText property."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the action."""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomMediaPlayerAction.Create(AOwner: Component) -> None
        Instantiates and initializes a TCustomMediaPlayerAction object.
        Applications do not need to call Create directly. Actions are created automatically when you add them to a TActionList component using New > New Standard Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TCustomMediaPlayerAction.HandlesTarget(Target: Object) -> bool
        Whether Target is appropriate for the action (True) or not (False).
        HandlesTarget ignores the specified Target parameter, actually. Regardless of the specified target, HandlesTarget returns True provided that:
        
        The platform where your application is running supports this action.
        Your action does not have any event handler assigned to its OnExecute event.
        You have an instance of TMediaPlayer in the MediaPlayer property of your action."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMemo(CustomPresentedScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoSelect: bool
    """bool: Defines whether the system selects all the memo's text when the control receives focus.
        AutoSelect defines whether the system selects all the Text included in the TCustomMemo memo when the control receives focus. If AutoSelect is True, then all text is selected when the memo receives focus. 
        In TMemo, AutoSelect is set to False."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Caret: Caret
    """Caret: Provides access to the TCaret attached to the memo control."""
    CaretPosition: CaretPosition
    """CaretPosition: Provides access to the current cursor position in the memo's text.
        Use CaretPosition to determine the coordinates of the cursor (insertion point) in the memo control. The TCaretPosition type has Line and Pos integer fields:
        
        Line represents the number of the line containing the cursor, indexed from zero.
        Pos represents the horizontal character coordinate of the cursor, indexed from zero.
        Modify the value of the CaretPosition property in order to change the position of the cursor within the memo control. In order for the cursor to be visible, the memo control must have focus.
        Thus, if Line = 3 and Pos = 5, then the cursor is at the fourth line and at the sixth character from the start of the line."""
    CharCase: EditCharCase
    """EditCharCase: Defines the character case for the text within the memo control.
        Modify the CharCase|CharCase property's value in order to change the case of the text in the memo control. 
        Options are: ecNormal, ecUpperCase and ecLowerCase."""
    CheckSpelling: bool
    """bool: Defines whether the spell-checking feature of the memo control is on or off.
        This property enables spell checking on the TMemo component. When set to True a red squiggly line appears underlining the words misspelled.  
        The spell checking is performed by an operating system service. It is only supported on iOS and OS X."""
    DataDetectorTypes: DataDetectorTypes
    """DataDetectorTypes: The types of information that can be detected in the memo text.
        DataDetectorTypes is used on native presentation for iOS only."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Font: Font
    """Font: Specifies the family, size, and style properties of the text font in the memo control."""
    FontColor: int
    """int: Specifies the font color of the text in this memo.
        Use the FontColor property to read or change the font color of the text in this memo component. The default value of the FontColor property is TAlphaColorRec.Black."""
    HideSelectionOnExit: bool
    """bool: Determines whether to cancel the visual indication of the selected text region when the memo control does not have the focus.
        If HideSelectionOnExit is False, then the memo keeps highlighting the selected text using the SelectionFill brush, even when the focus moves from the memo to another control."""
    ImeMode: ImeMode
    """ImeMode: For internal use only.
        Do not use this member. It is for internal use only.
        Specifies the TImeMode input mode for the memo control."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Specifies the type of on-screen keyboard to be displayed for the memo control.
        Use KeyboardType to specify the type of on-screen keyboard that appears for the memo when ShowVirtualKeyboard is called."""
    Lines: Strings
    """Strings: Provides access to the individual lines in the memo text.
        The memo text can contain several line break symbols that separate the whole memo text into several lines. Depending on the current platform, a line break symbol can be a LF 'line feed' character (MacOS) or a CRLF 'carriage return' plus 'line feed' pair (Windows). Lines holds the memo text separated line by line. 
        When WordWrap is True then each line (specified in the Lines property) can be wrapped into several 'visual lines' to fit to the memo width. However these several 'visual lines' are still represented by a single string element in the Lines property. 
        
        Notice that GoToLineBegin and GoToLineEnd move the cursor to the beginning or the end of the current (pointed by the cursor) visual line.
        Lines is a TStrings object, so you can use TStrings methods to work with the Lines property. 
        For example, you can count the number of lines: 
        
        ShowMessage('The number of lines:' + IntToStr(Memo1.Lines.Count));
        
        You can add new lines: 
        
        Memo1.Lines.Append('New text to append at the end of memo');
        
        You can delete lines:  
        
        Memo1.Lines.Delete(0); // Deletes the fist line from memo
        
        You can replace a line with a new string:
        
        Memo1.Lines[8] := 'Replace 9th  line with this string';
        
        To work with all the memo's text at once, one can use the Text property."""
    MaxLength: int
    """int: Specifies the maximum number of characters that can be kept in the memo control.
        If the text in the memo control contains more characters than the MaxLength, then the text is truncated to the MaxLength characters. 
        If the memo control already contains a number of characters equal to MaxLength, then the user cannot enter any more characters. 
        MaxLength counts end-of-line characters. 
        If MaxLength is 0, then no explicit length limitation is set.
        
        Note: Even when MaxLength is 0, there may be limitations imposed by a platform on the number of characters that may be entered into a memo control."""
    Model: CustomMemoModel
    """CustomMemoModel: Holds the data model of the memo control."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnValidate: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnValidating: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    ReadOnly: bool
    """bool: Specifies whether the memo's text can be changed.
        ReadOnly equals to True forbids any modification of the text in the memo control."""
    SelLength: int
    """int: Specifies the number of characters that are selected in the memo control.
        Read SelLength to determine the length, in characters, of the selected text.
        Set the value of the SelLength property in order to specify the length of the selected text, starting at SelStart. Keep in mind that the character count from SelLength will include end-of-line characters at the end of each line.
        To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection. The memo component must have focus (call SetFocus) before you attempt to use SelStart; otherwise the selection is invisible.
        
        Note: Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set."""
    SelStart: int
    """int: Specifies the zero-based number of the first character selected in the memo's text.
        Read SelStart to determine the number of the first selected character, where 0 indicates the first character. If there is no selected text, then SelStart returns the cursor position. Keep in mind that the SelStart character count includes end-of-line characters at the end of each line.
        To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection. The memo component must have focus (call SetFocus) before you attempt to use SelStart; otherwise the selection is invisible."""
    SelText: str
    """str: Represents the currently selected fragment of the memo's text.
        Use SelText in order to retrieve the text that is selected, from the TCustomMemo control. If there is no selection,  SelText is an empty string. If the memo control does not have the focus, SelText represents the previous selected portion of the text."""
    SelectionFill: Brush
    """Brush: Represents the brush to draw the selected text region in the memo control.
        Use SelectionFill to change the brush characteristics for the selected text region in the memo control. For example, to change the background color of the selected text region, use:
        
         Memo1.SelectionFill.Color := System.UIConsts.claCoral;"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    """str: Represents the entire text displayed in the memo control.
        
        Note: The visibility for Text is Public. Thus, Text is not available in the Object Inspector at design time.
        For manipulating the text in a TMemo, you should use FMX.Memo.TMemo.Lines, which is available at design time in the Object Inspector."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in the memo control.
        Use the TextAlign property to change the horizontal alignment of the text in the memo control. TextAlign can be one of the Center, Leading, or Trailing values defined in TTextAlign.
        When you use text representation properties stored in the 
        TextSettings property, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text in the memo when its length is greater than the memo width.
        Set WordWrap to True to wrap the text in the memo control. Wrapping implies the division of the text string that is wider than the memo control onto several lines that fit to the memo control's width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def ClearSelection(self, *args, **kwargs) -> Any:
        """Delete selected text"""
    def CopyToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text from the memo control to the system Clipboard.
        Use CopyToClipboard to replace the contents of the system Clipboard with the selected text. If no text is selected, CopyToClipboard does nothing."""
    def Create(self, AOwner: Component) -> None:
        """TCustomMemo.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.Memo.TCustomMemo.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def CutToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text to the system Clipboard and then deletes the selected text.
        Use CutToClipboard to replace the contents of the system Clipboard with the selected text and then to delete the selected text from the memo control. If no text is selected, CutToClipboard does nothing."""
    def DeleteFrom(self, APosition: CaretPosition, ALength: int, Options: DeleteOptions) -> None:
        """TCustomMemo.DeleteFrom(APosition: CaretPosition, ALength: int, Options: DeleteOptions) -> None
        From the memo's text, deletes the fragment of text that has the ALength number of characters and begins at APosition.
        Options specifies the delete options.
        
        Note: If in a call of  DeleteFrom, one removes TDeleteOptions.CanUndo from Options, then the implemented changes cannot be backed out.
        DeleteFrom internally calls Model.DeleteFrom."""
    def DeleteSelection(self, *args, **kwargs) -> Any:
        """Removes the selected text from the memo control.
        Use DeleteSelection to delete the selected text from the memo control. If the ReadOnly property is True or if no text is selected, DeleteSelection does nothing."""
    def GoToLineBegin(self, *args, **kwargs) -> Any:
        """Moves the cursor to the beginning of the current visual line.
        When WordWrap is True, then each line (in the memo text) can be separated into several 'visual lines'.    
        GoToLineBegin moves the cursor to the beginning of the current (pointed by the cursor) visual line."""
    def GoToLineEnd(self, *args, **kwargs) -> Any:
        """Moves the cursor to the end of the current visual line.
        When WordWrap is True, then each line (in the memo text) can be separated into several 'visual lines'.  
        GoToLineEnd moves the cursor to the end of the current (pointed by the cursor) visual line."""
    def GoToTextBegin(self, *args, **kwargs) -> Any:
        """Moves the cursor to the beginning of the text in the memo control."""
    def GoToTextEnd(self, *args, **kwargs) -> Any:
        """Moves the cursor to the end of the text in the memo control."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def InsertAfter(self, APosition: CaretPosition, AFragment: str, Options: InsertOptions) -> None:
        """TCustomMemo.InsertAfter(APosition: CaretPosition, AFragment: str, Options: InsertOptions) -> None
        Inserts the AFragment string into the memo's text, at APosition.
        InsertAfter inserts in the memo's text the string specified by AFragment at the position specified by APosition. Options represent a set of insert options. 
        
        Note: InsertAfter does not insert a newline character. If the Pos field of the APosition parameter is greater than the width of the specified line, then AFragment is inserted on the next line.
        Note: If in a call of  InsertAfter one removes TInsertOptions.CanUndo from Options, then the implemented changes cannot be backed out.
        InsertAfter internally calls Model.InsertAfter."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def PasteFromClipboard(self, *args, **kwargs) -> Any:
        """Copies the contents of the system Clipboard to the memo control.
        PasteFromClipboard copies the contents of the system Clipboard, if possible, to the memo control, at the position of the cursor. If there is text selected in the memo control, the selected text will be removed. If the content of the system Clipboard is not a string, PasteFromClipboard does nothing."""
    @overload
    def PosToTextPos(self, APostion: CaretPosition) -> int:
        """TCustomMemo.PosToTextPos(APostion: CaretPosition) -> int
        Converts a Line/Pos coordinate of a character into a number of this character in the text of the memo.
        PosToTextPos returns an integer an integer representing a position of the character specified by APosition in the memo control. The APosition position is specified in the TCaretPosition format which uses the Line number and Pos horizontal shifting of the character in the memo control. Keep in mind that PosToTextPos calculates the character number counting end-of-line characters. 
        For example, if the first line of a memo's text contains 'Hello' and the second line contains 'Goodbye', then the following code:
        
          MyPosition.Line := 1;           //Zero-based
          MyPosition.Pos := 1;            //Zero-based
          MyString := Copy(Text, PosToTextPos(MyPosition) + 1, 3);
        
        sets MyString to 'odb', which are the three characters starting from the third character of the second line.
        PosToTextPos internally calls Model.PosToTextPos."""
    @overload
    def PosToTextPos(self, MyPosition) -> Any:
        """TCustomMemo.PosToTextPos(APostion: CaretPosition) -> int
        Converts a Line/Pos coordinate of a character into a number of this character in the text of the memo.
        PosToTextPos returns an integer an integer representing a position of the character specified by APosition in the memo control. The APosition position is specified in the TCaretPosition format which uses the Line number and Pos horizontal shifting of the character in the memo control. Keep in mind that PosToTextPos calculates the character number counting end-of-line characters. 
        For example, if the first line of a memo's text contains 'Hello' and the second line contains 'Goodbye', then the following code:
        
          MyPosition.Line := 1;           //Zero-based
          MyPosition.Pos := 1;            //Zero-based
          MyString := Copy(Text, PosToTextPos(MyPosition) + 1, 3);
        
        sets MyString to 'odb', which are the three characters starting from the third character of the second line.
        PosToTextPos internally calls Model.PosToTextPos."""
    def Replace(self, AStartPos: int, ALength: int, AStr: str) -> None:
        """TCustomMemo.Replace(AStartPos: int, ALength: int, AStr: str) -> None
        Replaces the ALength number of characters, beginning from the AStartPos position, with the AStr string.
        The caret is moved to the position of the last inserted character."""
    def ResetSelection(self, *args, **kwargs) -> Any:
        """Cancel the text selection if it exists.
        The ResetSelection method internally sets the SelLength property to 0."""
    def SelectAll(self, *args, **kwargs) -> Any:
        """Selects all the text in the memo control.
        Use SelectAll to select all the text in the memo control. If there is no text in the memo control, SelectAll does nothing."""
    def SelectWord(self, *args, **kwargs) -> Any:
        """Selects the word that contains the cursor.
        In the memo's text, SelectWord selects a delimited by word dividing characters (space characters, punctuation marks, and others) substring (word) that contains the cursor. Here word dividing characters are space characters, line feeds, and punctuation marks."""
    def TextPosToPos(self, APos: int) -> CaretPosition:
        """TCustomMemo.TextPosToPos(APos: int) -> CaretPosition
        Converts APos into a Line/Pos coordinate in the memo control.
        TextPosToPos returns the TCaretPosition format position of a character indicated by APos. TextPosToPos calculates the TCaretPosition.Line line number and TCaretPosition.Pos horizontal shifting, corresponding to the APos character count coordinate of a character in the text of the memo control. 
        Keep in mind that APos counts end-of-line characters. 
        For example, if the first line of a memo's text contains 'Hello' and the second line contains 'Goodbye', then the following code:
        
          OldPosition.Line := 1;           //Zero-based
          OldPosition.Pos := 2;            //Zero-based
          NewPosition := TextPosToPos(PosToTextPos(OldPosition) + 2);
        
        sets the NewPosition.Line to 1 and NewPosition.Pos to 4.
        TextPosToPos internally calls Model.TextPosToPos."""
    def UnDo(self, *args, **kwargs) -> Any:
        """Undoing the latest text change made in the memo control.
        UnDo backs out, if possible, the latest change made to the text in the memo control. If no change has been made, UnDo does nothing.
        
        Note: Remove TDeleteOptions.CanUndo from Options calling DeleteFrom or TInsertOptions.CanUndo from Options calling InsertAfter when modifying the text in the memo control, so that the changes cannot be backed out."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMemoryStream(Stream):
    """Wrapper for Delphi TCustomMemoryStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Memory: Pointer
    """Pointer:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TCustomMemoryStream.Read(Buffer, Count: int) -> int"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SaveToFile(self, FileName: str) -> None:
        """TCustomMemoryStream.SaveToFile(FileName: str) -> None"""
    def SaveToStream(self, Stream: Stream) -> None:
        """TCustomMemoryStream.SaveToStream(Stream: Stream) -> None"""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """TCustomMemoryStream.Seek(Offset: int, Origin: SeekOrigin) -> int"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMultiView(StyledControl):
    """The base class for MultiView components.
    If you need to create a custom MultiView component, derive it from TCustomMultiView."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    BorderOptions: MultiViewBorderOptions
    """MultiViewBorderOptions: Handles appearance options of borders for MultiView components.
        TMultiViewBorderOptions defines the  Color and Visible properties."""
    CustomPresentationClass: MultiViewPresentationClass
    """MultiViewPresentationClass: Refers the custom class for presentations of master panes in  MultiView controls.
        The user can customize the master pane presentation. You need to set the MultiView control to Custom and declare your own class that descends from TMultiViewPresentation or from other classes declared in the FMX.MultiView.Presentations.pas unit (such as MyPresentationClass).
        The custom presentation class should be set in the CustomPresentationClass property. See the Custom Mode subsection in Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DrawerOptions: DrawerAppearance
    """DrawerAppearance: Handles appearance options of the master pane in the Drawer presentation mode.
        The DrawerOptions property handles the following options:
        
        DurationSliding: specifies the duration of the master pane sliding (in seconds).
        Mode: specifies the master pane sliding mode.
        Placement: specifies the master pane location (left or right).
        TouchAreaSize: specifies the touch area size (in pixels)."""
    MasterButton: Control
    '''Control: Allows you to hide or show the master pane.
        If your application has no master button, leave the MasterButton property empty.
        
        Limitations
        The master button cannot be used when:
        
        The button is invisible and if the Mode property is set to Panel presentation mode. That is, the master pane is a "docked panel".
        The onClick event handler is not supported.'''
    MasterContent: Content
    """Content: Holds the content (child controls) of the MultiView.
        MasterContent lists child controls in the master pane and does not list the detail pane. 
        
        Note: The detail pane is referenced by the TargetControl property."""
    Mode: MultiViewMode
    """MultiViewMode: Specifies the presentation mode of the master pane.
        The TMultiViewMode type provides the following presentation modes:
        
        
        
        Mode
        
        Master Pane Presentation
        
        
        Drawer
        
        In the Drawer mode, the master pane can be whether hidden or can slide to overlap the detail pane.
        
        
        Panel
        
        Master and detail panels are always displayed, independently of a device type and orientation. The master panel is docked to the left or right of the MultiView component.
        
        
        PlatformBehaviour
        
        An application automatically selects the master pane presentation mode depending on the device type and orientation, as described in the tables in the Platform Dependent Behavior Mode subsection below.
        
        
        Popover
        
        Pop-up menu.
        
        
        NavigationPane
        
        Navigation pane.
        
        
        Custom
        
        The user can customize the master pane presentation. The custom presentation class should be set in the CustomPresentationClass property. For details, see Custom Mode description.
        
        For detailed information about the presentation modes, see Master Pane Presentation Modes.
        
        Platform Dependent Behavior Mode
        In the PlatformBehaviour mode, you let the application automatically select the master pane presentation mode. In this scenario,  the application behavior depends on the device type, orientation, and the operation system version (only for desktop applications) as described in the following tables:
        Mobile Applications
        
        
        
        Device Type
        
        Device Orientation  
        
        Master Pane Presentation
        
        
        Phone
        
        Landscape, Portrait
        
        Drawer (push/overlap)
        
        
        Tablet
        
        Landscape
        
        Docked panel
        
        
        Tablet
        
        Portrait
        
        Drawer (push/overlap)
        
        Desktop Applications
        
        
        
        OS Version
        
        Master Pane Presentation
        
        
        Windows 10
        
        Navigation pane
        
        
        Windows 8 or earlier
        
        Docked panel
        
        
        OS X
        
        Docked panel"""
    NavigationPaneOptions: NavigationPaneAppearance
    """NavigationPaneAppearance: Handles the appearance options of the master pane in the NavigationPane presentation mode.
        With NavigationPaneOptions, you can manage the CollapsedWidth property of the master pane appearance of the current MultiView component. CollapsedWidth specifies the width (in pixels) of the master pane in the NavigationPane presentation mode when it is collapsed."""
    OnHidden: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPresenterChanging: Callable[[Object,MultiViewPresentationClass],None]
    """Callable[[Object, MultiViewPresentationClass], None]:"""
    OnShown: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartHiding: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartShowing: Callable[[Object],None]
    """Callable[[Object], None]:"""
    PopoverOptions: PopoverAppearance
    """PopoverAppearance: Handles appearance options of the master pane in the Popover presentation mode.
        In the Popover presentation mode, the master pane is a pop-up menu, which can be displayed or hidden using the master button.
        The PopoverOptions property allows you to handle the following options:
        
        AppearanceDuration: specifies the duration of the pop-up window appearance (in seconds). By default, this property is set to 0.25 s.
        PopupHeight: specifies the height of the pop-up window (in pixels). By default, this property is set to 400px.
        StyleLookup: specifies the name of the resource object (style) to which this pop-up window is linked.
        TintColor: specifies the tint applied to this pop-up window."""
    Presenter: MultiViewPresentation
    """MultiViewPresentation: Keeps the object providing the presentation of the master pane of the current MultiView component."""
    ShadowOptions: ShadowAppearance
    """ShadowAppearance: Handles appearance options of a shadow that the master pane casts on the detail pane.
        With ShadowOptions property, you can handle the following appearance options of the shadow:
        
        Color: specifies the shadow color.
        Enabled: enables or disables the shadow.
        Opacity: specifies the opacity level of the shadow."""
    SplitViewOptions: SplitViewAppearance
    """SplitViewAppearance: Handles appearance options of the master pane in the Panel presentation mode.
        With SplitViewOptions property, you can handle the Placement option. Placement specifies the docked master pane location (left, right, top, or bottom)."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TargetControl: Control
    """Control: Specifies a datail pane container (such as TPanel) showing elements described in the master pane.
        For more information about the master-detail interface, see Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android).
        
        Limitations
        See FireMonkey Native iOS Controls: Combining Native iOS Controls With Non-native Controls for more information about the limitations when using native controls.
        
        Exceptions
        Setting TargetControl may raise the following exception:
        
        
        
        Exception
        
        Exception.Message
        
        Scenarios
        
        
        
        EComponentError
        
        
        
        TargetControl cannot be a child of TMultiView.
        
        
        
        You set a child control of a TMultiView as the TargetControl of that TMultiView.
        You set a TMultiView as the TargetControl of itself."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def ClearContent(self, *args, **kwargs) -> Any:
        """Removes all controls from the content."""
    def Create(self, AOwner: Component) -> None:
        """TCustomMultiView.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.MultiView.TCustomMultiView.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.MultiView.TCustomMultiView.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def HasMasterButton(self, *args, **kwargs) -> Any:
        """Verifies whether the component has a master button.
        A master button is a UI element that allows you to view or hide the master pane."""
    def HasPresenter(self, *args, **kwargs) -> Any:
        """Retrieves whether the master pane of the current MultiView component has the Presenter."""
    def HasTargetControl(self, *args, **kwargs) -> Any:
        """Verifies whether the component has the detail pane."""
    def HideMaster(self, *args, **kwargs) -> Any:
        """Hides the master pane.
        Use this method to hide the master pane."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def IsShowed(self, *args, **kwargs) -> Any:
        """Verifies whether the master pane is displayed. 
        Use this method to verify whether the master pane is displayed. The IsShowed method returns the following values:
        
        true: the master pane is displayed.
        false: the master pane is hidden."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ShowMaster(self, *args, **kwargs) -> Any:
        """Displays the master pane.
        Use this method to display the master pane."""
    def UpdateAlignment(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomNumberColumn(Column):
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    DecimalDigits: int
    """int: The number of decimal places when displaying float numbers."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShowThousandSeparator: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ValueType: NumValueType
    """NumValueType: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomNumberColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TCustomNumberColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    @classmethod
    def TryValueToString(cls, Value: Value, ValueType: NumValueType, Text: str, DecimalDigits: int, ShowThousandSeparator: bool) -> bool:
        """TCustomNumberColumn.TryValueToString(Value: Value, ValueType: NumValueType, Text: str, DecimalDigits: int, ShowThousandSeparator: bool) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def ValidChar(self, KeyChar) -> bool:
        """TCustomNumberColumn.ValidChar(KeyChar: unicodechr(str)) -> bool
        Returns True if the specified character is a valid character for a cell of this column or False otherwise.
        FMX.Grid.TCustomNumberColumn.ValidChar inherits from FMX.Grid.TColumn.ValidChar. All content below this line refers to FMX.Grid.TColumn.ValidChar.
        Returns True if the specified character is a valid character for a cell of this column or False otherwise.
        For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid."""
    def ValueToString(self, Value: Value) -> str:
        """TCustomNumberColumn.ValueToString(Value: Value) -> str
        Draws the value of the column cell.
        FMX.Grid.TCustomNumberColumn.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
        Draws the value of the column cell.
        Each column type defines its own implementation of this method to convert TValue into string value."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPath(Shape):
    """TCustomPath is the base class for all 2D path-type shapes representing groups of connected curves and lines.
    TCustomPath renders the path Data graphics with the Paint method. Paint scales and positions the path graphics according to the WrapMode parameter. Paint draws the path contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TCustomPath object."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Data: PathData
    '''PathData: Specifies the SVG data used to build graphic shapes.
        The Data property supports only a comma-separated list of instructions defined for the d attribute of the path element in SVG 1.0. 
        In SVG 1.0, the d attribute contains the moveto, line, curve, arc, and closepath instructions. All instructions are expressed as one character (for example, a moveto is expressed as an M).
        For more information, see Scalable Vector Graphics (SVG) 1.0 Specification.
        
        Example
        To clarify, consider the following code snippets that specify the SVG instructions at run time:
        
        
        Delphi:
        
        Path1.Data.Data := \'M 1,0, L 2,1, L 1,2, L 0,1, L 1,0\';
        
        
        C++Builder:
        
        
        Path1->Data->Data = "M 1,0, L 2,1, L 1,2, L 0,1, L 1,0";
        
        
        An application that uses the above mentioned SVG instructions displays a rhomb:'''
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    WrapMode: PathWrapMode
    """PathWrapMode: Specifies whether and how to resize, replicate, and position the graphical path representation for painting the area.
        The WrapMode property should be one of the constants defined in the TPathWrapMode type: 
        
        Stretch--stretches the path representation to fill the entire area. Default.
        Original--keeps the original path size.
        Fit--resizes the path representation (keeping proportions) to best fit the area.
        Tile--renders the path representation repeatedly to tile the area."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomPath.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TCustomPath.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the object instance and frees its memory.
        FMX.Objects.TCustomPath.Destroy inherits from FMX.Objects.TShape.Destroy. All content below this line refers to FMX.Objects.TShape.Destroy.
        Destroys the object instance and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PointInObject(self, X: float, Y: float) -> bool:
        """TCustomPath.PointInObject(X: float, Y: float) -> bool
        Checks whether the specified point belongs to the path Data of the TCustomPath object.
        PointInObject calls the FMX.Graphics.TCanvas.PtInPath method of the TCanvas object to check whether the specified point belongs to the path Data of the TCustomPath object.
        X and Y are absolute pixel coordinates of the point to be checked:
        
        X is the x-coordinate.
        Y is the y-coordinate."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPopupForm(CustomForm):
    """TCustomPopupForm represents the base class for FMX pop-up forms.
    Create a subclass derived from TCustomPopupForm if you want to create new pop-up forms. A derived pop-up form can contain one or more FireMonkey objects, such as TLabel, TComboBox, and so on.
    Note that every descendant of TCustomPopupForm is a 2D FireMonkey pop-up form."""
    __hash__: ClassVar[None] = ...
    AniDuration: float
    """float: Sets the animation duration for the pop-up form to close or to show.
        AniDuration is measured in seconds.
        AniDuration defines a duration time for execution of the custom event handler assigned to the OnAniTimer event of the current TCustomPopupForm pop-up form. 
        
        Note: AniDuration does not influence onto an animation duration of an external animation (for example TFloatAnimation animation) if such is assigned to the TCustomPopupForm pop-up form. AniDuration is used for the custom event handler assigned to the OnAniTimer event."""
    AniPosition: float
    """float: Read-only property returning values between 0 and 1. You can use AniPosition in an OnAniTimer event handler.
        The AniPosition value changes during AniDuration time of a custom animation execution from 0 to 1 (during opening of the current pop-up form) and from 1 to 0 (during closing) respectively.
        AniPosition might be used as a parameter in intermediate values of animated properties in an OnAniTimer event handler. For example, you can use AniPosition to calculate an intermediate position or intermediate opacity during custom animation. Where AniPosition = 0 corresponds to a starting moment and AniPosition = 1 to a termination of opening animation.
        For example, in the sample below the form Width (as a component of the form Size) changes from 0 (when AniPosition = 0) to 200 (when AniPosition = 1) during appearing of the pop-up form and vice versa on the form closing:
        
        ...
        procedure TForm1.AniTimerProc(Sender: TObject);
        begin
          if Sender is TCustomPopupForm then
          begin
        //    You can use AniPosition whether to define Opacity or Size
        //    TCustomPopupForm(Sender).ContentControl.Opacity := TCustomPopupForm(Sender).AniPosition;
            TCustomPopupForm(Sender).Size := TSize.Create(Round(200 * TCustomPopupForm(Sender).AniPosition), 100);
          end;
        end;
        
        procedure TForm1.Button1Click(Sender: TObject);
        var
          R: TRectangle;
        begin
          R := TRectangle.Create(Self);
          F := TCustomPopupForm.Create(Self);
          F.AniDuration := 0.5;
          F.ContentControl := R;
          F.OnAniTimer := AniTimerProc;
          F.PlacementTarget := Button1;
          F.Show;
        end;
        ...
        
        Commented line shows how to use AniPosition to animate a form transparency. 
        See also discussion in TPopup.OnAniTimer."""
    AutoFree: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    BeforeClose: Callable[[Object],None]
    """Callable[[Object], None]:"""
    BeforeShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    ContentControl: Control
    """Control: Specifies the control that is shown on the pop-up form.
        If a pop-up form does not contain any visible control, then the pop-up form is totally transparent. Therefore, some visible control should be placed onto the pop-up form. This control is specified by the ContentControl property. 
        
        Note: A ContentCtrl control can be associated to a PopupForm pop-up form using the Parent property of the control, like in the following example: ContentCtrl.Parent := ParentForm. However, we recommend using the ContentControl property like ParentForm.ContentControl := ContentCtrl, because  TCustomPopupForm handling ContentControl takes into account the current scale and rotation of the ContentCtrl control."""
    ContentPadding: Bounds
    """Bounds: Specifies the padding of the pop-up form. 
        The ContentPadding of a pop-up form specifies how close, in pixels, the children of the form can come to each of the form edges (top, left, bottom, right). See also Padding.
        The adhering of the pop-up form is executed to the boundaries of this indented 'padding rectangle'."""
    DragWithParent: bool
    """bool: Specifies whether the current TCustomPopupForm can be dragged after it is shown.
        For example, if DragWithParent is True, TCustomPopupForm is dragged together with its parent form when the parent form is the target of a drag-and-drop operation. When Placement is Mouse or MouseCenter, then the pop-up form moves following the mouse cursor. On mobile devices, after changing the orientation (portrait/landscape) the pop-up form can change its position in order not to be partially positioned outside of the screen boundaries. 
        The default is True."""
    HideWhenPlacementTargetInvisible: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Offset: PointF
    """PointF: The offset of the padding rectangle  relative to the rectangle of the pop-up form.
        Defines the number of pixels, by which the pop-up form is displaced  relatively to the main form position; this number is obtained taking into account all positioning properties used in the TCustomPopupForm class. The Offset direction depends on a Placement value. The Offset property is used, for example, in multi-level menus, when pop-up forms of submenus are placed overlapping a form of a previous level."""
    OnAniTimer: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnRealPlacementChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    Placement: Placement
    """Placement: Gets or sets how the TCustomPopupForm is positioned relative to rectangles specified by the PlacementRectangle or PlacementTarget properties, relative to the screen, or relative to the mouse (pointing device) position.
        TPlacement defines possible values of Placement.
        TPlacement also specifies the behavior of the TCustomPopupForm, when it overlaps screen boundaries. The default value is Bottom.
        This figure demonstrates the TopCenter value.
        
        In the figure, ScreenPlacementRect is the colored Fuchsia rectangle of the Show popup button. 
        Use Placement, PlacementTarget, and PlacementRectangle to set the positioning of TCustomPopupForm."""
    PlacementRectangle: Bounds
    """Bounds: Gets or sets a rectangle, relative to which the TCustomPopupForm is positioned. 
        Screen coordinates of PlacementRectangle are calculated relative to PlacementTarget (if specified). Otherwise, relative to the top left corner of the screen. The following rules are used:
        
        If PlacementRectangle is not specified (width or height equals to zero 0), but PlacementTarget is specified, then the coordinates and size of PlacementTarget are used.
        If neither PlacementRectangle nor PlacementTarget are specified, then adhering of the top left corner of the form is implemented to the mouse cursor.
        Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of the TCustomPopupForm."""
    PlacementTarget: Control
    """Control: The target control, relative to which the TCustomPopupForm is positioned. 
        If PlacementTarget is not set, and the TCustomPopupForm has a ParentForm, then the TCustomPopupForm is positioned relative to its parent. If PlacementTarget and ParentForm are not set, TCustomPopupForm is positioned relative to the main window. 
        Use Placement, 
        RealPlacement, and PlacementRectangle to set the target origin and the alignment point of TCustomPopupForm."""
    PreferedDisplayIndex: int
    """int: Specifies the index of the display that shows the pop-up form.
        Specifies the index of the display in the Displays array that shows the current pop-up form.
        PreferedDisplayIndex is used for context menus. When an application opens several submenus of context menus, all these submenus should be shown on the same display, even if a new pop-up submenu can be shown on a neighbor display.
        If a specified PreferedDisplayIndex does not exist, then a pop-up form is shown on a display that is the closest to the place where the form should appear according to all specified positioning parameters Placement, PlacementTarget, and PlacementRectangle."""
    RealPlacement: Placement
    """Placement: Used internally.
        The CreateNew constructor initializes RealPlacement equal to Placement. At run time RealPlacement can be changed according to the real environment properties. For example, if a run-time environment supports the mouse, then RealPlacement can be set to  
        TPlacement.Mouse, otherwise to
        TPlacement.Absolute."""
    ScreenContentRect: RectF
    """RectF: Screen coordinates of the rectangle relative to which controls in the pop-up form are positioned.
        ScreenContentRect is the rectangle inside which all controls of the pop-up form are positioned. 
        Notice that some 'decorative elements', like 'triangular peaks' on  TCalloutPanel rectangles, can be positioned outside the ScreenContentRect."""
    ScreenPlacementRect: RectF
    """RectF: Screen coordinates of the rectangle relative to which the pop-up form is positioned.
        ScreenPlacementRect is defined taking into account PlacementRectangle and PlacementTarget.
        
        In the figure, ScreenPlacementRect is the colored Fuchsia rectangle of the Show popup button."""
    Size: SizeF
    """SizeF: The working area size of the current pop-up form.
        Size defines the width and height of the working area of the current TCustomPopupForm pop-up form. Size defines the rectangle to which all controls of the form are aligned. 
        In the following picture the Size rectangular of the pop-up form is specified with the green dashes. The physical rectangle of the pop-up form window (defined by Width and Height) is  marked with red dashes. 
        
        As you see from the picture, the physical rectangle is not used for positioning. 
        ClientWidth and ClientHeight of the working area  of the form are defined automatically according to the specified Size and Padding. If PlacementRectangle is defined and Placement is Absolute, then Size is ignored. 
        Use a TSizeF object to set the Size of a pop-up form.  
        For example, the following code will set up the working area width to 200 and height to 250: 
        
          Form1.Size := TSizeF.Create(200, 250);"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyPlacement(self, *args, **kwargs) -> Any:
        """Positions the current pop-up form.
        ApplyPlacement positions the TCustomPopupForm pop-up form using the current Size and Placement properties."""
    def CanShow(self, *args, **kwargs) -> Any:
        """Retrieves whether the form is not visible.
        First CanShow calls the inherited 
        TCommonCustomForm.CanShow. If TCommonCustomForm.CanShow returns False, CanShow exits returning False. If TCommonCustomForm.CanShow returns True, CanShow initiates animation 
        (AniDuration, AniPosition, DoAniTimer) and
        exits returning True."""
    def CloseQuery(self, *args, **kwargs) -> Any:
        """Close-attempt event dispatcher.
        FMX.Forms.TCustomPopupForm.CloseQuery inherits from FMX.Forms.TCommonCustomForm.CloseQuery. All content below this line refers to FMX.Forms.TCommonCustomForm.CloseQuery.
        Close-attempt event dispatcher.
        CloseQuery is called automatically when an attempt is made to close the form. CloseQuery can allow the form to close by returning True, or prevent the form from closing by returning False.
        As implemented in TCommonCustomForm, CloseQuery calls the OnCloseQuery event handler, if it exists. If no such event handler exists, CloseQuery returns True."""
    def Create(self, AOwner: Component, AStyleBook: StyleBook, APlacementTarget: Control, AutoFree: bool) -> None:
        """TCustomPopupForm.Create(AOwner: Component, AStyleBook: StyleBook, APlacementTarget: Control, AutoFree: bool) -> None
        Creates and initializes this pop-up form.
        Create calls CreateNew, which creates this pop-up form and sets initial values to several properties of the created pop-up form. Then Create initializes the PlacementTarget, 
        Parent, and StyleBook properties for the created pop-up form.  
        AOwner specifies the owner of this pop-up form. The AOwner is responsible for freeing the created pop-up form.
        AStyleBook specifies the style book to set for the StyleBook property of this pop-up form.  
        APlacementTarget specifies the PlacementTarget property for this pop-up form."""
    def CreateNew(self, AOwner: Component, Dummy: int) -> None:
        """TCustomPopupForm.CreateNew(AOwner: Component, Dummy: int) -> None"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Forms.TCustomPopupForm.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LoadProps(self) -> Any:
        """TCommonCustomForm.LoadProps()
        Load properties from a .pydfm file"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPopupMenu(FmxObject):
    """Represents a pop-up menu attachable to graphical controls that support pop-up menus.
    The TTextService virtual abstract class represents a pop-up context menu that can be attached to any FireMonkey graphical control that support pop-up menus, such as TImageControl, TPanel, and so on."""
    __hash__: ClassVar[None] = ...
    Parent: Any
    """Returns/Sets the Control Visibility"""
    PopupComponent: Component
    """Component: Specifies the control for which the current object is a context menu.
        Set the PopupComponent value to a control so that the current object will be a context menu for that control. The context menu for a control will appear when you right-click that control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Popup(self, X: float, Y: float) -> None:
        """TCustomPopupMenu.Popup(X: float, Y: float) -> None
        Displays the pop-up menu onscreen.
        TCustomPopupMenu descendants implement Popup so that it brings up the pop-up menu onscreen. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPresentedFramedScrollBox(CustomPresentedScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPresentedFramedVertScrollBox(CustomPresentedVertScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPresentedHorzScrollBox(CustomPresentedScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomPresentedHorzScrollBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.ScrollBox.TCustomPresentedHorzScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPresentedScrollBox(StyledControl):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    Content: ScrollContent
    """ScrollContent: Container that can hold scrollable content of the scroll box.
        Contains controls placed into the scroll box. Content does not contain a style object, any kind of Animation or effect objects."""
    ContentBounds: RectF
    """RectF: The content bounds.
        This property is read-only if AutoCalculateContentSize is True. To update the content bounds when AutoCalculateContentSize is True, call UpdateContentSize."""
    ContentLayout: Control
    """Control: Returns the control from style that will wrap its scrolling content.
        ContentLayout is used by internal methods to get the list of components in the scrollbox and represents the parent for all of them."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    HScrollBar: ScrollBar
    """ScrollBar: Returns the horizontal scrollbar component.
        HScrollBar is only available for style presentation. For native presentation, it returns null/nil."""
    Model: CustomScrollBoxModel
    """CustomScrollBoxModel: Data model that represents the data used by the presentation of the current control.
        
        The constructor of your presented control creates a data model. The class of the data model is the class that DefineModelClass returns."""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    ScrollAnimation: BehaviorBoolean
    """BehaviorBoolean: Enables or disables scrolling animation."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTracking: BehaviorBoolean
    """BehaviorBoolean: Defines if the control reacts to touch events."""
    VScrollBar: ScrollBar
    """ScrollBar: Returns the vertical scrollbar component.
        VScrollBar is only available for style presentation. For native presentation, it returns null/nil."""
    ViewportPosition: PointF
    """PointF: Position of the view port of the ScrollBox content.
        ViewportPosition is set in local coordinates of the Content."""
    ViewportSize: SizeF
    """SizeF: Size of the view port of the ScrollBox content."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def ClearContent(self, *args, **kwargs) -> Any:
        """Removes all controls from the content."""
    def Create(self, AOwner: Component) -> None:
        """TCustomPresentedScrollBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.ScrollBox.TCustomPresentedScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def InViewRect(self, ARect: RectF, AAnimated: bool) -> None:
        """TCustomPresentedScrollBox.InViewRect(ARect: RectF, AAnimated: bool) -> None
        Scrolls the content to the rectangle defined in ARect."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def RealignContent(self, *args, **kwargs) -> Any:
        """Forces the update of the content size calculation."""
    def ScrollBy(self, ADX: float, ADY: float, AAnimated: bool) -> None:
        """TCustomPresentedScrollBox.ScrollBy(ADX: float, ADY: float, AAnimated: bool) -> None
        Changes the scroll position by the offset defined in ADX and ADY."""
    def ScrollTo(self, AX: float, AY: float, AAnimated: bool) -> None:
        """TCustomPresentedScrollBox.ScrollTo(AX: float, AY: float, AAnimated: bool) -> None
        Changes the scroll position to the value defined by AX and AY.
        ScrollTo uses the value of the ViewportPosition property to calculate the offset and then calls ScrollBy."""
    def ScrollToCenter(self, AAnimated: bool) -> None:
        """TCustomPresentedScrollBox.ScrollToCenter(AAnimated: bool) -> None
        Changes the scroll position to the center of the content size."""
    def ScrollToTop(self, AAnimated: bool) -> None:
        """TCustomPresentedScrollBox.ScrollToTop(AAnimated: bool) -> None
        Changes the scroll position to the top."""
    def Sort(self, Compare: FmxObjectSortCompare) -> None:
        """TCustomPresentedScrollBox.Sort(Compare: FmxObjectSortCompare) -> None
        Sorts the children in the children list using the specified sorting procedure.
        FMX.ScrollBox.TCustomPresentedScrollBox.Sort inherits from FMX.Types.TFmxObject.Sort. All content below this line refers to FMX.Types.TFmxObject.Sort.
        Sorts the children in the children list using the specified sorting procedure."""
    def UpdateContentSize(self, *args, **kwargs) -> Any:
        """Recalculates content bounds of a scroll box.
        This method does not calculate content bounds if AutoCalculateContentSize is False or if the state of the scroll box is csLoading or csDestroying.
        See also ContentBounds."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPresentedVertScrollBox(CustomPresentedScrollBox):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomPresentedVertScrollBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.ScrollBox.TCustomPresentedVertScrollBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPrototypeBindSource(BaseObjectBindSource):
    """Is a base class that implements a bind source for creating sample data.
    If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications, TPrototypeBindSource is available from the Tool Palette."""
    __hash__: ClassVar[None] = ...
    AutoEdit: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoPost: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DataGenerator: CustomDataGeneratorAdapter
    """CustomDataGeneratorAdapter: Embarcadero Technologies does not currently have any additional information."""
    FieldDefs: GeneratorFieldDefs
    """GeneratorFieldDefs: Embarcadero Technologies does not currently have any additional information."""
    Owner: Any
    """Returns the Component Owner"""
    RecordCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TCustomPrototypeBindSource.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.ObjectScope.TCustomPrototypeBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomScrollBox(StyledControl):
    """The base class for controls representing a scrolling area (scroll box).
    One use of a scroll box is to group multiple graphical controls (such as buttons, list boxes, edit boxes, radio buttons, and so on) under the same scrollable parent (the scroll box itself). In this way, a smaller form can contain a lot of graphical objects organized in a scrollable manner in order to occupy less space on a graphical user interface (GUI).
    Another use of scroll boxes is to create multiple scrolling areas (views) in a form. Views are common in commercial word-processor, spreadsheet, and project management applications.
    
    Note: Do not anchor the children of a scroll layout (TScrollBox, TVertScrollBox, TFramedScrollBox, and so on) to the right and bottom edges. If the Anchors property of a scroll layout child is set to akBottom, akRight, or both, the child will continue to stretch to keep constant the distance to the layout edges when the layout content size is being calculated. The children of a scroll layout should be anchored only to the left and top edges.
    Note: When the size of the area occupied by the Content of a scroll box exceeds the control Size, and, therefore,  all Content cannot be shown in the control at one moment, then you can use scroll bars to scroll the Content in the control. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll the Content using the mouse wheel. To enforce the scroll bar to be shown by default, you can use the code like following:
    ScrollBox1.AniCalculations.AutoShowing := false;"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AniCalculations: ScrollCalculations
    """ScrollCalculations: Allows you to set various parameters that control the inertial scrolling effect animation.
        AniCalculations keeps a TScrollCalculations object created by CreateAniCalculations. Using properties of this object you can programmatically set values for inertial scrolling properties in order to emulate on the current platform the inertial scrolling behavior typical for other platforms. For example, you can select the emulation of the iOS scrolling behavior under Windows and vice-versa.
        TScrollCalculations is the descendant of the TAniCalculations class, which provides methods to calculate parameters of the inertial scrolling.
        By using AniCalculations you can set:
        
        Whether the scrolling is animated (via the TAniCalculations.Animation property).
        The deceleration rate of the inertial scrolling (via the TAniCalculations.DecelerationRate property).
        Whether the inertial scrolling is bound to the area (via the TAniCalculations.BoundsAnimation property).
        Whether the scrolling bars appear automatically when the scroll action is initiated (via the TAniCalculations.AutoShowing property).
        Whether the scrolling bars are hidden automatically when they are not needed (via the TAniCalculations.Shown property).
        other properties of the TScrollCalculations object."""
    AutoHide: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentBounds: RectF
    """RectF: Keeps a rectangle bounding all controls in the content of this scroll box.
        DoRealign calls DoCalcContentBounds to calculate the ContentBounds rectangle. If the OnCalcContentBounds event handler is defined, then DoRealign calls this event handler and  passes into it the calculated content bounding rectangle for additional calculations.
        The ContentBounds property is read-only. If the value returned by ContentBounds needs to be changed, you need to override DoCalcContentBounds or to assign the OnCalcContentBounds event handler."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnHScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnVScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ShowSizeGrip: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    ViewportPosition: PointF
    """PointF: Coordinates of the origin of the scrolling viewport specified as the offset from the origin of the content layout of this scroll box.
        Coordinates are specified as the TPointF point defining the origin of the scrolling viewport in relation to the origin of the content layout of this scroll box.
        A scrolling viewport (or viewport) is a rectangle bounding all controls placed on the content layout of this scroll box."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Center(self, *args, **kwargs) -> Any:
        """Scrolls to the center of the TScrollBox control.
        Center only has an effect if the scroll box actually has content beyond the display area and the scroll bars are needed to scroll to view all the content held by this scroll box."""
    def ClientHeight(self, *args, **kwargs) -> Any:
        """ClientHeight specifies the height of the components content (in dp). Use it to read or change the height of the component.
        
        Note:  ClientHeight is the components height without decoration. The components could be scrollbars and paddings."""
    def ClientWidth(self, *args, **kwargs) -> Any:
        """ClientWidth specifies the width of the components content (in dp). Use it to read or change the width of the component.
        
        Note: ClientWidth is the components width without decoration. The components could be scrollbars and paddings."""
    def Create(self, AOwner: Component) -> None:
        """TCustomScrollBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TCustomScrollBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Layouts.TCustomScrollBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def InViewRect(self, Rect: RectF) -> None:
        """TCustomScrollBox.InViewRect(Rect: RectF) -> None
        Internally used."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def InvalidateContentSize(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def RealignContent(self, *args, **kwargs) -> Any:
        """Realigns the children controls of this scroll box in the scrolling area of this scroll box. 
        RealignContent can be overridden in subclasses to allow further functionality when performing the alignment of the objects inside the ContentBounds scrolling area of this scroll box."""
    def ScrollBy(self, Dx: float, Dy: float) -> None:
        """TCustomScrollBox.ScrollBy(Dx: float, Dy: float) -> None
        Scrolls the view according to the given Dx and Dy offsets (relative to the current position) in the TScrollBox control. 
        The Dx and Dy parameters specify offsets to the values of the horizontal and  vertical scroll bars assigned to the TScrollBox control. This means that the Dx parameter is the change in pixels horizontally (along the X axis), and the Dy parameter is the change in pixels vertically (along the Y axis). 
        ScrollBy has the effect of scrolling the view, in the TScrollBox control, to the new coordinates defined by the new values of the horizontal and  vertical scroll bars. These new values are obtained from the current values of the vertical and horizontal scroll bars by decreasing them by Dx and Dy pixels, respectively. For example, if Dx is a negative value, ScrollBy scrolls the view to the left; if  Dx is a positive value, ScrollBy scrolls the view to the right.
        ScrollBy only has an effect if the scroll box actually has content beyond the display area, and the scroll bars are needed to view more of the content."""
    def ScrollTo(self, Dx: float, Dy: float) -> None:
        """TCustomScrollBox.ScrollTo(Dx: float, Dy: float) -> None"""
    def Sort(self, Compare: FmxObjectSortCompare) -> None:
        """TCustomScrollBox.Sort(Compare: FmxObjectSortCompare) -> None
        Sorts components of the layout based on the comparison function Compare. 
        TFmxObjectSortCompare is declared as:
        
        TFmxObjectSortCompare = function(item1, item2: TFmxObject): Integer;"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomSwitch(StyledControl):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    IsChecked: bool
    """bool: Indicates if the Switch is turned on or off.
        IsChecked is True if the Switch is turned on, False otherwise."""
    Model: SwitchModel
    """SwitchModel: A data model for this control."""
    OnSwitch: Callable[[Object],None]
    """Callable[[Object], None]:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomSwitch.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCustomSwitch.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomTimeEdit(CustomDateTimeEdit):
    """Wrapper for Delphi TCustomTimeEdit"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TimeFormatKind: DTFormatKind
    """DTFormatKind:"""
    UseNowTime: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CanInput(self, *args, **kwargs) -> Any: ...
    def CopyToClipboard(self, *args, **kwargs) -> Any: ...
    def Create(self, AOwner: Component) -> None:
        """TCustomTimeEdit.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TTextControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Controls.TTextControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomTrack(StyledControl):
    """Base class for all track bar components.
    TCustomTrack is the base class for all track bar components such as TTrackBar.
    If you need to create your own custom track bar, then you should derive your component from TCustomTrack, as it already implements functionality for drawing and manipulating the track bar."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Frequency: float
    """float: Specifies the number of positions the slider advances with each move.
        Use the Frequency property to specify how many steps at once the slider advances with each move. For instance, if you set Frequency to 10, Min to 0, and Max to 100, then there are only 10 steps for this slider to move within the 0 to 100 range; Value is incremented or decremented with 10 divisions.
        Frequency is a floating-point Single value; setting Frequency to 0 enables this track bar to increment or decrement by 0.01 divisions by step. Setting Frequency to any integer value (for instance 1, or 5, and so on) will enable this track bar to increment or decrement by the specified value.
        However, please take into consideration that if you set Frequency to any value greater than 0 and you try to programmatically assign a value to Value, then your value will be converted to the nearest multiple of Frequency.
        For instance, setting Frequency to 5 and then attempting to programmatically set Value to 12 will actually set Value to 10.
        
          MyTrackBar.Frequency := 5;
          MyTrackBar.Value := 12; { actually sets Value to 10 }
        
          MyTrackBar->Frequency = 5;
          MyTrackBar->Value = 12; /* actually sets Value to 10 */"""
    Max: float
    """float: Specifies the maximum value of this track bar for the maximum position of the slider.
        Use the Max property to set a maximum value up to which the slider of this track bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100."""
    Min: float
    """float: Specifies the minimum value of this track bar, for the minimum position of the slider.
        Use the Min property to set a minimum value down to which the slider of this track bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Orientation: Orientation
    """Orientation: Specifies the orientation of this track bar (from left to right or from bottom to top).
        Use the Orientation property to specify how this track bar will be displayed in terms of left-to-right orientation or bottom-to-top orientation. Orientation can have one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        Vertical
        
        
        
        The track bar is rendered with the bottom-to-top orientation.
        
        
        
        
        Horizontal
        
        
        
        The track bar is rendered with the left-to-right orientation."""
    SmallChange: float
    """float: Controls the number of positions that the Thumb of the TCustomTrack moves each time the user presses on a free area."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    Thumb: Thumb
    """Thumb: The part of a track bar that you move to change the value of the track bar.
        The default appearance of the Thumb depends on the platform:
        
        Windows: The Thumb is a rectangle.
        OS X: The Thumb is a circle.
        iOS: The Thumb is a circle.
        Android: The Thumb is a circle."""
    Tracking: bool
    '''bool: Indicates whether thumb tracking is active or not. The default value of Tracking is True.
        The following table shows how the value of Tracking impacts the behavior of a track bar and the related events:
        
        
        
        Tracking
        
        Scenario
        
        Behaviour
        
        Events fired
        
        IsTracking
        
        
        
        True or False
        
        
        
        Press an arrow key on the keyboard.
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each "step" of the movement:
        
        OnTracking
        OnChange
        
        
        True
        
        
        
        
        False
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each step of the movement:
        
        OnTracking
        After you release the Thumb
        
        OnChange
        
        
        True
        
        
        
        
        True
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        False
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True or False
        
        
        
        Hold the Shift button and click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False'''
    Value: float
    """float: Specifies the current value of this track bar.
        Set or get Value to specify or obtain the current value of this track bar. You can set Value programmatically or visually at run time, with any value within the interval delimited by Min and Max."""
    ValueRange: ValueRange
    """ValueRange: Provides access to the Value value, to its Min and Max boundaries, and to the Frequency and ViewportSize properties."""
    ViewportSize: float
    """float: Specifies the size, in pixels, of the area that the slider cannot span to the left or right of this track bar.
        Use the ViewportSize property to specify the size of the view port of this track bar, that is, the area, in pixels, that the slider of this track bar cannot span. As an example, the picture below shows two track bars, one with ViewportSize set to 0 and the other with ViewportSize set to 50.
        
        
        Tip: Changing the ViewportSize property does not affect the limits (Min or Max) or the Value of this track bar."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed and loads the control presentation.
        FMX.StdCtrls.TCustomTrack.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
        Responds after the last constructor has executed and loads the control presentation.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TCustomTrack.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TCustomTrack.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TCustomTrack.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomValueRange(BaseValueRange):
    __hash__: ClassVar[None] = ...
    AfterChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    BeforeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Changing: bool
    """bool: This property identifies that the TCustomValueRange type object is recalculating property values."""
    ClassName: Any
    """Returns the TObject.ClassName"""
    Frequency: float
    """float: The step of possible Value variations.
        FMX.StdActns.TCustomValueRange.Frequency inherits from FMX.StdActns.TBaseValueRange.Frequency. All content below this line refers to FMX.StdActns.TBaseValueRange.Frequency.
        The step of possible Value variations. 
        Value can be multiple of Frequency, Min, or Max. For example, if
        
        Min = 0.1
        Max = 2.1
        ViewportSize = 0
        Frequency = 1
        
        then Value can be:
        
        0.1
        1
        2
        2.1
        
        but it cannot be:
        
        Value = 1.1"""
    Increment: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    IsChanged: bool
    """bool: Handles whether some properties have been changed, but values are still not recalculated."""
    LastValue: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Max: float
    """float: Maximum permissible value of the floating-point Value range.
        FMX.StdActns.TCustomValueRange.Max inherits from FMX.StdActns.TBaseValueRange.Max. All content below this line refers to FMX.StdActns.TBaseValueRange.Max.
        Maximum permissible value of the floating-point Value range."""
    Min: float
    """float: Minimum permissible value of the floating-point Value range.
        FMX.StdActns.TCustomValueRange.Min inherits from FMX.StdActns.TBaseValueRange.Min. All content below this line refers to FMX.StdActns.TBaseValueRange.Min.
        Minimum permissible value of the floating-point Value range."""
    New: BaseValueRange
    """BaseValueRange: Keeps the new values of ValueRange properties. 
        New is the TBaseValueRange type property that keeps the new values of the Value, Min, Max, ViewportSize, and Frequency properties of the current object, declared in the TBaseValueRange class. It can be used in the BeforeChange event handler."""
    OnChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTrackingChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Component
    """Component: The owner component of this class instance."""
    RelativeValue: float
    """float: The Value-based position of the thumb in the scrollable control. 
        The RelativeValue property is calculated relatively to Value, according to the following expression:
        
        RelativeValue = (Value-Min)/(Max-Min-ViewportSize)
        
        It can be in the range from 0 through 1. It can be used for positioning a thumb in a scrollable control, whose parameters are defined by the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency)."""
    Tracking: bool
    """bool: Controls whether the BeforeChange and AfterChange events are fired on each property change. 
        If Tracking = True, then the BeforeChange and AfterChange events are fired on each property change. If Tracking = False, then the BeforeChange and AfterChange events are not fired.
        
        Note: The OnChanged and OnTrackingChange events are fired independently from the Tracking value."""
    UpdateCount: int
    """int: Counter of how many times update changes of the ValueRange properties have been started and not accomplished. 
        If UpdateCount > 0, then no update changes will be actually implemented, and
        all (Value, Min, Max, ViewportSize, and Frequency) properties will have old values. Update changes will be actually implemented only after calls to the EndUpdate method decrement UpdateCount to 0.
        To set new values to these properties, use the New property."""
    Value: float
    """float: A changeable floating-point parameter.
        FMX.StdActns.TCustomValueRange.Value inherits from FMX.StdActns.TBaseValueRange.Value. All content below this line refers to FMX.StdActns.TBaseValueRange.Value.
        A changeable floating-point parameter. 
        The TBaseValueRange class associates a floating-point number Value to its Min and Max ranges."""
    ViewportSize: float
    """float: Used by controls such as TScrollBar to define the thumb size.
        FMX.StdActns.TCustomValueRange.ViewportSize inherits from FMX.StdActns.TBaseValueRange.ViewportSize. All content below this line refers to FMX.StdActns.TBaseValueRange.ViewportSize.
        Used by controls such as TScrollBar to define the thumb size. 
        Note that the effective maximum value of Value decreases according to Max - ViewportSize."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def BeginUpdate(self, *args, **kwargs) -> Any:
        """Called when the ValueRange properties start to update. 
        The BeginUpdate method is called when the object starts to change values of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency).
        BeginUpdate increments the UpdateCount property's value by 1."""
    def Changed(self, IgnoreLoading: bool) -> None:
        """TCustomValueRange.Changed(IgnoreLoading: bool) -> None
        Recalculates values of properties, fires proper events, and sets IsChanged to False. 
        Changed is called immediately after the value of any property (Value, Min, Max, ViewportSize, and Frequency) of the current object has been changed. It recalculates values, raises the proper events (if needed), and sets IsChanged to False. If the Owner component of the action is loading (csLoading) or UpdateCount > 0, then no operations are performed and IsChanged is set to True. After loading the Owner component is finished, the component should check the IsChanged property's value and call the Changed method (if needed).
        If IgnoreLoading = True, then Changed does not check the loading state (csLoading)."""
    def Clear(self, *args, **kwargs) -> Any:
        """Assigns the default values to all properties (Value, Min, Max, and so on). 
        In TCustomValueRange, Clear assigns the following default values:
        
        Value = 0,
        Min = 0,
        Max = 100.0,
        ViewportSize = 0,
        Frequency = 0."""
    def Create(self, AOwner: Component) -> None:
        """TCustomValueRange.Create(AOwner: Component) -> None
        Constructs an object and initializes its data before the object is first used.
        FMX.StdActns.TCustomValueRange.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def Dec(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        FMX.StdActns.TCustomValueRange.Destroy inherits from System.Classes.TPersistent.Destroy. All content below this line refers to System.Classes.TPersistent.Destroy.
        Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Called when the ValueRange properties have finished updating. 
        The EndUpdate method is called when the object accomplishes to change values of the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency).
        EndUpdate decrements the UpdateCount property value by 1."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def Inc(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def IsEmpty(self, *args, **kwargs) -> Any:
        """Checks whether any of the current object properties has an assigned value. 
        Returns True if any of the Value, Min, Max, ViewportSize, and Frequency properties of the current object has an assigned value."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomValueRangeAction(CustomControlAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ValueRange: CustomValueRange
    """CustomValueRange: Provides access to a floating-point value and its permitted ranges.
        ValueRange provides access to the Value, Min, Max, Frequency, ViewportSize, and
        RelativeValue properties and to the methods handling consistency of these properties."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomValueRangeAction.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.TCustomValueRangeAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the instance of the contained action.
        FMX.StdActns.TCustomValueRangeAction.Destroy inherits from System.Actions.TContainedAction.Destroy. All content below this line refers to System.Actions.TContainedAction.Destroy.
        Destroys the instance of the contained action.
        If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomViewAction(CustomAction):
    """A base class for actions that show a specified component when executed.
    Descendants of TCustomViewAction can be associated with a component that is made visible when the action executes.
    TCustomViewAction extends TCustomAction declaring the component that the action shows when it executes.
    TObjectViewAction extends the TCustomViewAction class that defines the FmxObject property and keeps the component value that should be the TFmxObject type object in this case. 
    Descendants of TObjectViewAction are associated with the TFmxObject type component that is made visible when the action executes.  
    TVirtualKeyboard and TViewAction are standard actions that descend from TObjectViewAction.
    Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TCustomViewAction (and its descendants) does not distribute changes in values of Caption, Enabled, Checked, GroupIndex, ShortCut, Visible, and OnExecute properties to the respective properties of clients linked with action links."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    Component: Component
    """Component: Keeps a component that executes an action and whose image becomes visible during the action execution."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TCustomViewAction.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        FMX.ActnList.TCustomViewAction.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DateColumn(DateTimeColumnBase):
    """Represents a column in a grid, whose cells use an editor similar to TDateEdit to edit cells in this column.
    A really used editor depends on implementation of the styled presentation class of TCustomGrid. For example, see TStyledGrid."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TDateColumn.Create(AOwner: Component) -> None
        Creates an instance of TDateColumn."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DateEdit(CustomDateEdit):
    """Wrapper for Delphi TDateEdit"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Date: float
    """float:"""
    DateFormatKind: DTFormatKind
    """DTFormatKind:"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FirstDayOfWeek: CalDayOfWeek
    """CalDayOfWeek:"""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    Format: str
    """str:"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool:"""
    IsEmpty: bool
    """bool:"""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType:"""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCheckChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnOpenPicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool:"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowCheckBox: bool
    """bool:"""
    ShowClearButton: bool
    """bool:"""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
        Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
        Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TodayDefault: bool
    """bool:"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    WeekNumbers: bool
    """bool:"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DateTimeColumn(DateTimeColumnBase):
    """Wrapper for Delphi TDateTimeColumn"""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DateTimeColumnBase(Column):
    """Represents a column in a TGrid grid.
    FMX.Grid.TDateTimeColumnBase inherits from FMX.Grid.TColumn. All content below this line refers to FMX.Grid.TColumn.
    Represents a column in a TGrid grid.
    TColumn is the base class for classes declaring different types of   columns in grids:
    
    TCheckColumn
    TCurrencyColumn
    TDateColumn
    TGlyphColumn
    TImageColumn
    TPopupColumn
    TProgressColumn
    TStringColumn
    TTimeColumn
    If you need to create a new type of column, you should derive your subclass from TColumn."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Format: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShowClearButton: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TDateTimeColumnBase.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TDateTimeColumnBase.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def ValueToString(self, Value: Value) -> str:
        """TDateTimeColumnBase.ValueToString(Value: Value) -> str
        Draws the value of the column cell.
        FMX.Grid.TDateTimeColumnBase.ValueToString inherits from FMX.Grid.TColumn.ValueToString. All content below this line refers to FMX.Grid.TColumn.ValueToString.
        Draws the value of the column cell.
        Each column type defines its own implementation of this method to convert TValue into string value."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DelphiDefaultContainer:
    """Abstract Container type for Delphi"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class DelphiDefaultIterator:
    """Iterator for Abstract Containers"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __next__(self) -> Any:
        """Implement next(self)."""

class DelphiDefaultMapping:
    """Abstract Mapping type for Delphi"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class DelphiMethod:
    """Wrapper for Delphi methods"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __call__(self, *args, **kwargs) -> Any:
        """Call self as a function."""

class DialogService(Object):
    """Wrapper for Delphi TDialogService"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    @classmethod
    def InputQuery(cls, ACaption: str, APrompts: str, AValues: str, ACloseQueryProc: InputCloseQueryProc) -> None:
        """TDialogService.InputQuery(ACaption: str, APrompts: str, AValues: str, ACloseQueryProc: InputCloseQueryProc) -> None"""
    @classmethod
    def MessageDialog(cls, AMessage: str, ADialogType: MsgDlgType, AButtons: MsgDlgButtons, ADefaultButton: MsgDlgBtn, AHelpCtx: int, ACloseDialogProc: InputCloseDialogProc) -> None:
        """TDialogService.MessageDialog(AMessage: str, ADialogType: MsgDlgType, AButtons: MsgDlgButtons, ADefaultButton: MsgDlgBtn, AHelpCtx: int, ACloseDialogProc: InputCloseDialogProc) -> None"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    @classmethod
    def ShowMessage(cls, AMessage: str) -> None:
        """TDialogService.ShowMessage(AMessage: str) -> None"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Edit(CustomEdit):
    """General-purpose FireMonkey edit box.
    TEdit extends the functionality of TCustomEdit by publishing a set of properties to the Object Inspector so you can customize the look and feel of this edit box.
    For using TEdit in a Metro application, see 
    Creating Metropolis UI Edit Buttons with Embedded Glyphs.
    When not in focus, TEdit does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.
    
    Note: For a multiline edit control, use FMX.Memo.TMemo."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Caret: CustomCaret
    """CustomCaret: Represents the caret of the control.
        Caret is of type TCaret."""
    CharCase: EditCharCase
    """EditCharCase: It defines whether to implement the UPPER or lower case conversion to the memo's text."""
    CheckSpelling: bool
    """bool: Defines whether the spell-checking feature of the edit control is on or off.
        This property enables spell checking on the TEdit component. When set to True a red squiggly line appears underlining the words misspelled.  
        The spell checking is performed by an operating system service. It is only supported on iOS and OS X."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FilterChar: str
    """str: Defines characters which can be input in the edit field. All characters not in FilterChar will be
                  ignored. Empty FilterChar value means no filtering."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ImeMode: ImeMode
    """ImeMode: For internal use only.
        Do not use this member. It is for internal use only."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Determines the type of the virtual keyboard.
        Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
        Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).
        
        Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions."""
    KillFocusByReturn: bool
    """bool: Specifies whether to hide the virtual keyboard by clicking the Return key.
        When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MaxLength: int
    """int: Maxmimum length of text that can be input in the edit field."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTyping: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnValidate: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnValidating: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    Password: bool
    """bool: Specifies whether this edit control shows its characters or not.
        Set the Password property to True to make this edit control hide its characters for password-like input. Set Password to False to make this edit control show all its characters."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Determines whether you can change the text of this edit control.
        To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
        Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    ReturnKeyType: ReturnKeyType
    """ReturnKeyType: Indicates the type of action that the edit control performs when you are editing the text of the control and you press the return key on the virtual keyboard. The run-time platform uses this value to determine the type of return button that it displays on the virtual keyboard for the edit control.
        The value of ReturnKeyType does not affect the actual action that the edit control performs when you press the return key. To define that action, use the OnKeyUp event.
        
        Platform Support
        This property only has effect on Android and iOS."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    """str: Contains the text displayed by this edit control.
        Use the Text property to read the text of this edit control or to specify a new string to be displayed."""
    TextPrompt: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextPrompt to cue the user about the kind of entry that is expected in the text field. The TextPrompt is grayed (like a watermark), cannot be scrolled at run time, and is cleared from the entry field as soon as the user begins to type into the edit field.
        The following image contains a design-time preview of setting the TextPrompt property:"""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Ellipse(Shape):
    """TEllipse defines 2D ellipses. It inherits TControl and can be used in styles to construct controls.
    The following TEllipse properties define the ellipse shape and position:
    
    Initially the ellipse is inscribed into the bounding rectangle ShapeRect of the TEllipse object.
    Then the rotation axis RotationCenter is moved along the local coordinate axes proportionally to the Scale factors.
    Then this ellipse is rotated around the obtained pivot on the RotationAngle angle.
    Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
    TEllipse draws the contour and fills the background with the Paint method. 
    Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TEllipse object."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TEllipse.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        FMX.Objects.TEllipse.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Expander(TextControl):
    """Represents a graphical control used to hold multiple graphical controls with the possibility to expand or contract its display area.
    Use TExpander components when you need to provide the user with a way of placing graphical components on a surface that can be expanded or collapsed in order to show or hide its contents.
    
    Collapse or expand this expander control by clicking its collapse/expand button."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    HeaderHeight: int
    """int: Allows to customize header height. Default value is -1.
        When the value is -1, if the style defines a header element style, the element height will be taken for default. If style element is not defined, it takes the FMX.StdCtrls.TExpander.cDefaultHeaderHeight value."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool: Specifies whether the expander's check box is selected or not.
        Set the IsChecked property to True to select the expander's check box. Set IsChecked to False in order to clear the expander's check box.
        The default value for the IsChecked property is True."""
    IsExpanded: bool
    """bool: Specifies whether the expander control is expanded or not.
        Set the IsExpanded property to True to expand the contents of the expander in order to show all the items it contains. Set IsExpanded to False in order to collapse the expander.
        The default value for the IsExpanded property is True.
        You can programatically expand and collapse the expander as shown in the following code snippet:
        
        var
          Expander1: TExpander1;
        
        begin
          { expand the expander control }
          Expander1.IsExpanded := True;
        
          { collapse the expander control }
          Expander1.IsExpanded := False;
        end;"""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnCheckChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExpandedChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExpandedChanging: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowCheck: bool
    """bool: Specifies whether the expander control shows a check box in the upper-right corner.
        Set the ShowCheck property to True to show a check box in the upper-right corner of the expander object. Set ShowCheck to False to hide the check box."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    '''str: Specifies the text that will be rendered over the surface of this TTextControl object.
        Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
        If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters.
        
        Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
        Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be "any string", but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.'''
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TExpander.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TExpander.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ExpanderButton(CustomButton):
    """Represents a collapse/expand button used exclusively by the TExpander component."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    ModalResult: int
    '''int: Determines whether and how the button closes its (modal) parent form.
        Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
        For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).'''
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RepeatClick: bool
    """bool: Specifies whether to automatically repeat the button click after a preset time.
        Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
        The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
        Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button's OnClick event."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TExpanderButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TExpanderButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateAction(Action):
    """Wrapper for Delphi TFMXBindNavigateAction"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateAction.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the instance of the contained action.
        If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TFMXBindNavigateAction.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TFMXBindNavigateAction.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def UpdateTarget(self, Target: Object) -> None:
        """TFMXBindNavigateAction.UpdateTarget(Target: Object) -> None
        Introduces an interface for a method of notifying a client when the action updates itself.
        UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateApplyUpdates(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateApplyUpdates"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateApplyUpdates.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateCancel(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateCancel"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateCancel.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateCancelUpdates(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateCancelUpdates"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateCancelUpdates.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateDelete(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateDelete"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ConfirmDelete: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateDelete.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TFMXBindNavigateDelete.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateEdit(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateEdit"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateEdit.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateFirst(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateFirst"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateFirst.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateInsert(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateInsert"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateInsert.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateLast(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateLast"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateLast.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateNext(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateNext"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateNext.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigatePost(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigatePost"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigatePost.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigatePrior(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigatePrior"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigatePrior.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FMXBindNavigateRefresh(FMXBindNavigateAction):
    """Wrapper for Delphi TFMXBindNavigateRefresh"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AComponent: Component) -> None:
        """TFMXBindNavigateRefresh.Create(AComponent: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileExit(SysCommonAction):
    """The standard action for shutting down the current application.
    Add TFileExit to an action list to let users shut down the application using a menu, control, toolbar button, or shortcut. Clients (controls, menu commands, toolbar buttons) linked to this action cause the application to shut down. 
    TFileExit is not immediate, it calls the method like Terminate that closes the main form. 
    The default ShortCut for TFileExit is CMD+Q."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TFileExit.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.TFileExit.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def CustomTextChanged(self, *args, **kwargs) -> Any:
        """Introduces an interface for a function that is called when the CustomText property for the action changes.
        FMX.StdActns.TFileExit.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
        Introduces an interface for a function that is called when the CustomText property for the action changes.
        As implemented in TCustomAction, CustomTextChanged does nothing. 
        Descendant classes can override CustomTextChanged to provide business functionality.
        The announced purpose of this method is to update the Text property when the CustomText property is changed."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TFileExit.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TFileExit.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TFileExit.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        FMX.StdActns.TFileExit.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileHideApp(SysCommonAction):
    """The standard action for hiding and showing (if hidden) a running macOS application. 
    TFileHideApp hides all windows of the receiver application, and the next application in line is activated. If the windows of the receiver application are hidden, then TFileHideApp restores the hidden windows to the screen and makes the receiver active.
    The default ShortCut for TFileHideApp is CMD+H.
    
    In the current version, TFileHideApp is implemented only for macOS."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TFileHideApp.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.TFileHideApp.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def CustomTextChanged(self, *args, **kwargs) -> Any:
        """Introduces an interface for a function that is called when the CustomText property for the action changes.
        FMX.StdActns.TFileHideApp.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
        Introduces an interface for a function that is called when the CustomText property for the action changes.
        As implemented in TCustomAction, CustomTextChanged does nothing. 
        Descendant classes can override CustomTextChanged to provide business functionality.
        The announced purpose of this method is to update the Text property when the CustomText property is changed."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TFileHideApp.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TFileHideApp.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TFileHideApp.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        FMX.StdActns.TFileHideApp.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileHideAppOthers(FileHideApp):
    """The standard action for hiding all macOS applications, except the receiver.
    The default ShortCut for TFileHideApp is ALT+CMD+H.
    
    In the current version, TFileHideAppOthers is implemented only for macOS."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TFileHideAppOthers.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.TFileHideAppOthers.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def CustomTextChanged(self, *args, **kwargs) -> Any:
        """Introduces an interface for a function that is called when the CustomText property for the action changes.
        FMX.StdActns.TFileHideAppOthers.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
        Introduces an interface for a function that is called when the CustomText property for the action changes.
        As implemented in TCustomAction, CustomTextChanged does nothing. 
        Descendant classes can override CustomTextChanged to provide business functionality.
        The announced purpose of this method is to update the Text property when the CustomText property is changed."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TFileHideAppOthers.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TFileHideAppOthers.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileStream(HandleStream):
    """Wrapper for Delphi TFileStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    FileName: str
    """str:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AFileName: str, Mode: int) -> None:
        """TFileStream.Create(AFileName: str, Mode: int) -> None"""
    def Destroy(self, *args, **kwargs) -> Any: ...
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FloatColumn(CustomNumberColumn):
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    DecimalDigits: int
    """int: The number of decimal places when displaying float numbers."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShowThousandSeparator: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TFloatColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TFloatColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FlowLayout(Control):
    """A control that arranges its child controls as if they were words in a paragraph.
    The children of a TFlowLayout are lined one by one. When the Width of the layout is exceeded, the remaining child controls are wrapped to the next line and so on until all of the controls are placed. To add a line break, like in a normal text, add a TFlowLayoutBreak to the current TFlowLayout. 
    The direction of the controls flow can be from left to right or from right to left. To change the direction, set the FlowDirection property. Changing the direction does not change the line of the control, only the order of the controls on each line.
    The distance between controls from the same line and the distance between lines can be customized by setting the HorizontalGap and VerticalGap properties.
    The TFlowLayout children can be aligned as words in a paragraph: left, right, center, or justified. The alignment can be customized through the Justify property. The alignment of the last line within the layout is treated separately, and can be set through the JustifyLastLine property. If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine.
    
    Note: The Align property of the controls within a TFlowLayout is ignored. The Position property for child controls is automatically set, and explicitly changing its value has no effect. 
    The TFlowLayout can be used to obtain this kind of results:"""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FlowDirection: FlowDirection
    """FlowDirection: Specifies the direction in which the controls are arranged within the TFlowLayout lines.
        The direction of the controls flow can be from left to right or from right to left. Changing the direction does not change the line of the control, only the order of the controls on each line. 
        
        
        
        Value
        
        Result
        
        
        
        LeftToRight
        
        
        
        
        
        
        
        
        RightToLeft"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    HorizontalGap: float
    """float: Specifies the minimum distance between two adjacent child controls of a TFlowLayout.
        If HorizontalGap has a negative value, the child controls are overlapped following the direction specified by the FlowDirection property.
        
        
        
        Gap and direction
        
        Result
        
        
        
        Positive Gap 
        
        
        
        
        
        
        
        
        Negative Gap; Direction=LeftToRight
        
        
        
        
        
        
        
        
        Negative Gap; Direction=RightToLeft"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Justify: FlowJustify
    """FlowJustify: Specifies the justification of all the lines within TFlowLayout, except the last line.
        If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine."""
    JustifyLastLine: FlowJustify
    """FlowJustify: Specifies the justification of the last line of a TFlowLayout. 
        If there is a single line, Justify has no effect, the line is treated as a last line, and is aligned according to JustifyLastLine."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    VerticalGap: float
    """float: Specifies the minimum distance between two adjacent lines of a TFlowLayout.
        If the VerticalGap has a negative value, the lines are overlapped.
        
        
        
        Gap
        
        Result
        
        
        
        Positive Gap 
        
        
        
        
        
        
        
        
        Negative Gap"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TFlowLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TFlowLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FmxObject(Component):
    """The base class for FireMonkey components.
    TFmxObject extends TComponent to provide low-level functionality to FireMonkey components, including:
    
    Creating, destroying, and releasing objects
    Cloning, storing, and loading objects from a stream
    Child object manipulations (add, remove, search)
    Free notifications
    Support for FireMonkey styles
    Support for FireMonkey animations"""
    __hash__: ClassVar[None] = ...
    ActionClient: bool
    """bool: Specifies whether the component object has an associated action.
        If ActionClient is True, this component object is the client of an associated action. 
        If ActionClient is False, this component object is not the client of an action. 
        This property can be checked before calling GetActionLinkClass."""
    Children: FmxChildrenList
    """FmxChildrenList: Stores an array of children attached to this parent component.
        Use the Children property to access each of the children attached to this parent component."""
    ChildrenCount: int
    """int: Read-only property that specifies the number of children in the children list."""
    Data: Value
    """Value: Stores a Tvalue, which is a data structure that can store different kinds of data types.
        Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.
        
        Note: Do not use this member. It is for internal use only."""
    Index: int
    """int: Specifies the index of the child object in the children array attached to this object."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    Root: IRoot
    """IRoot: Specifies the root parent of this object.
        The Root property is a link to the root parent of this object.
        By default, the root object is the youngest parent in the hierarchy of the object parents, which supports the IRoot interface. If no parent supports IRoot, then Root = nil.
        Notice that a Root object provides the Focused, Hovered, and Captured properties. Therefore, among the Children of the Root object, at each moment, there can only be one:
        
        Focused control.
        Control that has captured the mouse.
        Control over which the mouse is hovering."""
    Stored: bool
    """bool: Specifies whether this object is stored in the .XFM file.
        Set the Stored property to True to store the object in the .XFM file. Otherwise, set Stored to False."""
    StyleName: str
    """str: Specifies the style name for this FMX component.
        Read or set the StyleName property to obtain or to set the name of the style for this FireMonkey component. For instance, a TRectangle object can have StyleName set to 'backgroundstyle' or 'panelstyle'."""
    TagFloat: float
    """float: Custom property that stores any floating-point value."""
    TagObject: Object
    """Object: Custom property that stores any object value."""
    TagString: str
    """str: Custom property that stores any string value."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AddFreeNotify(self, AObject: IFreeNotification) -> None:
        """TFmxObject.AddFreeNotify(AObject: IFreeNotification) -> None
        Adds AObject to the list of objects to be notified when this TFmxObject is destroyed.
        The AObject parameter can be any object that implements the IFreeNotification interface, such as a TBrushResource, or a TBrushBitmap."""
    def AddObject(self, AObject: FmxObject) -> None:
        """TFmxObject.AddObject(AObject: FmxObject) -> None
        Adds the AObject object to the Children list of children attached to this parent object (self).
        AddObject internally calls DoAddObject that implements all business functionality of AddObject.
        AddObject adds the object provided in the AObject parameter to the list of children stored in the Children property of this object (self). AddObject changes the parent of AObject to this object (self) and sets the root of AObject to the Root object of this object (self).
        Descendant classes, like TCommonCustomForm and TControl, additionally handle tab stop lists keeping ordered lists of objects to which the user can tab. If such descendant class supports the ITabStopController interface and AObject is an object of a class supporting the IControl interface, then AddObject of this descendant adds AObject to the TabList tab stop lists of the (self) object."""
    def AddObjectsToList(self, AList) -> None:
        """TFmxObject.AddObjectsToList(AList: List<FMX.Types.TFmxObject>) -> None
        Adds the children of this object to the given list.
        The AddObjectsToList method adds all objects that are owned by this object (stored in the Children field) and all of the objects owned by them to the TList provided in the AList parameter."""
    def AnimateColor(self, APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateColor(APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def AnimateFloat(self, APropertyName: str, NewValue: float, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateFloat(APropertyName: str, NewValue: float, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def AnimateFloatDelay(self, APropertyName: str, NewValue: float, Duration: float, Delay: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateFloatDelay(APropertyName: str, NewValue: float, Duration: float, Delay: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def AnimateFloatWait(self, APropertyName: str, NewValue: float, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateFloatWait(APropertyName: str, NewValue: float, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def AnimateInt(self, APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateInt(APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def AnimateIntWait(self, APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None:
        """TFmxObject.AnimateIntWait(APropertyName: str, NewValue: int, Duration: float, AType: AnimationType, AInterpolation: InterpolationType) -> None"""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        FMX.Types.TFmxObject.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BringChildToFront(self, Child: FmxObject) -> None:
        """TFmxObject.BringChildToFront(Child: FmxObject) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def BringToFront(self, *args, **kwargs) -> Any:
        """Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
        You can call BringToFront at run time as in the following code snippet:
        
          Label1.BringToFront;
        
        or, at design time, by right-clicking the FMX visual control and selecting Control > Bring to Front from the pop-up menu."""
    def Clone(self, AOwner: Component) -> FmxObject:
        """TFmxObject.Clone(AOwner: Component) -> FmxObject
        Returns a new cloned instance of this FMX object.
        Clone internally creates and returns a new FMX object that is an exact copy of this object.
        
        Note: The class you want to clone must be registered and be a descendant of TFmxObject. Use RegisterClass or RegisterFMXClasses for your components."""
    def ContainsObject(self, AObject: FmxObject) -> bool:
        """TFmxObject.ContainsObject(AObject: FmxObject) -> bool
        Returns True if the specified object is a direct child.
        ContainsObject returns True if the specified object (AObject) is a direct child of this TFmxObject (self). It returns False otherwise.
        Unlike IsChild, ContainsObject only returns True when passed a direct child of this object as AObject. For example, if A is a direct child of this object, and B is a direct child of A, ContainsObject returns True when passed A as AObject, but it returns False when passed B."""
    def Create(self, AOwner: Component) -> None:
        """TFmxObject.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Types.TFmxObject.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def DeleteChildren(self, *args, **kwargs) -> Any:
        """Deletes all the children of this FMX object.
        DeleteChildren checks whether Children is assigned (children are present) and, if so, it deletes all of them. DeleteChildren also sets Children to nil."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        FMX.Types.TFmxObject.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def EnumObjects(self, *args, **kwargs) -> Any:
        """TFmxObject.EnumObjects(Proc: Func<FMX.Types.TFmxObject,FMX.Types.TEnumProcResult>) -> None
        Loops through the children of this object, and runs the specified procedure once per object as the first parameter in each call."""
    def Exchange(self, AObject1: FmxObject, AObject2: FmxObject) -> None:
        """TFmxObject.Exchange(AObject1: FmxObject, AObject2: FmxObject) -> None
        Exchanges two objects from the children list. Exchange exchanges AObject1 with AObject2."""
    def FindStyleResource(self, AStyleLookup: str, AClone: bool) -> FmxObject:
        """TFmxObject.FindStyleResource(AStyleLookup: str, AClone: bool) -> FmxObject
        Returns the style resource object with the specified (AStyleLookup).
        If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks for the styles of the control's children. If no resource object is found, it returns nil.
        Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True)."""
    def GetParentComponent(self, *args, **kwargs) -> Any:
        """Returns the containing component.
        FMX.Types.TFmxObject.GetParentComponent inherits from System.Classes.TComponent.GetParentComponent. All content below this line refers to System.Classes.TComponent.GetParentComponent.
        Returns the containing component.
        GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
        For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil."""
    def HasParent(self, *args, **kwargs) -> Any:
        """Verifies whether the component has a parent.
        FMX.Types.TFmxObject.HasParent inherits from System.Classes.TComponent.HasParent. All content below this line refers to System.Classes.TComponent.HasParent.
        Verifies whether the component has a parent.
        Call HasParent to determine whether a specific component has a parent. 
        Derived classes override this method to implement proper handling for parenting.
        Use GetParentComponent to retrieve the component reference."""
    def InsertObject(self, Index: int, AObject: FmxObject) -> None:
        """TFmxObject.InsertObject(Index: int, AObject: FmxObject) -> None
        Adds the object provided in the parameter to the FChildren TList of this object (self), at the specified position (index).
        The InsertObject method is similar to the AddObject method, except that InsertObject inserts the given object to the given position specified by the Index parameter."""
    def IsChild(self, AObject: FmxObject) -> bool:
        """TFmxObject.IsChild(AObject: FmxObject) -> bool
        Returns True if the specified object is a child.
        IsChild returns True if the specified object (AObject) is a child of this TFmxObject (self) or any of its children, grand-children, etc. It returns False otherwise.
        Unlike ContainsObject, IsChild not only returns True when passed a direct child of this object as AObject, but also when the specified object is a grand-child, grand-grand-child, and so on of this object. For example, if A is a direct child of this object, and B is a direct child of A, IsChild returns True both when passed A as AObject and when passed B."""
    def ObjectState(self, *args, **kwargs) -> Any: ...
    def Release(self, *args, **kwargs) -> Any:
        """Warning: Release is deprecated.  
        
        
        Marks this TFmxObject object  for delayed deletion."""
    def Released(self, *args, **kwargs) -> Any: ...
    def RemoveFreeNotify(self, AObject: IFreeNotification) -> None:
        """TFmxObject.RemoveFreeNotify(AObject: IFreeNotification) -> None
        Removes the given object from the free notifications list.
        The RemoveFreeNotify method removes the object specified through the AObject parameter, which is of type TFmxObject.
        
        Tip: If you want to use RemoveFreeNotify on an object, that object must have been added to the free notifications list using the AddFreeNotify method."""
    def RemoveObject(self, AObject: FmxObject) -> None:
        """TFmxObject.RemoveObject(AObject: FmxObject) -> None
        Removes a children object from its parent. Calling RemoveObject is equivalent to setting Parent to nil.
        RemoveObject has two overloaded methods. The first one removes the object specified through the AObject parameter, which is of type TFmxObject. The second one removes the object whose index is specified through the Index parameter.
        
        Tip: If you want to use RemoveObject on an object, that object must have been added to the children list through the AddObject method.\r
        Removes a children object from its parent. Calling RemoveObject is equivalent to setting Parent to nil.
        RemoveObject has two overloaded methods. The first one removes the object specified through the AObject parameter, which is of type TFmxObject. The second one removes the object whose index is specified through the Index parameter.
        
        Tip: If you want to use RemoveObject on an object, that object must have been added to the children list through the AddObject method."""
    def SendChildToBack(self, Child: FmxObject) -> None:
        """TFmxObject.SendChildToBack(Child: FmxObject) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def SendToBack(self, *args, **kwargs) -> Any:
        """Sends this FMX visual object to the background letting other overlapping visual controls that are on the same form to be on top of it.
        You can call SendToBack at run time as in the following code snippet:
        
          Label1.SendToBack;
        
        or, at design time by right-clicking the FMX visual control and selecting  Control > Send To Back from the pop-up menu."""
    def SetDesign(self, Value: bool, SetChildren: bool) -> None:
        """TFmxObject.SetDesign(Value: bool, SetChildren: bool) -> None
        Sets the csDesigning in TComponentState. Used internally by the IDE."""
    def SetRoot(self, ARoot: IRoot) -> None:
        """TFmxObject.SetRoot(ARoot: IRoot) -> None
        Sets the Root property of each child in the children list."""
    def Sort(self, Compare: FmxObjectSortCompare) -> None:
        """TFmxObject.Sort(Compare: FmxObjectSortCompare) -> None
        Sorts the children in the children list using the specified sorting procedure."""
    def StopPropertyAnimation(self, APropertyName: str) -> None:
        """TFmxObject.StopPropertyAnimation(APropertyName: str) -> None
        Stops the animation of the specified property of this FMX object.
        StopPropertyAnimation iterates through all the children of this FMX object and, if one of them is of type TFloatAnimation or TColorAnimation and is assigned to the specified property (APropertyName), stops the animation."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Form(CustomForm):
    """TForm represents a standard FireMonkey application window (form).
    When you create forms in the Form designer at design time, they are implemented as descendants of TForm. Forms can represent the application's main window, or dialog boxes or various preferences-related windows. A form can contain any other FireMonkey objects, such as TButton, TCheckBox,  TComboBox objects, and so on."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    ActiveControl: Control
    """Control: Specifies the active control on the form.
        Use ActiveControl to get or set the active control (having the focus) on the form. Only one control can have the focus at a given time, in an application.
        If the form does not have the focus, ActiveControl is the control, on the form, that receives the focus when the form itself receives the focus."""
    BiDiMode: BiDiMode
    """BiDiMode: Indicates the layout of this form when running under Middle Eastern versions of the operating system.
        Use BiDiMode to specify the bi-directional mode for the application. The bi-directional mode controls the direction in which text appears (left-to-right or right-to-left), the placement of vertical scroll bars, and the default alignment of text when the application runs in Middle Eastern locales."""
    Border: FormBorder
    """FormBorder: Embarcadero Technologies does not currently have any additional information."""
    BorderIcons: BorderIcons
    """BorderIcons: Specifies which icons appear on the title bar of the form.
        Use BorderIcons to get or set the icons that appear on the title bar of the form. BorderIcons can include any of the following TBorderIcons values:
        
        
        
        Value
        
        Meaning
        
        
        
        biSystemMenu
        
        
        
        The form has a Control menu (also known as a System menu).
        
        
        
        
        biMinimize
        
        
        
        The form has a Minimize button.
        
        
        
        
        biMaximize
        
        
        
        The form has a Maximize button.
        
        
        
        
        biHelp
        
        
        
        Has no effect in FireMonkey."""
    BorderStyle: FmxFormBorderStyle
    """FmxFormBorderStyle: Specifies the appearance and behavior of the form border.
        Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TFmxFormBorderStyle values:
        
        
        
        Value
        
        Meaning
        
        
        
        Single
        
        
        
        Not resizable; minimize/maximize menu
        
        
        
        
        None
        
        
        
        Not resizable; no visible border line
        
        
        
        
        Sizeable
        
        
        
        Standard resizable border
        
        
        
        
        ToolWindow
        
        
        
        Similar to Single, but with a smaller caption
        
        
        
        
        SizeToolWin
        
        
        
        Similar to Sizeable, but with a smaller caption
        
        
        Notes:
        
        In iOS applications, None makes your form run in fullscreen mode. With any other value, your iOS app shows the iOS status bar.
        In Android applications, the BorderStyle property does not control fullscreen display. Instead, you should set the theme property on the  Project > Options > Version Info  page of your Android project:
        Setting the theme = TitleBar means that your Android app includes a title or status bar.
        Setting the theme = NoTitleBar means that your Android app runs in fullscreen mode, without a title or status bar."""
    Caption: str
    """str: Specifies a text string that identifies the form to the user.
        Use Caption to specify the text string that labels the form, identifying it to the user."""
    ClientHeight: int
    """int: Specifies the height (in pixels) of the form's client area.
        Use ClientHeight to determine the height (in pixels) of the form's client area. The client area is the usable area inside the form's border, excluding the title bar, scroll bars, and so on.
        Set ClientHeight to change the height of the form's window based on the desired client area. To change the height of the form's window based on the total size of the window (including the border, menu, status bar and so on), use the Height property instead."""
    ClientWidth: int
    """int: Specifies the width (in pixels) of the form's client area.
        Use ClientWidth to determine the width (in pixels) of the form's client area. The client area is the usable area inside the form's border. Set ClientWidth to change the width of the form's window based on the desired client area. To change the width of the form's window based on the total size of the window (including the border, status bar, and so on), use the Width property instead."""
    Constraints: SizeConstraints
    """SizeConstraints: Embarcadero Technologies does not currently have any additional information."""
    Cursor: int
    """int: Specifies the mouse cursor that will be used on this form."""
    Fill: Brush
    """Brush: Specifies the way the background on this form is filled.
        Use Fill to get or set the brush that defines the way the background of this form is painted (gradient, solid, and so on).
        
        Tip: Using a brush for Fill overrides the functionality of the Transparency property."""
    FormFactor: FormFactor
    """FormFactor: Specifies the form factor for this FireMonkey form, that is, the TFormFactor properties: width, height, orientations, and devices."""
    FormFamily: str
    """str: Is a string property that specifies the form family this form is part of. 
        The logic can choose a different form as the main form depending on size, if an app has several forms with the same .FormFamily value as the app's main form."""
    FormStyle: FormStyle
    """FormStyle: Determines the form style.
        FormStyle is one of the Normal, Popup, or StayOnTop values defined in TFormStyle."""
    FullScreen: bool
    """bool: Indicates whether the form is in fullscreen mode.
        Use FullScreen to specify whether the form is in fullscreen mode."""
    Height: int
    """int: Specifies the vertical size of the form (in pixels).
        Use the Height property to read or change the height of the form."""
    Left: int
    """int: Specifies the X coordinate of the upper-left corner of the form, relative to the screen.
        Use Left to locate the top of the form or reposition the form to a different X coordinate. The Left property, like the Top property, is the position of the form relative to its container (the screen), in pixels."""
    OnActivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClose: Callable[[Object,CloseAction],None]
    """Callable[[Object, CloseAction], None]:"""
    OnCloseQuery: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnConstrainedResize: Callable[[Object,float,float,float,float],None]
    """Callable[[Object, float, float, float, float], None]:"""
    OnCreate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeactivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDestroy: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFocusChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnHide: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSaveState: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTap: Callable[[Object,PointF],None]
    """Callable[[Object, PointF], None]:"""
    OnTouch: Callable[[Object,tuple,TouchAction],None]
    """Callable[[Object, tuple, TouchAction], None]:"""
    OnVirtualKeyboardHidden: Callable[[Object,bool,Rect],None]
    """Callable[[Object, bool, Rect], None]:"""
    OnVirtualKeyboardShown: Callable[[Object,bool,Rect],None]
    """Callable[[Object, bool, Rect], None]:"""
    Padding: Bounds
    """Bounds: Specifies the padding of the form. 
        The Padding of a form specifies how close, in pixels, the child of the form can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the form.
        The child of the form is repositioned and resized, if necessary, to fit the Padding."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    Position: FormPosition
    """FormPosition: Represents the size and placement of the form.
        Use Position to get or set the size and placement of the form. Position can have one of the following TFormPosition values:
        
        
        
        Value
        
        Meaning
        
        
        
        Designed
        
        
        
        The form appears positioned on the screen and with the same height and width as it had at design time.
        
        
        
        
        Default
        
        
        
        The form appears in a position on the screen and with a height and width determined by the operating system. Each time you run the application, the form moves slightly down and to the right. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
        On OS X, the default position for new windows is the upper-left corner of the screen.
        
        
        
        
        DefaultPosOnly
        
        
        
        The form displays with the size you created it at design time, but the operating system chooses its position on the screen. Each time you run the application, the form moves slightly down and to the right. When the form can no longer move down and to the right and keep the same size while remaining entirely visible on the screen, the form displays in the upper-left corner of the screen.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of None, for example), the window is positioned in the upper-left corner of the screen.
        On OS X, the default position for new windows is the upper-left corner of the screen.
        
        
        
        
        DefaultSizeOnly
        
        
        
        The form appears in the position you left it at design time, but the operating system chooses its size. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        
        
        
        
        ScreenCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen.
        
        
        
        
        DesktopCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen. No adjustments are made for multi-monitor applications.
        
        
        
        
        MainFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the application's main form. No adjustments are made for multi-monitor applications. This position should only be used with secondary forms. If set for a main form, it acts like ScreenCenter.
        
        
        
        
        OwnerFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the owner form. If there is no owner form, this position acts like MainFormCenter.
        
        
        Note that, if Position is set to Default, DefaultPosOnly, or DefaultSizeOnly, and BorderStyle is set to None, the form will be positioned at (0,0)."""
    Quality: CanvasQuality
    """CanvasQuality: Embarcadero Technologies does not currently have any additional information."""
    ShowFullScreenIcon: bool
    """bool: Indicates whether the Mac fullscreen icon is visible.
        Use ShowFullScreenIcon to specify whether the Mac fullscreen icon  or  is visible. 
        
        Note: ShowFullScreenIcon has no visible effect in Windows."""
    ShowHint: bool
    """bool: Determines whether help hints are enabled or disabled for first level child controls in the form.
        For more information about the rules for enabling hints for a control, see   Using Hints to Show Contextual Help in a FireMonkey Application.
         TCommonCustomForm.ShowHint is a Boolean property set as True by default. When you place a child control in the form, and set the  TControl.Hint property, the hint is displayed because the TControl.ParentShowHint is True by default.
        If the  TCommonCustomForm.ShowHint property of the form is set to False, the hint is not displayed in the child control.
        To show the hint for a control, even when the  TCommonCustomForm.ShowHint property of the form is set to False, set  TControl.ShowHint for the control to True."""
    StyleBook: StyleBook
    """StyleBook: Specifies the style book for this form. For more information on how to customize the looks of a FireMonkey application with styles, refer to the Customizing FireMonkey Applications with Styles help topic."""
    StyleLookup: str
    """str: Specifies the name of the style to look up and apply to this form. The FireMonkey Component Design help topic shows, among other useful things related to component designing, how to apply a style to a TPanel component."""
    SystemStatusBar: FormSystemStatusBar
    """FormSystemStatusBar: System status bar settings on mobile platforms."""
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of the form, relative to the screen.
        Use Top to locate the top of the form or reposition the form to a different Y coordinate. The Top property, like the Left property, is the position of the form relative to its container (the screen), in pixels."""
    Touch: TouchManager
    """TouchManager: Embarcadero Technologies does not currently have any additional information."""
    Transparency: bool
    """bool: Indicates whether the form is transparent or not.
        Use Transparency to determine whether the form is displayed as a totally transparent one. However, note that in this situation, all the controls will not be transparent and will be displayed normally. Only the form's background will be set to a transparent state.
        If you set Transparency to True, the form will not display its title bar, nor its border. This means that you need to apply programmatic methods (involving setting of the Top and Left properties) to move the form on the screen surface."""
    Visible: bool
    """bool: Indicates whether the form is visible.
        Use Visible to determine whether the form is visible.
        If Visible is True, the form is visible unless it is completely obscured by other forms. If Visible is False, the form is not visible.
        The Show and ShowModal methods set Visible to True and bring the form to the front of all open windows."""
    Width: int
    """int: Specifies the horizontal size of the form (in pixels).
        Use the Width property to read or change the width of the form."""
    WindowState: WindowState
    """WindowState: Represents how the form appears on the screen.
        Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state.
        Possible values for the WindowState property are:
        
        wsMaximized
        wsMinimized
        wsNormal"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def LoadProps(self) -> Any:
        """TCommonCustomForm.LoadProps()
        Load properties from a .pydfm file"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Frame(Control):
    """TFrame is a container for components; it can be nested within forms or other frames.
    When you create frames, they are implemented as descendants of TFrame.
    A frame, like a form, is a container for other components. It uses the same ownership mechanism as forms for automatic instantiation and destruction of the components on it, and the same parent-child relationships for synchronization of component properties. But frames can be nested within forms or other frames, and they can be saved on the Component palette for easy reuse. After a frame is created and saved, it continues to function as a unit and to inherit changes from the components (including other frames) it contains. Moreover, an embedded frame continues to inherit changes made to the frame from which it is derived."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        FMX.Forms.TFrame.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
        Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TFrame.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Forms.TFrame.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TFrame.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Enumerates all child components.
        FMX.Forms.TFrame.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
        Enumerates all child components.
        GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
        GetChildren expects a TGetChildProc routine that receives all enumerated components. 
        Root represents the owner of the components that will be enumerated.
        This method does nothing in TComponent and is expected to be overridden in descendants."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def ShouldTestMouseHits(self, *args, **kwargs) -> Any:
        """Indicates whether a control should be ignored in ObjectAtPoint.
        FMX.Forms.TFrame.ShouldTestMouseHits inherits from FMX.Controls.TControl.ShouldTestMouseHits. All content below this line refers to FMX.Controls.TControl.ShouldTestMouseHits.
        Indicates whether a control should be ignored in ObjectAtPoint.
        False if the control should be ignored in ObjectAtPoint. ShouldTestMouseHits normally returns the same value as the value of Visible property of the control.
        TFrame overrides this method to allow itself to be painted in design time regardless of the value of its Visible property.
        
         See Also
        FMX.Forms.TFrame
        FMX.Controls.TControl.ObjectAtPoint
        FMX.Controls.TControl.Visible"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FramedScrollBox(CustomScrollBox):
    """Extends TCustomScrollBox declaring published properties.
    TFramedScrollBox extends TCustomScrollBox declaring published properties. TFramedScrollBox does not extend the base class with any new functionality.
    In difference to TScrollBox, TFramedScrollBox draws the edges (top, left, bottom, and right) and fills the control rectangle with some special color. Therefore, TFramedScrollBox scroll boxes are highlighted from the background of a parent control."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHide: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Content: ScrollContent
    """ScrollContent: Keeps an object that represents a scrollable content.
        A TScrollBox object uses a TScrollContent object in order to provide an area onto which you can place any other graphical components. Content keeps this TScrollContent object."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnHScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnVScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ShowSizeGrip: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FramedVertScrollBox(VertScrollBox):
    """Represents a TFramedScrollBox with an applied framedscrollboxstyle style lookup."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GlyphColumn(Column):
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    GlyphInterface: IGlyph
    """IGlyph: Reference to a glyph interface supported by the PresentedControl using this glyph column and the current data model."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    OnGetImageIndex: Callable[[Column,Value,int],None]
    """Callable[[Column, Value, int], None]:"""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Stretch: bool
    """bool: Specifies whether to stretch the image shown in the glyph control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanEdit(self, *args, **kwargs) -> Any:
        """Returns True if the column can show a value editor or False otherwise.
        FMX.Grid.TGlyphColumn.CanEdit inherits from FMX.Grid.TColumn.CanEdit. All content below this line refers to FMX.Grid.TColumn.CanEdit.
        Returns True if the column can show a value editor or False otherwise.
        
         See Also
        FMX.Grid.TColumn.EditingCancelled
        FMX.Grid.TColumn.EditingDone
        FMX.Grid.TColumn.EditorModified
        FMX.Grid.TColumn.PostEditorValue
        FMX.Grid.TColumn.RefreshEditor"""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def DefaultDrawCell(self, Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None:
        """TGlyphColumn.DefaultDrawCell(Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None
        Draws the default cell background.
        FMX.Grid.TGlyphColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
        Draws the default cell background.
        DefaultDrawCell receives the following parameters:
        
        Canvas is the canvas where DefaultDrawCell paints the cell background.
        Bounds indicates the cell boundaries.
        Row is the row number.
        Value is the cell value.
        State is the drawing state of the cell.
        DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.
        
         See Also
        FMX.Grid.TColumn.DrawCell
        FMX.Grid.TColumn.BeforeDrawing
        FMX.Grid.TColumn.AfterDrawing"""
    def GetImageIndex(self, Value: Value) -> int:
        """TGlyphColumn.GetImageIndex(Value: Value) -> int
        Returns the index of the image specified by Value.
        GetImageIndex returns the index of the image corresponding to the specified Value. Index is in a list of images specified in TGrid.Images."""
    def GlyphPlaceIntoBounds(self, Index: int, Bounds: RectF, Scale: float) -> RectF:
        """TGlyphColumn.GlyphPlaceIntoBounds(Index: int, Bounds: RectF, Scale: float) -> RectF
        Returns the rectangle in which to draw the Index image. Stretches and aligns the original rectangle of the Index image, preserving its rectangle proportions, to best fit into the Bounds rectangle.
        GlyphPlaceIntoBounds implements algorithm like the following:
        
        If the Stretch property of the current TGlyphColumn object is False, then GlyphPlaceIntoBounds retrieves the biggest rectangle from all layers of the Index image in the destination collection stretched to the Scale = 1. Then GlyphPlaceIntoBounds stretch the obtained rectangle, preserving its rectangle proportions, to best fits into the specified Bounds rectangle. Then GlyphPlaceIntoBounds aligns this rectangle in the Bounds rectangle using the default alignment parameters of the current column. GlyphPlaceIntoBounds returns the obtained rectangle.
        If the Stretch property of the current TGlyphColumn object is True, then GlyphPlaceIntoBounds retrieves the biggest rectangle from all layers of the Index image in the destination collection with the  Scale used in the layer. Then GlyphPlaceIntoBounds stretch the obtained rectangle, preserving its rectangle proportions, to best fits into the specified Bounds rectangle. Then GlyphPlaceIntoBounds aligns this rectangle in the Bounds rectangle using the default alignment parameters of the current column. GlyphPlaceIntoBounds returns the obtained rectangle."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GradientEdit(Control):
    """Represents a gradient editor component.
    A TGradientEdit component is a gradient editor that can be used to create new gradient patterns."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ColorPicker: ColorPicker
    """ColorPicker: Specifies the color picker attached to this gradient editor component.
        A color picker is a visual component represented as a rectangular-shaped optical indicator that permits you to select a color from the color spectrum."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    CurrentPoint: int
    """int: Specifies the location of the selector point over the spanning of the component, which is a gradient color selector.
        When the CurrentPoint property changes, an OnSelectPoint event also occurs."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Gradient: Gradient
    """Gradient: Specifies the color gradient this gradient edit component will use.
        Set or get the Gradient property to a TGradient type in order to specify a new gradient pattern."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectPoint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TGradientEdit.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Colors.TGradientEdit.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Colors.TGradientEdit.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def UpdateGradient(self, *args, **kwargs) -> Any:
        """Executes each time the selected color changes in order to update the gradient."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Grid(CustomGrid):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultDrawing: bool
    """bool: Determines whether cells are drawn using the default drawing method (True) or using a user-defined drawing method (False)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Specifies the list of images associated with this grid control. 
        Images from the Images collection can be shown in cells of the TGlyphColumn type column."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCellClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnCellDblClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnColumnMoved: Callable[[Column,int,int],None]
    """Callable[[Column, int, int], None]:"""
    OnCreateCustomEditor: Callable[[Object,Column,StyledControl],None]
    """Callable[[Object, Column, StyledControl], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnDrawColumnBackground: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnCell: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnHeader: Callable[[Object,Canvas,Column,RectF],None]
    """Callable[[Object, Canvas, Column, RectF], None]:"""
    OnEditingDone: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnGetValue: Callable[[Object,int,int,Value],None]
    """Callable[[Object, int, int, Value], None]:"""
    OnHeaderClick: Callable[[Column],None]
    """Callable[[Column], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectCell: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnSetValue: Callable[[Object,int,int,Value],None]
    """Callable[[Object, int, int, Value], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Options: GridOptions
    """GridOptions: Defines how grid controls look like and how they behave."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Specifies whether the cells in this grid can be modified or not.
        Use ReadOnly at run time to determine whether the cells in this grid can be edited. If ReadOnly is True, then you can only read and view the contents of the cells without the ability to affect the grid in any way."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    RowCount: int
    """int: Specifies the number of rows in the grid.
        The value of RowCount includes the scrollable rows in the grid, but not the fixed row with the headers.
        
        Read RowCount to determine the number of rows in the grid.
        Set RowCount to add or delete rows at the bottom of the grid."""
    RowHeight: float
    """float: Specifies the height of each row of this grid, in pixels.
        Read RowHeight to determine the size of each row in the grid. If the underlying grid is too tall to appear in the control, then the user must scroll to see the entire content of the grid."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GridLayout(Control):
    """A control that arranges child controls in a grid of equally sized cells.
    A TGridLayout grid layout is a container for graphical objects that can arrange the objects it contains in a grid, as shown in the following image:
    
    
    The children of a TGridLayout are resized to fit the sizes specified through the ItemHeight and ItemWidth properties. If the orientation is set to Horizontal, the child controls of a TGridLayout are lined one by one until the width of the layout is exceeded when a new line is added to the grid. If the orientation is set to Vertical, the child controls of a TGridLayout are positioned one under another until the height of the layout is exceeded when a new column is added to the grid. 
    However, you can customize sizes of child controls using the Margins properties of child controls. For example, the following image demonstrates the usage of different margins for Button5, Button6, Button7, and Button8 child controls: 
    
    
    Here we set:
    
    The Top and Bottom margins for Button5.
    The Left margin for Button6.
    All four Top, Left, Right, and Bottom margins for Button7.
    The Top and Left margins for Button8.
    Look how child controls are resized and positioned inside the respective grid cells.
    
    Note: The Align property of the controls within a TGridLayout is ignored. The Position, Height, and Width properties for child controls are automatically set, and explicitly changing their values has no effect."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    ItemHeight: float
    """float: Specifies the height of each cell that holds an item in a grid layout control.
        Use ItemHeight in combination with ItemWidth in order to change the aspect ratio of the graphical objects that are part of this grid layout."""
    ItemWidth: float
    """float: Specifies the width of each cell that holds an item in a grid layout control.
        Use ItemWidth in combination with ItemHeight in order to change the aspect ratio of the graphical objects that are part of this grid layout."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Orientation: Orientation
    """Orientation: Specifies the orientation of the graphical controls that are part of this grid.
        The Orientation property can be set to either Horizontal or Vertical in order to change the grid's orientation (and the position of the graphical objects in this grid) to either horizontal (left to right) or vertical (top to bottom)."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TGridLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TGridLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GridPanelLayout(Control):
    """Implements a grid panel layout control in which each component is placed within a cell on a grid panel.
    In a TGridPanelLayout layout, you specify the number of rows and columns on the grid panel, then each component is placed into the next available cell in the grid panel, regardless of where you place it with the mouse. If each grid panel layout's cell already contains a control and you add more controls, the location for the new controls is determined by the ExpandStyle property. For example, using the default AddRows value of the ExpandStyle property, a new row is added to the grid panel, and each cell in this row can contain a new control. 
    TGridPanelLayout layouts provide the following behavior:
    
    You can explicitly set the Height,  Width, Align, and Anchors properties of child controls to manually resize and align child controls placed inside cells on a TGridPanelLayout layout:
    
    You can specify that a child control can span on several merged cells. For example, look at the following figure:
    
    Here, the B4 button spans on two cells in the rightmost column, the B5 button occupies four cells in two rows and two columns and the B8 button occupies three cells in the bottom row.
    To specify that a child control can span on several cells you can use the following trick:
    
    In the Structure view, locate the desired TGridPanelLayout layout node.
    Under this node, locate the respective Control Collection node.
    Among control items in this Control Collection, select the control item associated with the desired child control. The Object Inspector shows the properties of this control item.
    In the ColumnSpan property, type the number of cells that can be occupied be the control item in the respective column (specified in the Column property).
    In the RowSpan property, type the number of cells that can be occupied by the control item in the respective row (specified in the Row property)."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    CellCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    CellRect: RectF
    """RectF:"""
    CellSize: PointF
    """PointF:"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ColumnCollection: GridPanelLayout.TColumnCollection
    """GridPanelLayout.TColumnCollection: Keeps the TColumnCollection column collection in the TGridPanelLayout grid panel layout. 
        The Count property of ColumnCollection defines the number of columns in TGridPanelLayout."""
    ColumnSpanIndex: int
    """int:"""
    ControlCollection: GridPanelLayout.TControlCollection
    """GridPanelLayout.TControlCollection: Keeps the TControlCollection control collection of TControlItem control items.
        Use ControlCollection to add, remove, or access control items in the collection of controls in a TGridPanelLayout grid panel layout. Each control item is identified by its Row and Column properties."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    ExpandStyle: GridPanelLayout.TExpandStyle
    """GridPanelLayout.TExpandStyle: Specifies whether to add a row or column to a filled grid panel layout to accommodate additional controls.
        The meanings of the options are:
        
        
        
        Value
        
        Meaning
        
        
        
        AddRows
        
        
        
        TGridPanelLayout is expanded vertically -- only rows are added.
        
        
        
        
        AddColumns
        
        
        
        TGridPanelLayout is expanded horizontally -- only columns are added.
        
        
        
        
        FixedSize
        
        
        
        TGridPanelLayout has a fixed number of rows and columns given by the Count property of both the ColumnCollection and RowCollection collections.
        
        
        The property is used when a new control is added to the  ControlCollection using 
        AddControl with the AColumn and ARow parameters set to -1. For example:
        
        GridPanelLayout1.ControlCollection.AddControl(AControl,-1,-1);
        
        where AControl is the control to add to the GridPanelLayout1 grid panel layout."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    RowCollection: GridPanelLayout.TRowCollection
    """GridPanelLayout.TRowCollection: Keeps the TRowCollection row collection in the TGridPanelLayout grid panel layout. 
        The Count property of RowCollection defines the number of rows in TGridPanelLayout."""
    RowSpanIndex: int
    """int:"""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TGridPanelLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TGridPanelLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Layouts.TGridPanelLayout.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def IsColumnEmpty(self, AColumn: int) -> bool:
        """TGridPanelLayout.IsColumnEmpty(AColumn: int) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def IsRowEmpty(self, ARow: int) -> bool:
        """TGridPanelLayout.IsRowEmpty(ARow: int) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def UpdateControlsColumn(self, AColumn: int) -> None:
        """TGridPanelLayout.UpdateControlsColumn(AColumn: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def UpdateControlsRow(self, ARow: int) -> None:
        """TGridPanelLayout.UpdateControlsRow(ARow: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GroupBox(PresentedTextControl):
    """Represents a graphical control used to arrange multiple related graphical controls on the surface of a form.
    Use TGroupBox whenever you need to arrange multiple related controls on a form (for instance, multiple radio buttons or check boxes). The most commonly grouped controls are radio buttons. After placing a group box on a FireMonkey form, select components from the Tool Palette and place them in the group box. The Text property contains text that labels the group box at run time.
    
    Similar components are:
    
    TPanel (without the frame and text caption)
    TExpander (additionally provides collapse/expand functionality)"""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TGroupBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TGroupBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class HandleStream(Stream):
    """Wrapper for Delphi THandleStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Handle: int
    """int:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AHandle: int) -> None:
        """THandleStream.Create(AHandle: int) -> None"""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """THandleStream.Read(Buffer, Count: int) -> int"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """THandleStream.Seek(Offset: int, Origin: SeekOrigin) -> int"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """THandleStream.Write(Buffer, Count: int) -> int"""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class HintAction(CustomAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """THintAction.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.THintAction.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class HorzScrollBox(CustomScrollBox):
    """Represents a TScrollBox  restricted to horizontal scrolling."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHide: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Content: ScrollContent
    """ScrollContent: Keeps an object that represents a scrollable content.
        A TScrollBox object uses a TScrollContent object in order to provide an area onto which you can place any other graphical components. Content keeps this TScrollContent object."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnHScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ShowSizeGrip: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Image(Control):
    """TImage defines 2D image components. It inherits TControl and can be used in styles to construct controls.
    Use TImage to display a graphical image on a control.
    Use the MultiResBitmap property to specify the multi-resolution set of bitmaps the most appropriate of which will be displayed as the picture on this TImage control. The TImage control shows the bitmap item with the scale best matching to the device resolution. See in the Bitmap property which algorithm is used to define the most appropriate bitmap item.
    You can find the list of supported picture formats in TBitmapCodecManager.
    Use the WrapMode property to specify whether and how to resize, replicate, and position the bitmap image for rendering the TImage surface. 
    Notice that if any BitmapMargins is defined, then WrapMode is ignored."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Bitmap: Bitmap
    """Bitmap: Specifies the bitmap picture that will be displayed by this TImage component.
        Set the Bitmap property to the bitmap picture that you want to be displayed by this TImage component. Reading Bitmap provides a TBitmap image that you can assign to other TImage components or you can save to a stream or a file.
        The Bitmap getter retrieves the Bitmap image from the appropriate bitmap item of the multi-resolution bitmap stored in MultiResBitmap. When you set a new value to the bitmap, the Bitmap setter saves this bitmap in this bitmap item of the MultiResBitmap multi-resolution bitmap. If you change this bitmap item in MultiResBitmap by any way, this will change the Bitmap image. For example, you can edit MultiResBitmap in the MultiResBitmap Editor from the Object Inspector. 
        For a list of image formats supported by this component, please refer to the TBitmapCodecManager API help topic.
        You can also assign an image programmatically, as exemplified in the following code snippet:
        
          Image1.Bitmap.LoadFromFile('MyImage.jpg');
        
        Note: The Bitmap getter uses the following algorithm to retrieve the Bitmap property's value:
        Using the GetSceneScale function for the Scene in which the control is drawn, the Bitmap getter retrieves the Scale for the current device. If Scene is not defined, then the 1.0 value for Scale is accepted.
        If MultiResBitmap is assigned, then the getter gets the Bitmap from the bitmap item having the scale best matching to the obtained Scale (not including empty bitmap items.)
        If the getter does not find any not empty bitmap item, then the getter tries to retrieve an empty bitmap item having the scale exactly matching to the obtained Scale.
        If the getter cannot find an empty bitmap item having the obtained Scale, then the getter creates a new bitmap item with the obtained Scale and returns the bitmap from the created bitmap item.
        If the obtained Scale <= 0 or MultiResBitmap is not assigned, the exception is raised."""
    BitmapMargins: Bounds
    """Bounds: Specifies the margins of the bitmap displayed by this TImage component.
        Set or read the BitmapMargins property in order to affect the margins of the image that is displayed by this TImage component."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DisableInterpolation: bool
    """bool: Enables or disables the interpolation of the bitmap image displayed by this TImage component.
        The DisableInterpolation property specifies whether the interpolation is used while rendering the bitmap image displayed by this TImage component. By default, DisableInterpolation is set to False.
        The following picture shows the same image rendered once with DisableInterpolation set to False and once with DisableInterpolation set to True."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    MarginWrapMode: ImageWrapMode
    """ImageWrapMode: Specifies how the margins of the Bitmap are resized, replicated, and positioned.
        Use MarginWrapMode property to set and get how the margins of the Bitmap are displayed within the TImage. By default the margins are stretched to fill the entire TImage. To see the possible values of MarginWrapMode, go to TImageWrapMode.
        If BitmapMargins property is not set, then MarginWrapMode has no effect over the image."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MultiResBitmap: FixedMultiResBitmap
    """FixedMultiResBitmap: Keeps the   TFixedMultiResBitmap multi-resolution bitmap."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WrapMode: ImageWrapMode
    """ImageWrapMode: Specifies whether and how to resize, replicate, and position the bitmap image for rendering the TImage surface.
        The WrapMode property should be one of the constants defined in the TImageWrapMode type:
        
        Original displays the image with its original dimensions.
        Fit provides the best fit, keeping image proportions (the ratio between the width and height) for the TImage rectangle. If needed, the image is scaled down or stretched to best fit the rectangle area. This is the default option.
        Stretch stretches the image to fill the entire rectangle of the TImage component.
        Tile tiles the TImage image to cover the entire rectangle of the TImage component.
        Center centers the image to the rectangle of the TImage component. The image is never resized, regardless the size of the rectangle of the TImage component.
        Place fits the image into the TImage rectangle. If the width or height of the image is greater than the corresponding dimension of the TImage rectangle, then the image is scaled down keeping image proportions (the ratio between the width and height) to fit in the TImage rectangle. The obtained image is centered in the TImage rectangle.  Place only makes images smaller, never larger."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TImage.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Objects.TImage.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Objects.TImage.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DrawBitmap(self, Canvas: Canvas, ARect: RectF, ABitmap: Bitmap, AOpacity: float) -> None:
        """TImage.DrawBitmap(Canvas: Canvas, ARect: RectF, ABitmap: Bitmap, AOpacity: float) -> None
        Draws a TBitmap image after scaling it to a specified area of the TCanvas.
        Use this method to display a whole bitmap image into a specified area of the TCanvas. To display a specified area of the bitmap image, use the FMX.Graphics.TCanvas.DrawBitmap method.
        
        Parameters
        This method defines the following parameters:
        
        Canvas: specifies a canvas.
        ARect: specifies the rectangle area of Canvas to be drawn.
        ABitmap: specifies a TBitmap image.
        AOpacity: specifies the transparency to be applied to the ABitmap.
        Notes
        When using the  DrawBitmap method, pay attention to the following:
        
        When drawing a bitmap image, this method uses the following properties of TImage:
        FMX.Objects.TImage.BitmapMargins: Specifies the margins of the bitmap image to draw.
        FMX.Objects.TImage.WrapMode: Specifies whether and how to resize, replicate, and position the bitmap image.
        It is recommended to use this method within the onPaint event handlers, such as FMX.Controls.TControl.OnPaint or FMX.Forms.TCustomForm.OnPaint."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ImageColumn(Column):
    """Represents a column in a grid, whose cells show images."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    PreviewSize: Size
    """Size: Represents the maximum size of a thumbnail that can be displayed in cells of the column.
        To improve performance, large pictures are reduced to the specified PreviewSize size. The obtained thumbnail is stored in internal cache and is drawn during repainting."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TImageColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TImageColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def DefaultDrawCell(self, Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None:
        """TImageColumn.DefaultDrawCell(Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None
        Draws the default cell background.
        FMX.Grid.TImageColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
        Draws the default cell background.
        DefaultDrawCell receives the following parameters:
        
        Canvas is the canvas where DefaultDrawCell paints the cell background.
        Bounds indicates the cell boundaries.
        Row is the row number.
        Value is the cell value.
        State is the drawing state of the cell.
        DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.
        
         See Also
        FMX.Grid.TColumn.DrawCell
        FMX.Grid.TColumn.BeforeDrawing
        FMX.Grid.TColumn.AfterDrawing"""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ImageControl(StyledControl):
    """Represents a graphical control used to display images on a FireMonkey form.
    Use a TImageControl whenever you need to put an image on a FireMonkey form. You can use the Bitmap property to specify the image that will be displayed."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bitmap: Bitmap
    """Bitmap: Specifies a TBitmap picture to be displayed onto the surface of this image control component.
        Use Bitmap to specify the image for the TImageControl component. Bitmap is a reference to a FMX.Graphics.TBitmap object.
        Setting Bitmap at design time brings up the Bitmap Editor, which can be used to specify the file that contains the image you want to display."""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    EnableOpenDialog: bool
    """bool: For future use only."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnLoaded: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TImageControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TImageControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.StdCtrls.TImageControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def LoadFromFile(self, FileName: str) -> None:
        """TImageControl.LoadFromFile(FileName: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ShowOpenDialog(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ImageList(CustomImageList):
    """Wrapper for Delphi TImageList"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Destination: DestinationCollection
    """DestinationCollection:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Source: SourceCollection
    """SourceCollection:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AddOrSet(self) -> Any:
        """TCustomImageList.AddOrSet()
        Adds or replaces several files in the source collection, and adds the item to the destination collection if it does not exist."""
    def BestSize(self) -> Any:
        """TCustomImageList.BestSize()
        Tries to find, in the source collection, the bitmap item specified by name. This method trying to determine the maximum size of layer, which less than input size. If TLayer.MultiResBitmap has multiple images for different scales, then the search is performed among all images."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def BitmapItemByName(self) -> Any:
        """TCustomImageList.BitmapItemByName()
        Tries to find, in the source collection, the bitmap item specified by name."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class IntegerColumn(CustomNumberColumn):
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShowThousandSeparator: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TIntegerColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TIntegerColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def ValidChar(self, KeyChar) -> bool:
        """TIntegerColumn.ValidChar(KeyChar: unicodechr(str)) -> bool
        Returns True if the specified character is a valid character for a cell of this column or False otherwise.
        FMX.Grid.TIntegerColumn.ValidChar inherits from FMX.Grid.TColumn.ValidChar. All content below this line refers to FMX.Grid.TColumn.ValidChar.
        Returns True if the specified character is a valid character for a cell of this column or False otherwise.
        For example, if the column contains numeric values, only digits, sign symbols (+ and -) and digit separators (, and .) would be considered valid."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Label(PresentedTextControl):
    """Represents a graphical control used to display text in FireMonkey forms.
    A TLabel control shows a text. The user cannot edit this text. A TLabel control can be used to label another control and can set focus to this control when the user presses an accelerator key assigned to the TLabel control.
    TLabel controls cannot receive focus.
    The Text property can be used to set an accelerator key to a TLabel control. The FocusControl property keeps the control that receives the focus when the accelerator key is pressed. 
    To add an object to a form that displays text that a user can scroll or edit, use a TEdit."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoSize: bool
    """bool: Specifies whether TLabel control is auto-sized based on the length of the text.
        Set the AutoSize property to True to automatically resize the TLabel control according to the length of the Text.
        Set the AutoSize property to False to lock autoresize of the TLabel control.
        
        Tip:  The size of the TLabel control readjusts when the Font property changes.
        When both AutoSize and WordWrap are set to True, the label's width does not change, and the height increases to show the full Text. So, the text might occupy several lines.
        When AutoSize  is set to True and WordWrap is set to False, the label's width changes to display the text in one line, while the height does not change."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FocusControl: Control
    """Control: Keeps the control that receives the focus when the accelerator key of the current label control is used. 
        Links the label control with another control. 
        If the Text property includes an accelerator key, the control specified by FocusControl receives focus when the accelerator is pressed."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    FontColor: int
    """int: Specifies the font color to use when displaying the text.
        This property sets or returns a value of the TAlphaColor type."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsPressed: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Trimming: TextTrimming
    """TextTrimming: Specifies how the text is trimmed when it exceeds the edges of the text area in this control.
        This property sets or returns a value of the TTextTrimming type."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies the vertical alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TLabel.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TLabel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TLabel.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        Sets a new Scene for the current control.
        FMX.StdCtrls.TLabel.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Layout(Control):
    """A layout is a container for other graphical objects. 
    Use the layouts when you need to organize multiple graphical controls under the same parent.
    For instance, you can use these layouts when you need to create rich FireMonkey applications with many graphical controls that are grouped on the same layer. You can set the visibility of all the controls on a layout at once by affecting the visibility of the layout."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Line(Shape):
    """TLine defines 2D lines. It inherits TControl and can be used in styles to construct controls.
    The end points of the line to draw are defined by the following properties of the TLine object:
    
    The shape rectangle and the LineType define the straight-line segment to draw:
    LineType defines the orientation of the line segment.
    The intersection points of this line segment with the local rectangle define the end points of the straight-line segment.
    RotationCenter defines the rotation axis and RotationAngle defines the rotation angle on which the straight-line segment is rotated to obtain the line to draw.
    Note: Scaling not only scales the line length proportionally to scaling the factors. It also changes the thickness of the stroke that draws the line. That change is proportional to the scaling factor for each axis.
    The parent TControl draws TLine with the Paint method. 
    To draw TLine, the Paint method uses the drawing pen with the Stroke property defined for the TLine object."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    LineLocation: LineLocation
    """LineLocation: Specifes the way a line is drawn.
        The available values are:
        
        Boundary: Default. If you increase the thickness of a Boundary line, the line grows inside and outside of the control symmetrically. The central point of the growth depends on the TLineType. If TLineType is Diagonal, the line goes from the top-left corner to the bottom-right corner. If the thickness of the line is greater than the size of the control, a Boundary line may grow beyond the control.
        Inner: If you increase the thickness of an Inner line, the line grows inside the control. If the thickness of the line is greater than the size of the control, an Inner line may grow beyond the control.
        InnerWithin: If you increase the thickness of an InnerWithin line, the line grows inside the control. The thickness of an InnerWithin line is limited by the size of the control (it never grows beyond the control)."""
    LineType: LineType
    """LineType: Specifies how to place the line inside the shape rectangle.
        The LineType value should be one of the constants defined in the TLineType type: Diagonal, Top, or Left.
        The default is Diagonal.
        The TLineType type defines the following constants:
        
        
        
        Constant
        
        Meaning
        
        
        
        Diagonal
        
        
        
         Draw the line as the diagonal of the shape rectangle.
        
        
        
        
        Top
        
        
        
         Draw the line as the top side (width) of the shape rectangle.
        
        
        
        
        Bottom
        
        
        
         Draw the line as the bottom side (width) of the shape rectangle.
        
        
        
        
        Left
        
        
        
         Draw the line as the left side (height) of the shape rectangle.
        
        
        
        
        Right
        
        
        
         Draw the line as the right side (height) of the shape rectangle."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShortenLine: bool
    """bool: Indicates whether to shorten the line.
        If True, the width of the line is reduced symmetrically by half of the thickness, while the value of Width stays the same."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TLine.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TLine.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Paint(self, *args, **kwargs) -> Any:
        """Renders the control's surface. 
        FMX.Objects.TLine.Paint inherits from FMX.Controls.TControl.Paint. All content below this line refers to FMX.Controls.TControl.Paint.
        Renders the control's surface. 
        The Paint method is called by DoPaint when a control is being painted by the PaintTo method. Before DoPaint, Painting is called. AfterPaint is called immediately after. 
        FireMonkey internally calls Paint to paint the control when the window is being painted. You must not call Paint explicitly.
        The base class TControl implements an empty Paint. The descendants of TControl override Paint to provide specific rendering of the respective controls.
        For example, Paint methods in classes of the FMX.Objects unit draw and fill shapes using the properties defined in these classes. See the descriptions of these classes to find the properties of the respective shapes."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlDelegate(BindComponentDelegate):
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanSetControlComponent(self, Value: Component) -> bool:
        """TLinkControlDelegate.CanSetControlComponent(Value: Component) -> bool
        Returns whether the given parameter can be used as the control component of this binding component.
        CanSetControlComponent returns whether the given Value (that is itself a TComponent) can be used as the control component of this binding component."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlToField(CustomLinkControlToField):
    """Wrapper for Delphi TLinkControlToField"""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Track: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlToFieldDelegate(LinkControlDelegate):
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkListControlToField(CustomLinkListControlToField):
    """Wrapper for Delphi TLinkListControlToField"""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    FillBreakCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional."""
    FillBreakFieldName: str
    """str: Specifies the field used to determine a break. This property is optional."""
    FillBreakGroups: FillBreakGroups
    """FillBreakGroups: Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional."""
    FillExpressions: FormatExpressions
    """FormatExpressions: Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
        For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property."""
    FillHeaderCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional."""
    FillHeaderExpressions: FormatExpressions
    """FormatExpressions: Specifies a collection of expressions to fill a list header. This property is optional."""
    FillHeaderFieldName: str
    """str: Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking."""
    ListItemStyle: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    OnFilledList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFilledListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    OnFillingList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFillingListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkPropertyToField(CustomLinkPropertyToField):
    """Wrapper for Delphi TLinkPropertyToField"""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool:"""
    Component: Component
    """Component: Specifies the component that this wrapping binding component references."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentProperty: str
    """str: Specifies the name of the property of the component that this wrapping binding component references."""
    Components: Any
    """Returns an iterator over the owned components"""
    CustomFormat: str
    """str:"""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TDataSource object to which this delegate component links.
        Use DataSource to determine or set the TDataSource object that connects to a specific dataset."""
    FieldName: str
    """str: Specifies the field name that this wrapping binding component references."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource:"""
    LookupKeyFieldName: str
    """str:"""
    LookupValueFieldName: str
    """str:"""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkPropertyToFieldDelegate(BindComponentDelegate):
    __hash__: ClassVar[None] = ...
    Component: Component
    """Component: Specifies the component that this wrapping binding component references."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentProperty: str
    """str: Specifies the name of the property of the component that this wrapping binding component references."""
    Components: Any
    """Returns an iterator over the owned components"""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TDataSource object to which this delegate component links.
        Use DataSource to determine or set the TDataSource object that connects to a specific dataset."""
    FieldName: str
    """str: Specifies the field name that this wrapping binding component references."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListBox(CustomListBox):
    """Wrapper for Delphi TListBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AllowDrag: bool
    """bool: Allows the dragging of items inside the list.
        AllowDrag allows you to change the order of the list items by dragging them."""
    AlternatingRowBackground: bool
    """bool: Specifies whether consecutive items should have different backgrounds.
        Set AlternatingRowBackground to True so that the background of items alternates."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Columns: int
    """int: Specifies the number of columns on which to display the items in the list box.
        If Columns is set to 3, this is how the list box will display the items:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultItemStyles: ListBoxItemStyleDefaults
    """ListBoxItemStyleDefaults: Embarcadero Technologies does not currently have any additional information."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    GroupingKind: ListGroupingKind
    """ListGroupingKind: Embarcadero Technologies does not currently have any additional information."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    ItemHeight: float
    """float: Specifies the height of the items from the list box.
        Use ItemHeight to specify the height, in pixels, of the items in the list box."""
    ItemIndex: int
    """int: Specifies the index of the currently selected item.
        Gets or sets the index of the item that is selected in the list box.
        The first item in the list has index 0, the second item has index 1, and so on. If no item is selected, the value of ItemIndex is -1.
        To get the actual item that is selected, use the Selected property."""
    ItemWidth: float
    """float: Specifies the width of the items in the list box.
        The default value is 0. If you set another value for ItemWidth, all the items will be re-dimensioned to that value and displayed on multiple columns."""
    Items: Strings
    """Strings: Specifies the items in the list box.
        Use Items to get or set the list of items in the list box as strings.
        Use the ListItems property to access an item by specifying its index. This property returns the item as a TListBoxItem object.
        
        Adding Items
        To add items as TListBoxItem at design-time, see ListBox Items Editor.
        To add items as TStrings at design-time, see String List editor."""
    ListStyle: ListStyle
    """ListStyle: Specifies how the items are displayed in the list box.
        ListStyle specifies whether the items in the list box are displayed vertically or horizontally.
        ListStyle can be set to Vertical or Horizontal."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MultiSelectStyle: MultiSelectStyle
    """MultiSelectStyle: Embarcadero Technologies does not currently have any additional information."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeCheck: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCompare: Callable[[ListBoxItem,ListBoxItem,int],None]
    """Callable[[ListBoxItem, ListBoxItem, int], None]:"""
    OnDragChange: Callable[[ListBoxItem,ListBoxItem,bool],None]
    """Callable[[ListBoxItem, ListBoxItem, bool], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnItemClick: Callable[[CustomListBox,ListBoxItem],None]
    """Callable[[CustomListBox, ListBoxItem], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowCheckboxes: bool
    """bool: Displays a check box next to every item in the list box."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Sorted: bool
    """bool: Specifies whether the list of items is sorted."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListBoxItem(TextControl):
    """A TListBoxItem is an item that is used in list box components.
    The items in list boxes and combo boxes are of type TListBoxItem. To add an item to a list box or combo box, double-click the component or right-click the component and choose Add Item."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Data: Object
    """Object: Stores a Tvalue, which is a data structure that can store different kinds of data types.
        FMX.ListBox.TListBoxItem.Data inherits from FMX.Types.TFmxObject.Data. All content below this line refers to FMX.Types.TFmxObject.Data.
        Stores a Tvalue, which is a data structure that can store different kinds of data types.
        Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.
        
        Note: Do not use this member. It is for internal use only."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsChecked: bool
    """bool: Specifies whether the check box associated with the item is checked."""
    IsSelected: bool
    """bool: Specifies whether the item is selected.
        If IsSelected is True, the item appears as selected inside its parent component."""
    ItemData: ListBoxItemData
    """ListBoxItemData: Specifies various data that can be attached to a TListBoxItem in order to be shown in the list box.
        Use the ItemData property in order to attach various data to a list box item. This data can then be displayed in the list box.
        
        ItemData has four sub-properties:
        
        Accessory - lets you add to the selected list box item one of the following items:
        Checkmark icon 
        Detail icon 
        More icon 
        No icon (this is the default)
        Bitmap - lets you add a bitmap image to your item.
        Detail - lets you add an additional text that describes your list box item.
        Text - allows you to change the text displayed on your list box item.
        
        In the picture above, two list box items are present in the list:
        
        The first one has a bitmap image, additional text description and no accessory icon.
        The second one has a bitmap image, additional text description and the Detail accessory icon."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Selectable: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    '''str: Specifies the text that will be rendered over the surface of this TTextControl object.
        Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
        If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters.
        
        Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
        Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be "any string", but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.'''
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
        Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
        Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether the text inside the TTextControl object wraps when it is longer than the width of the control.
        Set WordWrap to True to allow the TTextControl control to display multiple lines of text. When WordWrap is True, text that is too long for the TTextControl object wraps at the right margin and continues in additional lines.
        Set WordWrap to False for the text to span onto a single line of the TTextControl. However, in this case, the text that is too long for TTextControl appears truncated.
        The default value for the WordWrap property is False."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def ApplyTriggerEffect(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TListBoxItem.ApplyTriggerEffect(AInstance: FmxObject, ATrigger: str) -> None
        Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
        FMX.ListBox.TListBoxItem.ApplyTriggerEffect inherits from FMX.Controls.TControl.ApplyTriggerEffect. All content below this line refers to FMX.Controls.TControl.ApplyTriggerEffect.
        Applies the specified mouse trigger effect to all the children of this FMX object that are of type TEffect.
        ApplyTriggerEffect iterates through all the children of this FMX object and, if one of them is of type TEffect, applies the mouse trigger given through the ATrigger parameter (which can be 'IsMouseOver', 'IsMouseOver', 'IsDragOver', and so on).
        AInstance specifies the instance of the FMX object to which the trigger effect is applied."""
    def Create(self, AOwner: Component) -> None:
        """TListBoxItem.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.ListBox.TListBoxItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.ListBox.TListBoxItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetParentComponent(self, *args, **kwargs) -> Any:
        """Returns the containing component.
        Returns the containing component.
        FMX.ListBox.TListBoxItem.GetParentComponent inherits from System.Classes.TComponent.GetParentComponent. All content below this line refers to System.Classes.TComponent.GetParentComponent.
        Returns the containing component.
        GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
        For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetIsSelectedInternal(self, Value: bool, UserChange: bool) -> None:
        """TListBoxItem.SetIsSelectedInternal(Value: bool, UserChange: bool) -> None
        Processes the selection of an item.
        Sets the value of the IsSelected property, triggers the selection animation and calls the ItemStateChanged method of the listbox selection controller.
        The UserChange specifies whether the selection is initiated by an user action (as opposed to by a code call)."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListView(CustomListView):
    """Represents a FireMonkey list view component that you can use to hold and present various types of items.
    The TListView displays a collection of items in a list that is optimized for LiveBindings and for fast and smooth scrolling. 
    The items in the list view can have one or more of the following appearance features:
    
    A caption or detail text (for example, using the Item.Text bindable member of TListView)
    An associated image (for example, using the Item.Bitmap bindable member of TListView)
    An accessory icon (for example, using the ItemEditAppearance property in the Object Inspector)
    A graphic or a text button attached (for example, using the Item.ButtonText bindable member of TListView)
    You can customize the appearance of a list view by modifying the layout of the list items, including the caption, the associated image, text details, or the accessory icon.
    TListView has the edit mode in which  you can select several items.
    
    Example
    You can add items to a TListView either by binding to a data source, or by code (TListView.Items.Add).  
    Here is a code example that shows how to add items to a TListView:
    
    
    Delphi:
    
    var
      LItem: TListViewItem;
      I: Integer;
    begin
      for I := 1 to 10 do
      begin
        LItem := ListView1.Items.Add;
        LItem.Text := IntToStr(I); 
     end;
    end;
    
    // To achieve the best performance use BeginUpdate and EndUpdate.
    
    var
      LItem: TListViewItem;
      I: Integer;
    begin
      ListView1.BeginUpdate;
      try
        for I := 1 to 10 do
        begin
          LItem := ListView1.Items.Add;
          LItem.Text := IntToStr(I);
        end;
      finally
        ListView1.EndUpdate;
      end;
    end;
    
    
    
    C++:
    
    for (int i = 1; i <= 10; i++) {
      TListViewItem* item = ListView1->Items->Add();
      item->Text = IntToStr(i);
    }
    
    // To achieve the best performance use BeginUpdate and EndUpdate.
    
    ListView1->BeginUpdate();
    try {
      for (int i = 1; i <= 10; i++) {
        TListViewItem* item = ListView1->Items->Add();
        item->Text = IntToStr(i);
      }
    } catch (...) {
    }
    ListView1->EndUpdate();"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AllowSelection: bool
    """bool: Specifies whether the items are selectable or not.
        The AllowSelection property specifies whether the items are selectable or not.
        
        Tip: If items are not selectable, you will still be able to click on the embedded controls."""
    AlternatingColors: bool
    """bool: Specifies whether the fill colors for odd and even elements are rendered as alternating or not.
        The AlternatingColors property specifies whether the background of the individual items in the list should appear rendered in alternating colors."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTapScroll: bool
    """bool: Specifies whether tapping on the topmost side of this list view automatically scrolls to the top of the list.
        Set the AutoTapScroll property to True in order to allow for automatically scrolling to the top of the list when tapping with your finger on the topmost region of this list view component. Set AutoTapScroll to False in order to disable this feature."""
    AutoTapTreshold: int
    """int: Specifies the threshold value for the auto tap scrolling."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    CanSwipeDelete: bool
    """bool: Sets the swipe-to-delete feature on list view items.
        CanSwipeDelete specifies that a swipe gesture on individual list view items enables the end user to choose either to delete or retain the item.
        When this feature has been enabled in the Object Inspector, and the end user swipes an item in a listview, the user has the opportunity to delete the item: a Delete button temporarily appears on the item.  The user can then click the Delete button to delete the item from the listview, or can release the swipe to retain the item in the list view.
        
        Tip: When you swipe an item, this item shows the same behavior and appearance as a list item selected when your list view is in edit mode. For  a preview of this appearance, see TPublishedAppearance.ItemEditAppearance.
        The swipe-to-delete feature is supported on mobile apps (iOS and Android), as well as desktop apps (Windows and OS X) when touch input is available."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType: Describes if the Control type is Styled or Native."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DeleteButtonText: str
    """str: Specifies the name of the Delete button designed to delete the TListView items. 
        This button can be displayed if the CanSwipeDelete property is set True."""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DisableMouseWheel: bool
    """bool: Specifies whether scrolling this list view using the mouse wheel works or not.
        Set the DisableMouseWheel property to False to allow scrolling this list view using the mouse wheel. Set DisableMouseWheel to True to disable this feature."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EditMode: bool
    """bool: Specifies whether this list view component is in the edit mode (True) or in the regular mode (False).
        On some platforms, the list view shows an animation when the value of the EditMode property changes at run time."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FooterAppearanceClassName: str
    """str: Name of the appearance class of footer list view items."""
    FooterAppearanceName: str
    """str: Name of the appearance of footer list view items.
        Possible values are:
        
        
        
        Item
        
        Description
        
        
        Custom
        
        Custom appearance.
        
        
        ListHeader
        
        Default appearance."""
    HeaderAppearanceClassName: str
    """str: Name of the appearance class of header list view items."""
    HeaderAppearanceName: str
    """str: Name of the appearance of header list view items.
        Possible values are:
        
        
        
        Item
        
        Description
        
        
        Custom
        
        Custom appearance.
        
        
        ListHeader
        
        Default appearance."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    ItemAppearance: PublishedAppearance
    """PublishedAppearance: Specifies the various options that are used when rendering the list view items.
        
        Note: This is a design-time property. At run time access the relevant properties of the list view instead. See TPublishedAppearance for more information.
        Use the ItemAppearance property in order to control how an item from this list view component is displayed. The ItemAppearance property controls the footer, header, and list item appearance and height, and also the list item appearance and height when in edit mode."""
    ItemAppearanceClassName: str
    """str: Name of the appearance class of regular list view items."""
    ItemAppearanceName: str
    """str: Name of the appearance of regular list view items.
        When your list view switches between display mode and edit mode, the item appearance switches between the appearance defined in the ItemAppearanceName property (display mode) and the appearance defined in the ItemEditAppearanceName property (edit mode). Items may display an animation as their appearance changes.
        Possible values are:
        
        
        
        ItemAppearanceName
        
        ItemEditAppearanceName
        
        List Item Preview
        
        
        Not Selected
        
        Selected
        
        
        Custom
        
        Custom
        
        
        
        
        
        
        ImageListItem
        
        ImageListItemDeleteImageListItemShowCheck
        
        
        
        
        
        
        ImageListItemBottomDetail
        
        ImageListItemBottomDetailShowCheck
        
        
        
        
        
        
        ImageListItemBottomDetailRightButton
        
        ImageListItemBottomDetailRightButtonShowCheck
        
        
        
        
        
        
        ImageListItemRightButton
        
        ImageListItemRightButtonDeleteImageListItemRightButtonShowCheck
        
        
        
        
        
        
        ListItem
        
        ListItemDeleteListItemShowCheck
        
        
        
        
        
        
        ListItemRightDetail
        
        ListItemRightDetailDeleteListItemRightDetailShowCheck"""
    ItemAppearanceObjects: PublishedObjects
    """PublishedObjects: Allows you to specify properties of individual item appearance objects. These objects include footer, header, item, and item in edit mode objects.
        Use the ItemAppearanceObjects property in order to control various properties of the objects that might be part of this list view component. For instance, you can specify accessory and text settings for the items or you can affect text settings for the footer and header items."""
    ItemEditAppearanceClassName: str
    """str: Name of the appearance class of regular list view items in edit mode."""
    ItemEditAppearanceName: str
    """str: Name of the appearance of regular list view items in edit mode.
        When your list view switches between display mode and edit mode, the item appearance switches between the appearance defined in the ItemAppearanceName property (display mode) and the appearance defined in the ItemEditAppearanceName property (edit mode). Items may display an animation as their appearance changes.
        You can find the possible values in the table below.
        
        
        
        ItemEditAppearance
        
        ItemAppearanceName
        
        Editing Mode
        
        List Item Preview
        
        
        Not Selected
        
        Selected
        
        
        Custom
        
        Custom
        
        Custom
        
        
        
        
        
        
        ImageListItemBottomDetailShowCheck
        
        ImageListItemBottomDetail
        
        Select
        
        
        
        
        
        
        ImageListItemBottomDetailRightButtonShowCheck
        
        ImageListItemBottomDetailRightButton
        
        Select
        
        
        
        
        
        
        ImageListItemDelete
        
        ImageListItem
        
        Delete
        
        
        
        
        
        
        ImageListItemRightButtonDelete
        
        ImageListItemRightButton
        
        Delete
        
        
        
        
        
        
        ImageListItemRightButtonShowCheck
        
        ImageListItemRightButton
        
        Select
        
        
        
        
        
        
        ImageListItemShowCheck
        
        ImageListItem
        
        Select
        
        
        
        
        
        
        ListItemDelete
        
        ListItem
        
        Delete
        
        
        
        
        
        
        ListItemRightDetailDelete
        
        ListItemRightDetail
        
        Delete
        
        
        
        
        
        
        ListItemRightDetailShowCheck
        
        ListItemRightDetail
        
        Select
        
        
        
        
        
        
        ListItemShowCheck
        
        ListItem
        
        Select
        
        
        
        
        
        Each edit mode item appearance matches a display mode item appearance (ItemAppearanceName). The type of editing mode described in the table above determines how list items behave.
        
        
        
        Item
        
        Behavior
        
        
        Delete
        
        Tap a list item to show a Delete button. Tap Delete to delete the item, tap anywhere else to hide the Delete button.
        
        
        Select
        
        Tap a list item to select it. Tap again to unselect it. You can select more than one item (multiselect).
        
        
        Custom
        
        Your custom implementation of the edit mode item appearance determines the behavior of list items."""
    ItemIndex: int
    """int: Specifies the index of the selected item in this list view component."""
    ItemSpaces: Bounds
    """Bounds: Specifies the space in logical units around the content of each list item."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    NativeOptions: ListViewNativeOptions
    """ListViewNativeOptions: Set of properties to customize the appearance and behavior of the list view when ControlType is Platform.
        This group of properties provides the subproperties described in the following table. All subproperties are disabled by default.
        
        
        
        Subproperty
        
        Description
        
        
        
        Grouped
        
        
        
        Make cells use a grouped style. The grouped style is the style that the list of iOS settings uses.
        
        
        
        False
        
        True
        
        
        
        
        
        
        
        
        
        Indexed
        
        
        
        Shows an index on the right-hand side of the list with the first letter of each header. You may tap a letter to navigate to the header that the letter represents.
        If you want to display something other than the first letter of each header, use the IndexTitle of each header item to define a custom text to show for that header. Long index titles may hide important information behind them, use no more than few characters.
        
        
        
        False
        
        True
        
        
        
        
        
        
        
        
        
        Styled
        
        
        
        Make the native presentation use the style settings defined in your list view control for the following aspects of your list view:
        
        Font
        Text color and selected text color
        Text alignment, both vertical and horizontal
        Word wrapping and trimming
        You cannot customize any other aspects of the native presentation of a list view. If you need to customize your list view further, change ControlType to Styled to use the regular FireMonkey presentation instead.
        
        
        
        False
        
        True
        
        ControlType: Styled"""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnButtonChange: Callable[[Object,ListItem,ListItemSimpleControl],None]
    """Callable[[Object, ListItem, ListItemSimpleControl], None]:"""
    OnButtonClick: Callable[[Object,ListItem,ListItemSimpleControl],None]
    """Callable[[Object, ListItem, ListItemSimpleControl], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeRepainted: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeleteChangeVisible: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnDeleteItem: Callable[[Object,int],None]
    """Callable[[Object, int], None]:"""
    OnDeletingItem: Callable[[Object,int,bool],None]
    """Callable[[Object, int, bool], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEditModeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEditModeChanging: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFilter: Callable[[Object,str,str,bool],None]
    """Callable[[Object, str, str, bool], None]:"""
    OnItemClick: Callable[[Object,ListViewItem],None]
    """Callable[[Object, ListViewItem], None]:"""
    OnItemClickEx: Callable[[Object,int,PointF,ListItemDrawable],None]
    """Callable[[Object, int, PointF, ListItemDrawable], None]:"""
    OnItemsChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPullRefresh: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnScrollViewChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSearchChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdateObjects: Callable[[Object,ListViewItem],None]
    """Callable[[Object, ListViewItem], None]:"""
    OnUpdatingObjects: Callable[[Object,ListViewItem,bool],None]
    """Callable[[Object, ListViewItem, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    PullRefreshWait: bool
    """bool: Determines if the spinning wheel disappears automatically or not.
        When set to True, the spinning wheel does not disappear automatically and you have to call the StopPullRefresh method after doing a refresh operation. If PullRefreshWait is set to False (default), then the spinning wheel disappears automatically shortly after triggering the effect. This option only works in native iOS controls and does not have effect otherwise.
        
        Note: You must set the PullToRefresh property to True to use PullRefreshWait."""
    PullToRefresh: bool
    '''bool: Determines whether the "pull list to refresh" feature is enabled.
        When this property is set to true, the Pull-to-Refresh feature is enabled and the end user can pull down a list view to refresh the contents.
        To enable the Pull-to-Refresh feature, select the TListView component in the Form Designer, and do the following:
        
        On the Properties page of the Object Inspector, set the PullToRefresh property to true.
        Open the Events page, and double-click the right-hand column for OnPullRefresh.
        When the Code Editor opens, you can implement the OnPullRefresh event handler. In this event handler, you can specify how to refresh the list view. For example, you might update existing list items, add new items, or delete specified items.
        Note: In the case of native iOS controls, you can use the PullRefreshWait property to set whether the animated spinning indicator disappears automatically, or if it disappears when you call StopPullRefresh.'''
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollViewPos: float
    """float: Specifies the position of the vertical scroll in the list. Setting ScrollViewPos to 0 scrolls the list view to its top."""
    SearchAlwaysOnTop: bool
    """bool: Search box partially hidden in a list view where SearchAlwaysOnTop is False
        Your list view component keeps the search box on top as you scroll. If SearchAlwaysOnTop is False, the search box behaves as a list item: scrolling down the list hides the search box, and you must scroll up to show the search box again.
        SearchAlwaysOnTop has no effect if SearchVisible is False.
        SearchAlwaysOnTop is supported only on the iOS platform."""
    SearchVisible: bool
    """bool: Set SearchVisible to True to show a search box on top of your list view
        Shows a search box on top of your list view that can filter the content of the list.
        To access the search box control from code, simply loop trough the controls of your list view until you find an instance of TSearchBox. For an example, see the code snippet at FMX.ListView.TListViewBase.OnSearchChange."""
    SelectionCrossfade: bool
    """bool: Enables the selection of Crossfade animation ."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowSelection: bool
    """bool: Determines whether the selection is visible when selecting list view items. The ShowSelection property can be disabled when the list view has check boxes."""
    SideSpace: int
    """int: Specifies the space in logical units on all sides around the list box, encompassing the items."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Transparent: bool
    """bool: Specifies whether this list view control is transparent or not. When the control is transparent (Transparent is set to True), its background will not be drawn."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListViewBase(AdapterListView):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AllowSelection: bool
    """bool: Specifies whether the items are selectable or not.
        The AllowSelection property specifies whether the items are selectable or not.
        
        Tip: If items are not selectable, you will still be able to click on the embedded controls."""
    AlternatingColors: bool
    """bool: Specifies whether the fill colors for odd and even elements are rendered as alternating or not.
        The AlternatingColors property specifies whether the background of the individual items in the list should appear rendered in alternating colors."""
    AutoTapScroll: bool
    """bool: Specifies whether tapping on the topmost side of this list view automatically scrolls to the top of the list.
        Set the AutoTapScroll property to True in order to allow for automatically scrolling to the top of the list when tapping with your finger on the topmost region of this list view component. Set AutoTapScroll to False in order to disable this feature."""
    AutoTapTreshold: int
    """int: Specifies the threshold value for the auto tap scrolling."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanSwipeDelete: bool
    """bool: Sets the swipe-to-delete feature on list view items.
        CanSwipeDelete specifies that a swipe gesture on individual list view items enables the end user to choose either to delete or retain the item.
        When this feature has been enabled in the Object Inspector, and the end user swipes an item in a listview, the user has the opportunity to delete the item: a Delete button temporarily appears on the item.  The user can then click the Delete button to delete the item from the listview, or can release the swipe to retain the item in the list view.
        
        Tip: When you swipe an item, this item shows the same behavior and appearance as a list item selected when your list view is in edit mode. For  a preview of this appearance, see TPublishedAppearance.ItemEditAppearance.
        The swipe-to-delete feature is supported on mobile apps (iOS and Android), as well as desktop apps (Windows and OS X) when touch input is available."""
    ControlType: ControlType
    """ControlType: Describes if the Control type is Styled or Native."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DeleteButtonText: str
    """str: Specifies the name of the Delete button designed to delete the TListView items. 
        This button can be displayed if the CanSwipeDelete property is set True."""
    DisableMouseWheel: bool
    """bool: Specifies whether scrolling this list view using the mouse wheel works or not.
        Set the DisableMouseWheel property to False to allow scrolling this list view using the mouse wheel. Set DisableMouseWheel to True to disable this feature."""
    EditMode: bool
    """bool: Specifies whether this list view component is in the edit mode (True) or in the regular mode (False).
        On some platforms, the list view shows an animation when the value of the EditMode property changes at run time."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    ItemCount: int
    """int: Specifies the number of items in this list view component. ItemCount is a read-only property.
        Read the ItemCount property in order to obtain the number of list items in this list view component."""
    ItemIndex: int
    """int: Specifies the index of the selected item in this list view component."""
    ItemSpaces: Bounds
    """Bounds: Specifies the space in logical units around the content of each list item."""
    NativeOptions: ListViewNativeOptions
    """ListViewNativeOptions: Set of properties to customize the appearance and behavior of the list view when ControlType is Platform.
        This group of properties provides the subproperties described in the following table. All subproperties are disabled by default.
        
        
        
        Subproperty
        
        Description
        
        
        
        Grouped
        
        
        
        Make cells use a grouped style. The grouped style is the style that the list of iOS settings uses.
        
        
        
        False
        
        True
        
        
        
        
        
        
        
        
        
        Indexed
        
        
        
        Shows an index on the right-hand side of the list with the first letter of each header. You may tap a letter to navigate to the header that the letter represents.
        If you want to display something other than the first letter of each header, use the IndexTitle of each header item to define a custom text to show for that header. Long index titles may hide important information behind them, use no more than few characters.
        
        
        
        False
        
        True
        
        
        
        
        
        
        
        
        
        Styled
        
        
        
        Make the native presentation use the style settings defined in your list view control for the following aspects of your list view:
        
        Font
        Text color and selected text color
        Text alignment, both vertical and horizontal
        Word wrapping and trimming
        You cannot customize any other aspects of the native presentation of a list view. If you need to customize your list view further, change ControlType to Styled to use the regular FireMonkey presentation instead.
        
        
        
        False
        
        True
        
        ControlType: Styled"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeRepainted: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeleteChangeVisible: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnDeleteItem: Callable[[Object,int],None]
    """Callable[[Object, int], None]:"""
    OnDeletingItem: Callable[[Object,int,bool],None]
    """Callable[[Object, int, bool], None]:"""
    OnFilter: Callable[[Object,str,str,bool],None]
    """Callable[[Object, str, str, bool], None]:"""
    OnItemChange: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnItemClickEx: Callable[[Object,int,PointF,ListItemDrawable],None]
    """Callable[[Object, int, PointF, ListItemDrawable], None]:"""
    OnItemsChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnListItemClick: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnPullRefresh: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnScrollViewChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSearchChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    PullRefreshWait: bool
    """bool: Determines if the spinning wheel disappears automatically or not.
        When set to True, the spinning wheel does not disappear automatically and you have to call the StopPullRefresh method after doing a refresh operation. If PullRefreshWait is set to False (default), then the spinning wheel disappears automatically shortly after triggering the effect. This option only works in native iOS controls and does not have effect otherwise.
        
        Note: You must set the PullToRefresh property to True to use PullRefreshWait."""
    PullToRefresh: bool
    '''bool: Determines whether the "pull list to refresh" feature is enabled.
        When this property is set to true, the Pull-to-Refresh feature is enabled and the end user can pull down a list view to refresh the contents.
        To enable the Pull-to-Refresh feature, select the TListView component in the Form Designer, and do the following:
        
        On the Properties page of the Object Inspector, set the PullToRefresh property to true.
        Open the Events page, and double-click the right-hand column for OnPullRefresh.
        When the Code Editor opens, you can implement the OnPullRefresh event handler. In this event handler, you can specify how to refresh the list view. For example, you might update existing list items, add new items, or delete specified items.
        Note: In the case of native iOS controls, you can use the PullRefreshWait property to set whether the animated spinning indicator disappears automatically, or if it disappears when you call StopPullRefresh.'''
    ScrollViewPos: float
    """float: Specifies the position of the vertical scroll in the list. Setting ScrollViewPos to 0 scrolls the list view to its top."""
    SearchAlwaysOnTop: bool
    """bool: Search box partially hidden in a list view where SearchAlwaysOnTop is False
        Your list view component keeps the search box on top as you scroll. If SearchAlwaysOnTop is False, the search box behaves as a list item: scrolling down the list hides the search box, and you must scroll up to show the search box again.
        SearchAlwaysOnTop has no effect if SearchVisible is False.
        SearchAlwaysOnTop is supported only on the iOS platform."""
    SearchVisible: bool
    """bool: Set SearchVisible to True to show a search box on top of your list view
        Shows a search box on top of your list view that can filter the content of the list.
        To access the search box control from code, simply loop trough the controls of your list view until you find an instance of TSearchBox. For an example, see the code snippet at FMX.ListView.TListViewBase.OnSearchChange."""
    Selected: ListItem
    """ListItem: List item that is currently selected on the list view.
        This property is nil if no item is selected.
        To use Selected as an instance of Appearances.TListViewItem, you must cast it as such:
        
        
        Delphi:
        
        SelectedItemText := TListViewItem(TListView1.Selected).Text;
        
        
        
        C++:
        
        SelectedItemText = ((TListViewItem*)(TListView1->Selected))->Text;"""
    SelectionCrossfade: bool
    """bool: Enables the selection of Crossfade animation ."""
    ShowSelection: bool
    """bool: Determines whether the selection is visible when selecting list view items. The ShowSelection property can be disabled when the list view has check boxes."""
    SideSpace: int
    """int: Specifies the space in logical units on all sides around the list box, encompassing the items."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    Transparent: bool
    """bool: Specifies whether this list view control is transparent or not. When the control is transparent (Transparent is set to True), its background will not be drawn."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TListViewBase.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.ListView.TListViewBase.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.ListView.TListViewBase.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Marks the end of an update session of the control and its children.
        FMX.ListView.TListViewBase.EndUpdate inherits from FMX.Controls.TControl.EndUpdate. All content below this line refers to FMX.Controls.TControl.EndUpdate.
        Marks the end of an update session of the control and its children.
        The update session must be started first by calling BeginUpdate.
        EndUpdate decreases the FUpdating semaphore. If all update sessions end and FUpdating is 0, EndUpdate invokes Realign to process layout changes.
        
         See Also
        FMX.Controls.TControl.FUpdating
        FMX.Controls.TControl.BeginUpdate
        FMX.Controls.TControl.IsUpdating
        FMX.Controls.TControl.Realign"""
    @classmethod
    def GetDefaultMargins(cls, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetItemRect(self, AItemIndex: int) -> RectF:
        """TListViewBase.GetItemRect(AItemIndex: int) -> RectF
        Returns a TRectF that surrounds the specified item.
        The GetItemRect method returns a rectangle with floating-point coordinates (TRectF) that surrounds the item specified through its index (the AItemIndex parameter)."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def RebuildList(self, *args, **kwargs) -> Any:
        """Re-creates the list and updates visible item content when using native presentation."""
    def ScrollTo(self, AItemIndex: int) -> None:
        """TListViewBase.ScrollTo(AItemIndex: int) -> None
        Scrolls the view instantly (without scrolling effect) to the desired item, placing it in the view.
        Use the ScrollTo method in order to immediately scroll, without a slow scrolling graphical effect, to the item specified through its index (the AItemIndex parameter), and place it in the view."""
    def StopPullRefresh(self, *args, **kwargs) -> Any:
        '''StopPullRefresh is a boolean method. It should be called when the "pull to refresh" mode has been triggered to stop the spinning wheel.
        StopPullRefresh can be set to
        
        True, as result the spinning wheel does not disappear automatically and StopPullRefresh method needs to be called after the refresh operation is done.
        False (default value), as result the spinning wheel disappears automatically shortly after triggering the effect.
        Note: This works only in native IOS control and only when the  PullRefreshWait property is set to True.'''
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MainMenu(FmxObject):
    """Describes the structure of the form's main menu.
    Use TMainMenu to describe the structure of the form's main menu. TMainMenu is composed of TMenuItems. 
    Menu items can be added in several ways:
    
    To add a menu item at design time, do any of the following:
    Right-click the component and select Add Item from the context menu.
    Double-click the component and click the Add Item button on the Items Designer.
    Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
    To add a menu item at run time, use the AddObject procedure of the TMainMenu."""
    __hash__: ClassVar[None] = ...
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Items: FmxObject
    """FmxObject:"""
    ItemsCount: int
    """int: Represents the number of child menu items of this menu."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        FMX.Menus.TMainMenu.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def Create(self, AOwner: Component) -> None:
        """TMainMenu.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Menus.TMainMenu.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Menus.TMainMenu.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DialogKey(self, Key: int, Shift: ShiftState) -> None:
        """TMainMenu.DialogKey(Key: int, Shift: ShiftState) -> None
        Processes a dialog key for every item in the menu.
        Do not call DialogKey in an application. It is for internal use only."""
    def Exchange(self, AObject1: FmxObject, AObject2: FmxObject) -> None:
        """TMainMenu.Exchange(AObject1: FmxObject, AObject2: FmxObject) -> None
        Exchanges two objects from the children list.
        FMX.Menus.TMainMenu.Exchange inherits from FMX.Types.TFmxObject.Exchange. All content below this line refers to FMX.Types.TFmxObject.Exchange.
        Exchanges two objects from the children list. Exchange exchanges AObject1 with AObject2."""
    def RecreateOSMenu(self, *args, **kwargs) -> Any:
        """Recreates the OS specific menu."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Media(Object):
    """Base class to access media files.
    TMedia is an abstract class that defines an interface for media files. Platform-specific subclasses provide concrete implementations for Windows and OS X platforms.
    TMedia exposes media file properties such as file name, size, dimension, state, or duration. 
    The supported media files formats are the native formats for each platform:
    
    For Windows:
    Audio formats: .wma, .mp3, .wav
    Video formats: .avi, .wmv
    For OS X:
    Audio formats: .mp3
    Video formats: .mov, .m4v, .mp4
    Using TMediaCodecManager, it is possible to register custom media codecs to extend the audio/video feature support.
    For easy access to media files, use the TMediaPlayer and TMediaPlayerControl components."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Control: MediaPlayerControl
    """MediaPlayerControl: Specifies the media player control that plays the current media file.
        Set Control to specify the media player control that plays the current media file.
        
        Tip: For easy access to media files and easy playing, use the TMediaPlayer or TMediaPlayerControl visual components. Giving the name of the file to be played will automatically create the TMedia objects and set the Control to the current used media player control."""
    CurrentTime: int
    """int: Specifies the current playback position.
        CurrentTime is measured in 100ns. To obtain s, divide Duration by MediaTimeScale.
        Set CurrentTime to control the current position to be played."""
    Duration: int
    """int: Specifies the total play time of the current media file.
        Duration is measured in 100ns. To obtain s, divide Duration by MediaTimeScale."""
    FileName: str
    """str: Specifies the name of the current used media file.
        FileName specifies the name of the media file used to create the current TMedia object. FileName includes the path, name, and extension of the media file."""
    State: MediaState
    """MediaState: Specifies whether the current media file is playing or is stopped.
        If the current media file is not assigned or supported, then State is set to Unavailable.
        If the current media file is playing, then State is set to Playing, otherwise it is set to Stopped."""
    VideoSize: PointF
    """PointF: Specifies the resolution of the current video file.
        VideoSize specifies the native width and height of the current media file, in pixels. 
        VideoSize is a TPointF. The X coordinate of the point represents the width of the window, and the Y coordinate of the point represents the height of the window. If the media file is audio only and does not have a window to be displayed, VideoSize is (0,0)."""
    Volume: float
    """float: Specifies the audio volume of the current media file.
        Volume takes values in the range from 0 through 1. If Volume is 1, then the media file is played at the maximum native volume. If Volume is 0, then the media file is mute."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AFileName: str) -> None:
        """TMedia.Create(AFileName: str) -> None
        Constructs an object and initializes its data before the object is first used.
        FMX.Media.TMedia.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Play(self, *args, **kwargs) -> Any:
        """Starts the playback of the current media file.
        Call the Play method to playback the current media file. To pause or stop the current media file from playing, call the Stop method."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def Stop(self, *args, **kwargs) -> Any:
        """Stops the playback of the current media file.
        Call the Stop method to stop or to pause the current played media file. To play the current media file, call the Play method."""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayer(FmxObject):
    """Nonvisual component for media file playback.
    Use a TMediaPlayer component for easy access to media files. 
    The currently accessed media file is specified through the Media property.
    To specify the media file to be played by the current TMediaPlayer, set the FileName property. The file name must include the path of the file, so it can be localized on the memory, and the extension. 
    Call the Play and Stop methods to start playing a media file, or to stop or pause a running media file. The current position is specified through the CurrentTime property. TMediaPlayer also exposes media file properties such as Duration, VideoSize, Volume or State.
    TMediaPlayer can play back audio files and the audio component of a video file. To display a video file, use a TMediaPlayerControl component.  For more information, see Audio-Video in FireMonkey.
    
    Note: In order to play an audio file using TMediaPlayer, use the appropriate format:
    .wav on Windows
    .caf on iOS and OS X
    .3GP on Android"""
    __hash__: ClassVar[None] = ...
    CurrentTime: int
    """int: Specifies the current playback position.
        CurrentTime is measured in 100ns. To obtain s, divide CurrentTime by MediaTimeScale.
        Set CurrentTime to control the current position to be played."""
    Duration: int
    """int: Specifies the total play time of the current media file attached to the media player.
        Duration is measured in 100ns. To obtain s, divide Duration by MediaTimeScale."""
    FileName: str
    """str: Specifies the media file name played by the current media player.
        Media is assigned and created when the FileName property is set. The file name must include the path of the file, so it can be localized on the memory, and the extension. 
        To empty the current Media attached to the media player, call the Clear method."""
    Media: Media
    """Media: Specifies the current TMedia attached to this media player.
        Call the Play and Stop methods to start playing, or to stop or pause the current Media file, respectively.
        Media is assigned and created when the FileName property is set.
        TMediaPlayer exposes the Media properties through the following properties: Duration, VideoSize, CurrentTime, Volume, and  State. 
        To empty the current Media attached to the media player, call the Clear method.
        If Media type is audio, then calling Play will start playing the audio file. If Media type is video, then calling Play will just play the audio component of the specified video file. To display a video file, use a TMediaPlayerControl, and link the current TMediaPlayer to it by setting the MediaPlayer property of the TMediaPlayerControl."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    State: MediaState
    """MediaState: Specifies whether the current attached Media is playing or is stopped.
        If the current media file is not assigned or supported, then State is set to Unavailable.
        If the current media file is playing, then State is set to Playing, otherwise it is set to Stopped."""
    VideoSize: PointF
    """PointF: Specifies the resolution of the current video file.
        VideoSize specifies the native width and height of the current media file, in pixels. 
        VideoSize is a TPointF. The X coordinate of the point represents the width of the window, and the Y coordinate of the point represents the height of the window. If the media file is audio only and does not have a window to be displayed, or if no media file is attached to the media player, then VideoSize is (0,0)."""
    Volume: float
    """float: Specifies the audio volume of the current media file.
        Volume takes values in the range from 0 through 1. If Volume is 1, then the media file is played at the maximum native volume. If Volume is 0, then the media file is mute.
        If there is no media file attached to the current media player, then Volume is 1."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Clear(self, *args, **kwargs) -> Any:
        """Clears the current media player.
        Call Clear to clear the current Media attached to the media player. Clear also empties the FileName property."""
    def Create(self, AOwner: Component) -> None:
        """TMediaPlayer.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Media.TMediaPlayer.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Media.TMediaPlayer.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Play(self, *args, **kwargs) -> Any:
        """Starts playing the current Media.
        Call the Play method to play the current Media. If Media is not assigned, Play does nothing. 
        To stop or pause the current media file from playing, call the Stop method."""
    def Stop(self, *args, **kwargs) -> Any:
        """Stops or pauses playing the current Media.
        Call Stop to stop or to pause the current Media. If Media is not assigned, Stop does nothing. 
        To start playing the current media file, call the Play method."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerControl(Control):
    """Visual component to display video media files. 
    TMediaPlayerControl is a native control used to display video media files at design time. It is an empty control that does not show any video data. TMediaPlayerControl can be placed anywhere on a form. To set the video to be displayed, link the current TMediaPlayerControl to a TMediaPlayer through the MediaPlayer property."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Specifies the TMediaPlayer to which this TMediaPlayerControl is linked.
        Set MediaPlayer to link a TMediaPlayer to this TMediaPlayerControl, so the video file attached to the media player is displayed on a form."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TMediaPlayerControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Media.TMediaPlayerControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Media.TMediaPlayerControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerCurrentTime(MediaPlayerValue):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the value."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerPlayPause(CustomMediaPlayerAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the action."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TMediaPlayerPlayPause.ExecuteTarget(Target: Object) -> None
        Executes the action on the media player of the MediaPlayer property. The specified Target is ignored."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerStart(CustomMediaPlayerAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the action."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TMediaPlayerStart.ExecuteTarget(Target: Object) -> None
        Executes the action on the media player of the MediaPlayer property. The specified Target is ignored."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerStop(CustomMediaPlayerAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the action."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TMediaPlayerStop.ExecuteTarget(Target: Object) -> None
        Executes the action on the media player of the MediaPlayer property. The specified Target is ignored."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerValue(CustomValueRangeAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    CustomText: str
    """str: CustomText is a user text.
        Some actions can, by default, automatically set the Text property. For example, in the TFileExit standard action, the Text property has the Quit <Application.Title> value. To set your own value, set the value of the Text property to the value of the CustomText property."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the value."""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TMediaPlayerValue.Create(AOwner: Component) -> None
        Creates an instance of TMediaPlayerValue."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TMediaPlayerValue.HandlesTarget(Target: Object) -> bool
        Whether Target is appropriate for the action (True) or not (False).
        HandlesTarget is always False."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayerVolume(MediaPlayerValue):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    MediaPlayer: MediaPlayer
    """MediaPlayer: Instance of TMediaPlayer that is target of the value."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Memo(CustomMemo):
    """TMemo is a multiline text editing control, providing text scrolling.
    Use TMemo to place a standard multiline edit control on a form. Multiline edit boxes allow the user to enter more than one line of text. They are appropriate for representing large amounts of text. 
    The text in the memo control can be edited as a whole or line by line. 
    The characteristics of the text in the memo control can be modified by using, for example, Font, FontColor, or CharCase.
    To limit the changes made to the memo control, use properties such as ReadOnly, Enabled, or MaxLength.
    When not in focus, TMemo does not draw a selection rectangle even though the user has selected the text. You can verify whether the text is selected by using the SelText property.
    
    Note: When a number of lines in a control is more than can be concurrently shown in the control, then you can use a scroll bar to scroll the text in the control. Notice that on Windows the scroll bar is shown by default. However, on OS X the scroll bar is not shown by default. On OS X, the scroll bar appears when you try to scroll a text using the mouse wheel. To enforce the scroll bar to be shown by default, in the Object Inspector, select the memo control and set the AutoHide to False."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoSelect: bool
    """bool: Defines whether the system selects all the memo's text when the control receives focus.
        AutoSelect defines whether the system selects all the Text included in the TCustomMemo memo when the control receives focus. If AutoSelect is True, then all text is selected when the memo receives focus. 
        In TMemo, AutoSelect is set to False."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Caret: Caret
    """Caret: Provides access to the TCaret attached to the memo control."""
    CharCase: EditCharCase
    """EditCharCase: Defines the character case for the text within the memo control.
        Modify the CharCase|CharCase property's value in order to change the case of the text in the memo control. 
        Options are: ecNormal, ecUpperCase and ecLowerCase."""
    CheckSpelling: bool
    """bool: Defines whether the spell-checking feature of the memo control is on or off.
        This property enables spell checking on the TMemo component. When set to True a red squiggly line appears underlining the words misspelled.  
        The spell checking is performed by an operating system service. It is only supported on iOS and OS X."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DataDetectorTypes: DataDetectorTypes
    """DataDetectorTypes: The types of information that can be detected in the memo text.
        DataDetectorTypes is used on native presentation for iOS only."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HideSelectionOnExit: bool
    """bool: Determines whether to cancel the visual indication of the selected text region when the memo control does not have the focus.
        If HideSelectionOnExit is False, then the memo keeps highlighting the selected text using the SelectionFill brush, even when the focus moves from the memo to another control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ImeMode: ImeMode
    """ImeMode: For internal use only.
        Do not use this member. It is for internal use only.
        Specifies the TImeMode input mode for the memo control."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Specifies the type of on-screen keyboard to be displayed for the memo control.
        Use KeyboardType to specify the type of on-screen keyboard that appears for the memo when ShowVirtualKeyboard is called."""
    Lines: Strings
    """Strings: Provides access to the individual lines in the memo text.
        The memo text can contain several line break symbols that separate the whole memo text into several lines. Depending on the current platform, a line break symbol can be a LF 'line feed' character (MacOS) or a CRLF 'carriage return' plus 'line feed' pair (Windows). Lines holds the memo text separated line by line. 
        When WordWrap is True then each line (specified in the Lines property) can be wrapped into several 'visual lines' to fit to the memo width. However these several 'visual lines' are still represented by a single string element in the Lines property. 
        
        Notice that GoToLineBegin and GoToLineEnd move the cursor to the beginning or the end of the current (pointed by the cursor) visual line.
        Lines is a TStrings object, so you can use TStrings methods to work with the Lines property. 
        For example, you can count the number of lines: 
        
        ShowMessage('The number of lines:' + IntToStr(Memo1.Lines.Count));
        
        You can add new lines: 
        
        Memo1.Lines.Append('New text to append at the end of memo');
        
        You can delete lines:  
        
        Memo1.Lines.Delete(0); // Deletes the fist line from memo
        
        You can replace a line with a new string:
        
        Memo1.Lines[8] := 'Replace 9th  line with this string';
        
        To work with all the memo's text at once, one can use the Text property."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MaxLength: int
    """int: Specifies the maximum number of characters that can be kept in the memo control.
        If the text in the memo control contains more characters than the MaxLength, then the text is truncated to the MaxLength characters. 
        If the memo control already contains a number of characters equal to MaxLength, then the user cannot enter any more characters. 
        MaxLength counts end-of-line characters. 
        If MaxLength is 0, then no explicit length limitation is set.
        
        Note: Even when MaxLength is 0, there may be limitations imposed by a platform on the number of characters that may be entered into a memo control."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnValidate: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnValidating: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Specifies whether the memo's text can be changed.
        ReadOnly equals to True forbids any modification of the text in the memo control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MemoryStream(CustomMemoryStream):
    """Wrapper for Delphi TMemoryStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Clear(self, *args, **kwargs) -> Any: ...
    def Destroy(self, *args, **kwargs) -> Any: ...
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def LoadFromFile(self, FileName: str) -> None:
        """TMemoryStream.LoadFromFile(FileName: str) -> None"""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TMemoryStream.LoadFromStream(Stream: Stream) -> None"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def SetSize(self, NewSize: int) -> None:
        """TMemoryStream.SetSize(NewSize: int) -> None"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TMemoryStream.Write(Buffer, Count: int) -> int"""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MenuBar(StyledControl):
    """Represents an editable menu bar.
    TMenuBar describes the structure of a menu bar that can be moved, resized, and edited. TMenuBar is composed of TMenuItems.
    Menu items can be added in several ways:
    
    To add a menu item at design time, do any of the following:
    Right-click the component and select Add Item from the context menu.
    Double-click the component and click the Add Item button on the Items Designer.
    Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
    To add a menu item at run time, use the AddObject procedure of the TMenuBar.
    Use Items and ItemsCount to retrieve information about menu items.
    TMenuBar:"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Items: MenuItem
    """MenuItem:"""
    ItemsCount: int
    """int: Returns the total number of menu items in this menu bar."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Clear(self, *args, **kwargs) -> Any:
        """Clears this TMenuBar.
        Clear removes all the children of this menu bar."""
    def Create(self, AOwner: Component) -> None:
        """TMenuBar.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Menus.TMenuBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Menus.TMenuBar.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def StartMenuLoop(self, *args, **kwargs) -> Any:
        """Starts the menu loop for this menu bar. There is no need to manually call StartMenuLoop in applications."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MenuItem(TextControl):
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoCheck: bool
    """bool: Controls whether the IsChecked property toggles when the TMenuItem is clicked.
        Set the AutoCheck property to True if the toggling of the IsChecked property is desired when the  TMenuItem is clicked, and to False otherwise."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bitmap: Bitmap
    """Bitmap: A bitmap that is drawn on the TMenuItem menu item.
        Use Bitmap to provide a custom image that appears next to the text of the TMenuItem.
        Bitmap is an obsolete feature. We recommend to show images stored in a centralized collection of images. Such image is specified with the ImageIndex property from the image list specified with Images. If an image specified with ImageIndex and Images is not empty, the TMenuItem object shows this image. Otherwise, the TMenuItem object shows the image specified in  Bitmap."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    GroupIndex: int
    """int: Identifies the group of TMenuItems to which this TMenuItem belongs.
        A group of TMenuItems represents a set of TMenuItem objects belonging to the same pop-up menu, out of which only one TMenuItem, having the RadioItem property set to True, can be selected.
        
        Note: TMenuItems belonging to different pop-up menus (that do not have the same value for the Parent property) can be simultaneously selected, even if their RadioItem property is True.
        Note: By default, all TMenuItems belonging to the same pop-up menu have the same value for the GroupIndex property."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsChecked: bool
    """bool: Specifies whether a check mark is displayed beside the text of the TMenuItem.
        Use IsChecked to allow the TMenuItem to work like a check box. The menu item appears selected if IsChecked is True, and cleared otherwise.
        
        Note: If AutoCheck is False, the menu item remains cleared even if IsChecked is True."""
    IsSelected: bool
    """bool: Specifies whether the TMenuItem is selected. IsSelected is True if the TMenuItem is selected, and False otherwise."""
    IsSeparator: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Items: MenuItem
    """MenuItem:"""
    ItemsCount: int
    """int: Represents the number of child TMenuItems of this menu item."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    MainMenu: MainMenu
    """MainMenu: It returns the main menu to which the menu item is attached."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentMenuItem: MenuItem
    """MenuItem: It returns the parent menu item."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    RadioItem: bool
    """bool: Specifies whether the TMenuItem is mutually exclusive with other menu items in its group.
        Use RadioItem to make the menu item behave like a radio button with a group of other menu items. The group of menu items is the set of all menu items in a pop-up menu that have the same value of GroupIndex. When RadioItem is True, only one menu item in the group that contains the menu item can be selected at a time. The single selected menu item in the group is indicated by a check mark beside its text.
        
        Note: RadioItem does not work for the top-level items in a main menu."""
    ShortCut: int
    """int: Shortcut that opens the menu item."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    Text: str
    '''str: Specifies the text that will be rendered over the surface of this TTextControl object.
        Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
        If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters.
        
        Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
        Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be "any string", but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.'''
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    View: IMenuView
    """IMenuView: For internal use.
        Do not use this property. It is for internal use."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def CalcRenderSize(self, *args, **kwargs) -> Any:
        """CalcRenderSize determines the render size of this TMenuItem as a TPointF."""
    def CalcSize(self, *args, **kwargs) -> Any:
        """Calculates the size of a TMenuItem as a TPointF.
        Use CalcSize to determine the size of a TMenuItem object as a TPointF.
        
        Note: The Y value of the TPointF returned is 8 for a separator, and 23 for a regular TMenuItem."""
    def CanBeClicked(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Clear(self, *args, **kwargs) -> Any:
        """Clears this TMenuItem.
        Clear removes all the children menu items of this menu item."""
    def Create(self, AOwner: Component) -> None:
        """TMenuItem.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Menus.TMenuItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Menus.TMenuItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def HavePopup(self, *args, **kwargs) -> Any:
        """Decides whether the current TMenuItem needs a pop-up menu.
        A TMenuItem object needs a pop-up menu if at least one of the object's children is a TMenuItem."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedPopup(self, *args, **kwargs) -> Any:
        """Displays the pop-up menu of the current TMenuItem object, after a short delay.
        Use NeedPopup to display the pop-up menu of the current TMenuItem object, after a short delay."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def Popup(self, *args, **kwargs) -> Any:
        """Creates and displays the TMenuItem's pop-up menu.
        Popup creates and displays a pop-up menu containing all the visible TMenuItem children of the current object.
        
        Note: The TMenuItem children for which the Visible property is False are not displayed."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MultiView(CustomMultiView):
    """The class for MultiView components that allows providing the master-detail interface.
    With TMultiView, you can implement a master-detail interface, which can be used for any target platform (such as an iOS, Android, or desktop application).
    The TMultiView component provides the interface between the master and detail panes:   
    
    In the master pane, you can display a collection of visual controls, such as edit boxes, labels, lists, and so on. These controls may be linked to the concrete views on the detail pane.
    The detail pane displays information about the objects selected in the master pane. Whenever you change the selection in the master pane, the detail pane is updated to show details of the new selection.
    For more information, see Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android) and FMX.MultiViewDemo sample application."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    BorderOptions: MultiViewBorderOptions
    """MultiViewBorderOptions: Handles appearance options of borders for MultiView components.
        TMultiViewBorderOptions defines the  Color and Visible properties."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    DrawerOptions: DrawerAppearance
    """DrawerAppearance: Handles appearance options of the master pane in the Drawer presentation mode.
        The DrawerOptions property handles the following options:
        
        DurationSliding: specifies the duration of the master pane sliding (in seconds).
        Mode: specifies the master pane sliding mode.
        Placement: specifies the master pane location (left or right).
        TouchAreaSize: specifies the touch area size (in pixels)."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    MasterButton: Control
    '''Control: Allows you to hide or show the master pane.
        If your application has no master button, leave the MasterButton property empty.
        
        Limitations
        The master button cannot be used when:
        
        The button is invisible and if the Mode property is set to Panel presentation mode. That is, the master pane is a "docked panel".
        The onClick event handler is not supported.'''
    Mode: MultiViewMode
    """MultiViewMode: Specifies the presentation mode of the master pane.
        The TMultiViewMode type provides the following presentation modes:
        
        
        
        Mode
        
        Master Pane Presentation
        
        
        Drawer
        
        In the Drawer mode, the master pane can be whether hidden or can slide to overlap the detail pane.
        
        
        Panel
        
        Master and detail panels are always displayed, independently of a device type and orientation. The master panel is docked to the left or right of the MultiView component.
        
        
        PlatformBehaviour
        
        An application automatically selects the master pane presentation mode depending on the device type and orientation, as described in the tables in the Platform Dependent Behavior Mode subsection below.
        
        
        Popover
        
        Pop-up menu.
        
        
        NavigationPane
        
        Navigation pane.
        
        
        Custom
        
        The user can customize the master pane presentation. The custom presentation class should be set in the CustomPresentationClass property. For details, see Custom Mode description.
        
        For detailed information about the presentation modes, see Master Pane Presentation Modes.
        
        Platform Dependent Behavior Mode
        In the PlatformBehaviour mode, you let the application automatically select the master pane presentation mode. In this scenario,  the application behavior depends on the device type, orientation, and the operation system version (only for desktop applications) as described in the following tables:
        Mobile Applications
        
        
        
        Device Type
        
        Device Orientation  
        
        Master Pane Presentation
        
        
        Phone
        
        Landscape, Portrait
        
        Drawer (push/overlap)
        
        
        Tablet
        
        Landscape
        
        Docked panel
        
        
        Tablet
        
        Portrait
        
        Drawer (push/overlap)
        
        Desktop Applications
        
        
        
        OS Version
        
        Master Pane Presentation
        
        
        Windows 10
        
        Navigation pane
        
        
        Windows 8 or earlier
        
        Docked panel
        
        
        OS X
        
        Docked panel"""
    NavigationPaneOptions: NavigationPaneAppearance
    """NavigationPaneAppearance: Handles the appearance options of the master pane in the NavigationPane presentation mode.
        With NavigationPaneOptions, you can manage the CollapsedWidth property of the master pane appearance of the current MultiView component. CollapsedWidth specifies the width (in pixels) of the master pane in the NavigationPane presentation mode when it is collapsed."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnHidden: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresenterChanging: Callable[[Object,MultiViewPresentationClass],None]
    """Callable[[Object, MultiViewPresentationClass], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShown: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartHiding: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartShowing: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopoverOptions: PopoverAppearance
    """PopoverAppearance: Handles appearance options of the master pane in the Popover presentation mode.
        In the Popover presentation mode, the master pane is a pop-up menu, which can be displayed or hidden using the master button.
        The PopoverOptions property allows you to handle the following options:
        
        AppearanceDuration: specifies the duration of the pop-up window appearance (in seconds). By default, this property is set to 0.25 s.
        PopupHeight: specifies the height of the pop-up window (in pixels). By default, this property is set to 400px.
        StyleLookup: specifies the name of the resource object (style) to which this pop-up window is linked.
        TintColor: specifies the tint applied to this pop-up window."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShadowOptions: ShadowAppearance
    """ShadowAppearance: Handles appearance options of a shadow that the master pane casts on the detail pane.
        With ShadowOptions property, you can handle the following appearance options of the shadow:
        
        Color: specifies the shadow color.
        Enabled: enables or disables the shadow.
        Opacity: specifies the opacity level of the shadow."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    SplitViewOptions: SplitViewAppearance
    """SplitViewAppearance: Handles appearance options of the master pane in the Panel presentation mode.
        With SplitViewOptions property, you can handle the Placement option. Placement specifies the docked master pane location (left, right, top, or bottom)."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TargetControl: Control
    """Control: Specifies a datail pane container (such as TPanel) showing elements described in the master pane.
        For more information about the master-detail interface, see Mobile Tutorial: Using a MultiView Component to Display Alternate Views of Information (iOS and Android).
        
        Limitations
        See FireMonkey Native iOS Controls: Combining Native iOS Controls With Non-native Controls for more information about the limitations when using native controls.
        
        Exceptions
        Setting TargetControl may raise the following exception:
        
        
        
        Exception
        
        Exception.Message
        
        Scenarios
        
        
        
        EComponentError
        
        
        
        TargetControl cannot be a child of TMultiView.
        
        
        
        You set a child control of a TMultiView as the TargetControl of that TMultiView.
        You set a TMultiView as the TargetControl of itself."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class NumberBox(CustomEditBox):
    """Wrapper for Delphi TNumberBox"""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Caret: CustomCaret
    """CustomCaret: Represents the caret of the control.
        Caret is of type TCaret."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    HorzIncrement: float
    """float: Represents the value with which the number is incremented or decremented when, while holding down the mouse button, you move the mouse horizontally.
        HorzIncrement represents the value added or decreased from the number when, while holding down the mouse button, you move the mouse to the left or to the right."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Determines the type of the virtual keyboard.
        Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
        Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).
        
        Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions."""
    KillFocusByReturn: bool
    """bool: Specifies whether to hide the virtual keyboard by clicking the Return key.
        When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Model: NumberBoxModel
    """NumberBoxModel: The data model representing the data used by the presentation of the current control.
        FMX.EditBox.TCustomEditBox.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
        The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.
        
         See Also
        FMX.Controls.Model.TDataModel
        FMX.Controls.Presentation.TPresentedControl.Presentation
        FMX.Controls.Presentation.TPresentedControl.Create
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass"""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTyping: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Determines whether you can change the text of this edit control.
        To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
        Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how this edit control  displays the text in terms of horizontal alignment. TextAlign can have one of the following, defined in TTextAlign, values:
        
        Center (default) aligns the text at the middle of the edit control.
        Leading aligns the text at the leftmost position inside the edit control.
        Trailing aligns the text at the rightmost position inside the edit control.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    VertIncrement: float
    """float:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Object:
    """TObject is the ultimate ancestor of all objects and components.
    TObject encapsulates fundamental behavior common to objects by introducing methods that:
    
    Create, maintain, and destroy instances of the object by allocating, initializing, and freeing required memory.
    Respond when object instances are created or destroyed.
    Return class-type and instance information on an object and runtime type information (RTTI) about its published properties.
    Support message handling.
    Support interfaces implemented by the object.
    Use TObject as an immediate base class when declaring simple objects that do not need to persist (are not saved and reloaded) and that do not need to be assigned to other objects. 
    Much of the capability of objects is established by methods that TObject introduces. Many of these methods are used internally by IDEs and are not intended for users to call directly. Others are overridden in descendant objects that have more complex behavior. 
    Although TObject is the based object of a component framework, not all objects are components. All component classes descend from TComponent. 
    
    Note: TObject is never directly instantiated. Although it does not use programming language features that prevent instantiation, TObject is an abstract class."""
    __hash__: ClassVar[None] = ...
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any: ...
    def BeforeDestruction(self, *args, **kwargs) -> Any: ...
    @classmethod
    def ClassInfo(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def ClassName(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def ClassNameIs(cls, Name: str) -> bool:
        """TObject.ClassNameIs(Name: str) -> bool"""
    @classmethod
    def ClassParent(cls, *args, **kwargs) -> Any: ...
    def ClassType(self, *args, **kwargs) -> Any: ...
    def CleanupInstance(self, *args, **kwargs) -> Any: ...
    def Create(self, *args, **kwargs) -> Any: ...
    def DefaultHandler(self, Message) -> None:
        """TObject.DefaultHandler(Message) -> None"""
    def Destroy(self, *args, **kwargs) -> Any: ...
    def Dispatch(self, Message) -> None:
        """TObject.Dispatch(Message) -> None"""
    def DisposeOf(self, *args, **kwargs) -> Any: ...
    def Equals(self, Obj: Object) -> bool:
        """TObject.Equals(Obj: Object) -> bool"""
    def FieldAddress(self, Name: str) -> Pointer:
        """TObject.FieldAddress(Name: str) -> Pointer"""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def FreeInstance(self, *args, **kwargs) -> Any: ...
    def GetHashCode(self, *args, **kwargs) -> Any: ...
    def GetInterface(self, IID: GUID, Obj) -> bool:
        """TObject.GetInterface(IID: GUID, Obj) -> bool"""
    @classmethod
    def GetInterfaceEntry(cls, IID: GUID) -> PInterfaceEntry:
        """TObject.GetInterfaceEntry(IID: GUID) -> PInterfaceEntry"""
    @classmethod
    def GetInterfaceTable(cls, *args, **kwargs) -> Any: ...
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    @classmethod
    def InitInstance(cls, Instance: Pointer) -> Object:
        """TObject.InitInstance(Instance: Pointer) -> Object"""
    @classmethod
    def InstanceSize(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def MethodAddress(cls, Name: str) -> Pointer:
        """TObject.MethodAddress(Name: str) -> Pointer"""
    @classmethod
    def MethodName(cls, Address: Pointer) -> str:
        """TObject.MethodName(Address: Pointer) -> str"""
    @classmethod
    def NewInstance(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def QualifiedClassName(cls, *args, **kwargs) -> Any: ...
    def SafeCallException(self, ExceptObject: Object, ExceptAddr: Pointer) -> int:
        """TObject.SafeCallException(ExceptObject: Object, ExceptAddr: Pointer) -> int"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToString(self, *args, **kwargs) -> Any: ...
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    @classmethod
    def UnitName(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def UnitScope(cls, *args, **kwargs) -> Any: ...
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ObjectViewAction(CustomViewAction):
    """A base class for actions that show a specified component when executed.
    FMX.StdActns.TObjectViewAction inherits from FMX.ActnList.TCustomViewAction. All content below this line refers to FMX.ActnList.TCustomViewAction.
    A base class for actions that show a specified component when executed.
    Descendants of TCustomViewAction can be associated with a component that is made visible when the action executes.
    TCustomViewAction extends TCustomAction declaring the component that the action shows when it executes.
    TObjectViewAction extends the TCustomViewAction class that defines the FmxObject property and keeps the component value that should be the TFmxObject type object in this case. 
    Descendants of TObjectViewAction are associated with the TFmxObject type component that is made visible when the action executes.  
    TVirtualKeyboard and TViewAction are standard actions that descend from TObjectViewAction.
    Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TCustomViewAction (and its descendants) does not distribute changes in values of Caption, Enabled, Checked, GroupIndex, ShortCut, Visible, and OnExecute properties to the respective properties of clients linked with action links. 
    
     See Also
    FMX.ActnList.TCustomViewAction.Component
    FMX.Types.TFmxObject
    FMX.StdActns.TObjectViewAction
    FMX.ActnList.TActionLink
    System.Actions.TContainedAction.Caption
    System.Actions.TContainedAction.Enabled
    System.Actions.TContainedAction.Checked
    System.Actions.TContainedAction.GroupIndex
    System.Actions.TContainedAction.ShortCut
    System.Actions.TContainedAction.Visible
    System.Classes.TBasicAction.OnExecute"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    FmxObject: FmxObject
    """FmxObject: Keeps an FMX object (of the component) that executes an action and whose image becomes visible during the execution of the action."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class OpenDialog(FmxObject):
    """TOpenDialog is a class used to display a file-selection dialog.
    Use TOpenDialog to display a dialog box for selecting and opening files. 
    When the user clicks the Open button, the dialog closes and the selected files are stored in the Files property.
    
    Note: The dialog does not appear at run time until it is activated by a call to the Execute method."""
    __hash__: ClassVar[None] = ...
    DefaultExt: str
    """str: Specifies a default file extension.
        DefaultExt specifies a file extension that is appended automatically to the selected file name, unless the selected file name already includes a registered extension.
        Extensions longer than three characters are not supported. Do not include the period (.) that separates the file name from the extension."""
    FileName: Any
    Files: Strings
    """Strings: Represents the list containing the absolute paths of the selected files.
        Files represents a string list that contains the absolute path of each selected file. 
        
        Note: In order for the user to select multiple files, set the ofAllowMultiSelect flag in Options."""
    Filter: str
    """str: Represents the file masks (filters) of the dialog.
        The file-selection dialog includes a drop-down list of file types on the left of the 'File Name:' edit box. When the user picks a file type from the list, only files of the selected type are displayed in the dialog. You can select only one filter at a time.
        In order for Filter to work properly, the assigned string must be formatted as follows: 
        '<first displayed name>|<first file extension>|<second displayed name>|<second file extension>|...|<n-th displayed name>|<n-th file extension>'
        For example, the next code sample will add filters for text and executable files:
        
          OpenDialog1.Filter:='Applications (*.exe)|*.EXE|Text files (*.txt)|*.TXT';"""
    FilterIndex: int
    """int: Determines which filter is selected by default when the dialog opens.
        FilterIndex determines which of the file types in Filter is selected by default when the dialog opens. Set FilterIndex to 1 to choose the first file type in the list as default, 2 to choose the second file type as the default, and so on. If the value of FilterIndex is out of range, the last file type listed in Filter is selected by default."""
    HistoryList: Strings
    """Strings: Maintains a list of the previously selected files. Obsolete property.
        HistoryList is maintained for compatibility with older versions of TOpenDialog. It is not used."""
    InitialDir: str
    """str: Determines which directory is selected by default when the dialog opens.
        InitialDir determines the default directory displayed in the file-selection dialog when it opens.
        If no value is assigned to InitialDir, or the specified directory does not exist, the initial directory is controlled by a special registry key assigned to your application.
        
        Note: For Windows, the registry key can be found at HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\LastVisitedMRU\\."""
    OnCanClose: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnFolderChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectionChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTypeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Options: OpenOptions
    """OpenOptions: Determines the appearance and behavior of the file-selection dialog.
        Use the Options property to customize the appearance and functionality of the dialog."""
    OptionsEx: OpenOptionsEx
    """OpenOptionsEx: Augments the Options property with additional flags that determine the appearance and behavior of the file selection dialog.
        Use the OptionsEx property to further customize the file open dialog beyond the options covered by the Options property."""
    Title: str
    '''str: Specifies the text displayed in the dialog\'s title bar.
        Use Title to set the text that appears in the file-selection dialog\'s title bar. If no value is assigned to Title, the dialog\'s title is "Open".'''
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TOpenDialog.Create(AOwner: Component) -> None
        Creates and initializes a TOpenDialog instance.
        Create generates a TOpenDialog instance, but the new dialog does not appear on the form at runtime until the Execute method is called.
        AOwner is the component that is responsible for freeing the TOpenDialog instance. It becomes the value of the Owner property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TOpenDialog object and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free calls Destroy if the TOpenDialog reference is not nil."""
    def Execute(self) -> Any:
        """TOpenDialog.Execute()
        Displays the dialog"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PaintBox(Control):
    """TPaintBox defines a 2D image component providing a canvas that an application can use for rendering an image. It inherits TControl and can be used in styles to construct controls.
    Unlike TImage, which displays a picture that is stored in a file, TPaintBox requires an application to draw the image directly on a canvas. Use the OnPaint event handler to draw on the paint box's FMX.Graphics.TCanvas, the drawing surface of the paint box."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas],None]
    """Callable[[Object, Canvas], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TPaintBox.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Objects.TPaintBox.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Objects.TPaintBox.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Panel(StyledControl):
    """Represents a generic general-purpose panel used to hold multiple controls for organizing purposes.
    Use TPanel components when you need to provide the user with a way of placing multiple graphical components on a surface for organizing purposes.
    Panels have methods to help manage the placement of child controls embedded in the panel. You can also use panels to group controls together, similarly to the way you can use a group box. Panels are typically used for groups of controls within a single form. Panels with no borders are useful as docking sites when writing applications that use drag-and-dock."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TPanel.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TPanel.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PascalInterface:
    """Wrapper of a Pascal record"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PascalRecord:
    """Wrapper of a Pascal record"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Path(CustomPath):
    """TPath defines 2D path-type shapes representing groups of connected curves and lines."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Data: PathData
    '''PathData: Specifies the SVG data used to build graphic shapes.
        The Data property supports only a comma-separated list of instructions defined for the d attribute of the path element in SVG 1.0. 
        In SVG 1.0, the d attribute contains the moveto, line, curve, arc, and closepath instructions. All instructions are expressed as one character (for example, a moveto is expressed as an M).
        For more information, see Scalable Vector Graphics (SVG) 1.0 Specification.
        
        Example
        To clarify, consider the following code snippets that specify the SVG instructions at run time:
        
        
        Delphi:
        
        Path1.Data.Data := \'M 1,0, L 2,1, L 1,2, L 0,1, L 1,0\';
        
        
        C++Builder:
        
        
        Path1->Data->Data = "M 1,0, L 2,1, L 1,2, L 0,1, L 1,0";
        
        
        An application that uses the above mentioned SVG instructions displays a rhomb:'''
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WrapMode: PathWrapMode
    """PathWrapMode: Specifies whether and how to resize, replicate, and position the graphical path representation for painting the area.
        The WrapMode property should be one of the constants defined in the TPathWrapMode type: 
        
        Stretch--stretches the path representation to fill the entire area. Default.
        Original--keeps the original path size.
        Fit--resizes the path representation (keeping proportions) to best fit the area.
        Tile--renders the path representation repeatedly to tile the area."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PathLabel(StyledControl):
    """Represents a graphical control used to display information contained in TPathData within FireMonkey forms.
    Use TPathLabel components in FireMonkey forms to add TPathData display capabilities.
    For instance, the following image displays three rectangles by using a TPathData object.
    
    var
      PathData: TPathData;
    
    begin
      PathData:= TPathData.Create;
      PathData.AddRectangle(RectF(20, 20, 80, 80), 0, 0, AllCorners);
      PathData.AddRectangle(RectF(10, 10, 90, 90), 0, 0, AllCorners);
      PathData.AddRectangle(RectF(0, 0, 100, 100), 0, 0, AllCorners);
      PathLabel1.Data := PathData;
    
      { ... other instructions ... }
    
    
    To add an object to a form that displays text, use a TLabel."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    Data: PathData
    """PathData: Stores a Tvalue, which is a data structure that can store different kinds of data types.
        FMX.StdCtrls.TPathLabel.Data inherits from FMX.Types.TFmxObject.Data. All content below this line refers to FMX.Types.TFmxObject.Data.
        Stores a Tvalue, which is a data structure that can store different kinds of data types.
        Data has no predefined meaning. Although Data is used for LiveBinding, any succesor override this behavior. Then, the behaviour of Data is based on the type of its value.
        
        Note: Do not use this member. It is for internal use only."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WrapMode: PathWrapMode
    """PathWrapMode: Specifies the way the contents of this path label will be drawn.
        WrapMode can take one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        Fit
        
        
        
        The graphical path contents fit the entire area of this path label.
        
        
        
        
        Original
        
        
        
        The graphical path contents show at their original size in this path label.
        
        
        
        
        Stretch
        
        
        
        The graphical path contents stretch to fit the entire area of this path label.
        
        
        
        
        Tile
        
        
        
        The graphical path contents tile one or multiple times to fill the entire area of this path label."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TPathLabel.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TPathLabel.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.StdCtrls.TPathLabel.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Persistent(Object):
    """TPersistent is the ancestor for all objects that have assignment and streaming capabilities.
    TPersistent encapsulates the behavior common to all objects that can be assigned to other objects, and that can read and write their properties to and from a form file (.xfm or .dfm file). For this purpose, TPersistent introduces methods that can be overridden to:
    
    Define the procedure for loading and storing unpublished data to a stream.
    Provide the means to assign values to properties.
    Provide the means to assign the contents of one object to another.
    Do not create instances of TPersistent. Use TPersistent as a base class when declaring objects that are not components, but that need to be saved to a stream or have their properties assigned to other objects."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Pie(Ellipse):
    """TPie defines 2D pies. 
    TPie is drawn as part of TEllipse. It inherits TControl and can be used in styles to construct controls.
    The TPie object is the part of the TEllipse object enclosed between radiuses with the StartAngle and EndAngle angles.
    The ShapeRect bounding rectangle, scaling factors specified by Scale, RotationCenter rotation axis, and RotationAngle rotation angle of the TEllipse object should be used to define the general size, shape, and position of TPie.
    TPie draws the contour and fills the shape background with the Paint method. 
    Paint draws the contour using the drawing pen with the properties, color, and opacity defined by the Stroke property of the TPie object.
    Paint fills the background using the drawing brush with the properties, color, and opacity defined by the current Fill property of the TPie object."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    EndAngle: float
    """float: Specifies the end angle for this pie object.
        The EndAngle end angle is measured clockwise from the StartAngle start angle. 
        Use EndAngle in conjunction with StartAngle to specify how to draw and fill this pie."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    StartAngle: float
    """float: Specifies the start angle for this pie object.
        The StartAngle start angle is measured clockwise from the x-axis. 
        Use StartAngle in conjunction with EndAngle to specify how to draw and fill this pie.
        Notice that FMX.Controls.TControl.RotationAngle rotates the x-axis."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TPie.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TPie.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PointInObject(self, X: float, Y: float) -> bool:
        """TPie.PointInObject(X: float, Y: float) -> bool
        Checks whether the point, specified by the absolute coordinates, belongs to the control area.
        FMX.Objects.TPie.PointInObject inherits from FMX.Controls.TControl.PointInObject. All content below this line refers to FMX.Controls.TControl.PointInObject.
        Checks whether the point, specified by the absolute coordinates, belongs to the control area.
        PointInObject returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the absolute coordinates (relative to the main form) of the point to be checked (compare with PointInObjectLocal):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The points of the control boundary specified by BoundsRect belong to the control and PointInObject returns True for them.
        
        Note: PointInObject simply converts absolute coordinates of the point to local coordinates and calls PointInObjectLocal."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Point:
    """wrapper for Delphi TPoint type"""
    __hash__: ClassVar[None] = ...
    X: Any
    """Provides access to the X coordinate of a point"""
    Y: Any
    """Provides access to the Y coordinate of a point"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PointF:
    """wrapper for Delphi FMX TPointF type"""
    __hash__: ClassVar[None] = ...
    X: Any
    """Provides access to the X coordinate of a pointf"""
    Y: Any
    """Provides access to the Y coordinate of a pointf"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Popup(StyledControl):
    """TPopup provides a pop-up window.
    Use TPopup to display content in a temporary window.   
    By default, a TPopup content is empty. You can add any number of objects to the TPopup content:
    
    To add a control to the TPopup content, set the Parent property of the control or create it with the TPopup as its owner.
    To access the TPopup children, use ChildrenCount and Children properties.
    To position a TPopup, use the following properties:
    
    PlacementRectangle
    PlacementTarget
    HorizontalOffset
    VerticalOffset
    Placement
    When TPopup is open, it does not reposition itself if its parent is repositioned. To drag a TPopup together with its parent, set the DragWithParent property to True.
    TPopup supports animations and graphic effects. The animations and graphic effects are applied to the displayed window, and not to every child of the TPopup. For opacity effects, set the effects directly to the TPopup children. TPopup children do not inherit the animations and effects applied to the parent.
    If TPopup is not explicitly sized, it is sized by its content. In this case, if an effect is applied that increases the content's displayed size, part of the content might be obscured. To avoid this, explicitly set the size for TPopup or set its bounds through the BoundsRect, Margins, and Padding properties.   
    To open and explicitly close a TPopup, set the TPopup.IsOpen property to True and False, respectively. 
    (We do not recommend using Popup and ClosePopup.)"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AniDuration: float
    """float: Sets the animation duration during appearing or closing of the pop-up window.
        AniDuration defines time (in seconds) of a custom animation execution. The OnAniTimer event is periodically triggered during the AniDuration time after the pop-up window starts appearing or closing. During the AniDuration time, the AniPosition property changes from 0 to 1 (during opening) and from 1 to 0 (during closing) respectively. The OnAniTimer event handler contains the code that is performed during animation. 
        
        Note: AniDuration does not influence on a duration of an external animation (for example TFloatAnimation animation) if such is assigned to the TPopup pop-up window."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    BorderWidth: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ClosingAnimation: bool
    """bool: Is True if the TPopup has a closing animation, False otherwise."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    DragWithParent: bool
    """bool: Specifies whether the TPopup is dragged together with its parent.
        If DragWithParent is set to True, TPopup is dragged too, when its parent is the target of a drag-and-drop operation. The default value is False. 
        For example, the TPopup of a combo box is dragged with its parent."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HideWhenPlacementTargetInvisible: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    HorizontalOffset: float
    """float: Sets and gets the horizontal distance between the target origin and the TPopup alignment point. 
        To set the target origin and the alignment point, use the PlacementTarget, Placement, and PlacementRectangle properties. 
        HorizontalOffset has no effect if Placement has one of the values: Absolute, Mouse, MouseCenter."""
    IsOpen: bool
    """bool: Is True if the TPopup is dropped down, False otherwise."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    ModalResult: int
    '''int: Determines whether and how the TPopup closes its modal form. 
        TModalResult describes possible values of ModalResult.
        You can check a ModalResult value  using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the  StripAllFromResult function to convert the ModalResult value from a constant that refers to "all" to the corresponding simple constant.'''
    OnAniTimer: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    Placement: Placement
    """Placement: Determines how to position the TPopup form  relative to a rectangle specified by the PlacementRectangle or PlacementTarget properties, relative to the screen, or relative to the mouse (pointing device) position.
        Placement also specifies the behavior of the TPopup form, when it overlaps screen boundaries. The default value is Bottom.
        TPlacement determines possible values of Placement.
        Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup."""
    PlacementRectangle: Bounds
    """Bounds: Gets or sets the rectangle element relative to which TPopup is positioned. 
        Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup. 
        This is an example of a TPopup with PlacementRectangle:"""
    PlacementTarget: Control
    """Control: Gets or sets the target relative to which TPopup is positioned. 
        If PlacementTarget is not set, and TPopup has a parent, TPopup is positioned relative to its parent. If PlacementTarget and Parent are not set, TPopup is positioned relative to the main window. 
        Use Placement, PlacementTarget, and PlacementRectangle to set the target origin and the alignment point of TPopup."""
    PopupFormSize: SizeF
    """SizeF: Sets the size of the TPopup through a TSizeF object.
        For example, the following code will set up the TPopup Width to 200 and Height to 250: 
        Delphi:
        
          p1.PopupFormSize := TSizeF.Create(200, 250);
        
        C++ Builder:
        
          p1->PopupFormSize = TSizeF->Create(200, 250);"""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    PreferedDisplayIndex: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleBook: StyleBook
    """StyleBook: Gets and sets the TPopup stored style.
        To create a new style, use the Style Designer. See details here: Style Resource Storage."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    VerticalOffset: float
    """float: Sets and gets the vertical distance between the target origin and the TPopup alignment point.
        To set the target origin and the alignment point, use the PlacementTarget, Placement, and PlacementRectangle properties. 
        VerticalOffset has no effect if Placement has one of the values: Absolute, Mouse, MouseCenter."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def BringToFront(self, *args, **kwargs) -> Any:
        """Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
        FMX.Controls.TPopup.BringToFront inherits from FMX.Types.TFmxObject.BringToFront. All content below this line refers to FMX.Types.TFmxObject.BringToFront.
        Brings this FMX visual object on top of other overlapping visual controls that are on the same form.
        You can call BringToFront at run time as in the following code snippet:
        
          Label1.BringToFront;
        
        or, at design time, by right-clicking the FMX visual control and selecting Control > Bring to Front from the pop-up menu."""
    def Create(self, AOwner: Component) -> None:
        """TPopup.Create(AOwner: Component) -> None
        Creates and initializes a TPopup instance.
        Create constructs a TPopup object and initializes its data before the object is used."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPopup instance.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the TPopup object is not nil before calling Destroy."""
    def HasPopupForm(self, *args, **kwargs) -> Any:
        """Returns whether the PopupForm property holds a pop-up form. 
        HasPopupForm returns True if PopupForm holds the pop-up form that appears on the screen after the Popup method execution."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def Popup(self, AShowModal: bool) -> None:
        """TPopup.Popup(AShowModal: bool) -> None
        Displays the TPopup window. 
        
        Note: We do not recommend using Popup and ClosePopup. To open and explicitly close a TPopup, set the TPopup.IsOpen property to True and False, respectively.
        When AShowModal is True, then Popup drops down TPopup as a modal dialog. 
        Popup applies the specified placement and style to TPopup, before making it visible.
        To set the placement, use the PlacementRectangle, PlacementTarget, HorizontalOffset, VerticalOffset, and Placement properties."""
    def PopupModal(self, *args, **kwargs) -> Any:
        '''Returns whether and how the modal form of TPopup closes. 
        PopupModal returns 0 if the modal form is not closed. Otherwise PopupModal returns the value of the ModalResult property.
        To change how the modal form of TPopup is closed, set the ModalResult property.
        You can check a return value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions and use the  StripAllFromResult function to convert the return value from a constant that refers to "all" to the corresponding simple constant.'''
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PopupColumn(Column):
    """Represents a column in a grid, whose cells shows pop-up menus."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Items: StringList
    """StringList: Returns the items available for the pop-up column as strings.
        The items of Items are displayed in a pop-up that appears when clicking one of the cells in the column. Choosing one of the items will set the item as the value of that cell."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TPopupColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TPopupColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Grid.TPopupColumn.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PopupMenu(CustomPopupMenu):
    """Represents a pop-up menu.
    Use TPopupMenu to describe a menu that appears only when the Popup procedure is called. TPopupMenu appears at the coordinates indicated by the parameters of the Popup procedure.
    TPopupMenu is composed of TMenuItems. You can add menu items in several ways:
    
    To add a menu item at design time, do any of the following:
    Right-click the component and select Add Item from the context menu.
    Double-click the component and click the Add Item button on the Items Designer.
    Right-click the component, select Items Editor from the context menu, and then click the Add Item button.
    To add a menu item at run time, use the AddObject procedure of TPopupMenu."""
    __hash__: ClassVar[None] = ...
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Items: MenuItem
    """MenuItem:"""
    ItemsCount: int
    """int: Represents the number of child TMenuItems of this pop-up menu."""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    PopupPoint: PointF
    """PointF: The point where the pop-up menu opens."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Clear(self, *args, **kwargs) -> Any:
        """Clears this TPopupMenu.
        Clear removes all the child menu items of this pop-up menu."""
    def CloseMenu(self, *args, **kwargs) -> Any:
        """TPopupMenu descendants may implement CloseMenu to define actions made when the pop-up menu closes.  
        CloseMenu does nothing. It is meant to be implemented by TPopupMenu descendants to describe actions made when the pop-up menu closes."""
    def Create(self, AOwner: Component) -> None:
        """TPopupMenu.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Menus.TPopupMenu.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Menus.TPopupMenu.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DialogKey(self, Key: int, Shift: ShiftState) -> None:
        """TPopupMenu.DialogKey(Key: int, Shift: ShiftState) -> None
        Processes a dialog key for each of the TPopupMenu's TMenuItems.
        DialogKey is called during the message preprocessing to handle dialog characters. If the pressed keys match the ShortCut property of one of the TPopupMenu's TMenuItems, the OnClick event of that TMenuItem is triggered."""
    def Popup(self, X: float, Y: float) -> None:
        """TPopupMenu.Popup(X: float, Y: float) -> None
        Displays the pop-up menu onscreen.
        Call Popup to bring up the pop-up menu. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Position(Persistent):
    """Used for specifying a control's position inside a form.
    A TPosition object is used for representing the position of a control inside its parent, or anywhere related X and Y values are needed. The position can be specified through the X and Y values, as a Point."""
    __hash__: ClassVar[None] = ...
    DefaultValue: PointF
    """PointF: Specifies the default coordinates of the current object.
        Use the DefaultValue property to receive the default coordinates of a TPosition object."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Point: Any
    """Provides access to the position of a control inside its parent"""
    StoreAsInt: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    X: Any
    """Provides access to the X coordinate of a control inside its parent"""
    Y: Any
    """Provides access to the Y coordinate of a control inside its parent"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, Source: Persistent) -> None:
        """TPosition.Assign(Source: Persistent) -> None
        Copies the contents of another similar object to the current one.
        Assign copies the properties from another TPosition instance."""
    def Create(self, ADefaultValue: PointF) -> None:
        """TPosition.Create(ADefaultValue: PointF) -> None
        Creates and initializes a TPosition instance.
        Create generates a new TPosition instance. Create requires a default TPointF value as a DefaultValue for the position. The DefaultValue is usually (0,0), but can have other values also. If the position is the same as the default value, it is not stored in the .fmx file."""
    def Empty(self, *args, **kwargs) -> Any:
        """Returns True if the components are the default ones, False otherwise.
        Empty returns True if the X and Y coordinates are both the same as described by the DefaultValue property, False otherwise."""
    def Reflect(self, Normal: PointF) -> None:
        """TPosition.Reflect(Normal: PointF) -> None
        Returns the reflection of the current vector across a specified line.
        Use the Reflect function to obtain the reflection of the current position across the perpendicular on the point given as parameter."""
    def SetPointNoChange(self, P: PointF) -> None:
        """TPosition.SetPointNoChange(P: PointF) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedFramedScrollBox(CustomPresentedFramedScrollBox):
    """Wrapper for Delphi TPresentedFramedScrollBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedFramedVertScrollBox(CustomPresentedFramedVertScrollBox):
    """Wrapper for Delphi TPresentedFramedVertScrollBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedHorzScrollBox(CustomPresentedHorzScrollBox):
    """Wrapper for Delphi TPresentedHorzScrollBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedListView(ListViewBase):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        Performs any necessary actions before the first destructor is called.
        FMX.ListView.TPresentedListView.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.ListView.TPresentedListView.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Hide(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def Paint(self, *args, **kwargs) -> Any:
        """Renders the list view."""
    def RebuildList(self, *args, **kwargs) -> Any:
        """Recreates the list and updates the visible items content in native presentation. 
        When using native presentation, RebuildList recreates the list and updates the visible items content.
        To use the native presentation, you must set the ControlType property to Platform."""
    def RecalcEnabled(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its enabled state. 
        FMX.ListView.TPresentedListView.RecalcEnabled inherits from FMX.Controls.TControl.RecalcEnabled. All content below this line refers to FMX.Controls.TControl.RecalcEnabled.
        Forces the current control to recalculate its enabled state.  RecalcEnabled also forces the control's children to recalculate their enabled state."""
    def RecalcOpacity(self, *args, **kwargs) -> Any:
        """Forces the current control to recalculate its Opacity property. 
        FMX.ListView.TPresentedListView.RecalcOpacity inherits from FMX.Controls.TControl.RecalcOpacity. All content below this line refers to FMX.Controls.TControl.RecalcOpacity.
        Forces the current control to recalculate its Opacity property.  RecalcOpacity also forces the control's children to recalculate their Opacity property."""
    def Resize(self, *args, **kwargs) -> Any:
        """OnResize event dispatcher. 
        FMX.ListView.TPresentedListView.Resize inherits from FMX.Controls.TControl.Resize. All content below this line refers to FMX.Controls.TControl.Resize.
        OnResize event dispatcher. 
        A control calls Resize when the dimensions of the control change.
        Derived classes can override the protected Resize method to implement specific responses to control resizing."""
    def Show(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def StopPullRefresh(self, *args, **kwargs) -> Any:
        """This method should be called when 'pull to refresh' mode has been triggered to stop the spinning wheel.
        StopPullRefresh has only effect in native iOS control and only when the PullRefreshWait property is set to True."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedScrollBox(CustomPresentedScrollBox):
    """Wrapper for Delphi TPresentedScrollBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollAnimation: BehaviorBoolean
    """BehaviorBoolean: Enables or disables scrolling animation."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    TouchTracking: BehaviorBoolean
    """BehaviorBoolean: Defines if the control reacts to touch events."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedTextControl(StyledControl):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DefaultTextSettings: TextSettings
    """TextSettings: Stores a TTextSettings type object that keeps the default values of the text representation properties.
        DefaultTextSettings is set during the loading of the style in the ApplyStyle method."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    FontColor: int
    """int: Specifies the font color to use when displaying the text.
        This property sets or returns a value of the TAlphaColor type."""
    PrefixStyle: PrefixStyle
    """PrefixStyle: Determines whether the ampersand character (&) is considered as a special prefix character.
        The default value is TPrefixStyle.HidePrefix, which means that the (first) ampersand is hidden at run-time."""
    ResultingTextSettings: TextSettings
    """TextSettings: Keeps final values of text representation properties. These values are really used to draw texts in a control. 
        ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
        To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        RecalculateTextSettings updates the ResultingTextSettings."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Trimming: TextTrimming
    """TextTrimming: Specifies how the text is trimmed when it exceeds the edges of the text area in this control.
        This property sets or returns a value of the TTextTrimming type."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies the vertical alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed and loads the control presentation.
        FMX.StdCtrls.TPresentedTextControl.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
        Responds after the last constructor has executed and loads the control presentation.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Change(self, *args, **kwargs) -> Any:
        """Calls DoChanged when any of the styled text representation properties of the control changes."""
    def Create(self, AOwner: Component) -> None:
        """TPresentedTextControl.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TPresentedTextControl.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TPresentedTextControl.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ToString(self, *args, **kwargs) -> Any:
        '''Returns a string containing the class name.
        FMX.StdCtrls.TPresentedTextControl.ToString inherits from System.TObject.ToString. All content below this line refers to System.TObject.ToString.
        Returns a string containing the class name.
        By default, the ToString returns a string containing the class name of the instance that is being called. 
        For example, calling ToString on a TButton instance returns a string containing "TButton". 
        
        Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.'''
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PresentedVertScrollBox(CustomPresentedVertScrollBox):
    """Wrapper for Delphi TPresentedVertScrollBox"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoCalculateContentSize: bool
    """bool: Indicates that the size of the scrolling content is calculated automatically according to the size of the components in content.
        Otherwise, the value of the ContentSize property defines the content size."""
    AutoHide: BehaviorBoolean
    """BehaviorBoolean: Defines that scrollbars hide automatically when you scroll. AutoHide can be used to force the scrollbars to display."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    Bounces: BehaviorBoolean
    """BehaviorBoolean: Indicates if it is possible to scroll content abroad."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ContentSize: ScrollContentSize
    """ScrollContentSize: Current content size."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Defines that the control does not have reaction to Mouse-Wheel event."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    EnabledScroll: bool
    """bool: Enables or disables scrolling."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ScrollDirections: ScrollDirections
    """ScrollDirections: Defines the available scroll directions."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Defines scrollbars visibility."""
    ShowSizeGrip: bool
    """bool: Shows a small control in the right-bottom corner that represents the size of the changing control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ProgressBar(StyledControl):
    """Represents an animated progress bar indicator for general progress indication.
    Use a TProgressBar in applications where you need to inform the user about the progress of one or multiple tasks effectuated by your application. A TProgressBar control can display its progress (Value) in the range specified by Min and Max.
    
    Metropolis UI ProgressBar:
    
    When a task with an indefinite amount of time or operations is in progress, we recommend that you use a TAniIndicator to illustrate the progress."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Max: float
    """float: Specifies the maximum value for this progress bar. As you place a TProgressBar component on a form, the default value for the Max property is set to 100."""
    Min: float
    """float: Specifies the minimum value for this progress bar. The default value for the Min property is 0."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Orientation: Orientation
    """Orientation: Specifies the orientation (Horizontal or Vertical) for the progress bar."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Value: float
    """float: Specifies the current position of the progress bar.
        You can read Value to determine the progress from Min to Max. 
        Set a needed value for the Value property, and the progress bar will display a position between Min and Max. For example, when the process completes, set Value to Max so that it appears completely filled.
        By default, the Min and Max values of the progress bar are represented in percentage terms, where Min is 0 (0% complete) and Max is 100 (100% complete)."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed and loads the control presentation.
        FMX.StdCtrls.TProgressBar.AfterConstruction inherits from FMX.Controls.Presentation.TPresentedControl.AfterConstruction. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.AfterConstruction.
        Responds after the last constructor has executed and loads the control presentation.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TProgressBar.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TProgressBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TProgressBar.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ProgressColumn(Column):
    """Represents a column in a grid, whose cells show progress bars."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Max: float
    """float: Specifies the maximum value for all the progress cells in this column."""
    Min: float
    """float: Specifies the minimum value for all the progress cells in this column."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanEdit(self, *args, **kwargs) -> Any:
        """Returns True if the column can show a value editor or False otherwise.
        FMX.Grid.TProgressColumn.CanEdit inherits from FMX.Grid.TColumn.CanEdit. All content below this line refers to FMX.Grid.TColumn.CanEdit.
        Returns True if the column can show a value editor or False otherwise.
        
         See Also
        FMX.Grid.TColumn.EditingCancelled
        FMX.Grid.TColumn.EditingDone
        FMX.Grid.TColumn.EditorModified
        FMX.Grid.TColumn.PostEditorValue
        FMX.Grid.TColumn.RefreshEditor"""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TProgressColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TProgressColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def DefaultDrawCell(self, Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None:
        """TProgressColumn.DefaultDrawCell(Canvas: Canvas, Bounds: RectF, Row: int, Value: Value, State: GridDrawStates) -> None
        Draws the default cell background.
        FMX.Grid.TProgressColumn.DefaultDrawCell inherits from FMX.Grid.TColumn.DefaultDrawCell. All content below this line refers to FMX.Grid.TColumn.DefaultDrawCell.
        Draws the default cell background.
        DefaultDrawCell receives the following parameters:
        
        Canvas is the canvas where DefaultDrawCell paints the cell background.
        Bounds indicates the cell boundaries.
        Row is the row number.
        Value is the cell value.
        State is the drawing state of the cell.
        DrawCell calls DefaultDrawCell if Model.DefaultDrawing is True.
        
         See Also
        FMX.Grid.TColumn.DrawCell
        FMX.Grid.TColumn.BeforeDrawing
        FMX.Grid.TColumn.AfterDrawing"""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PrototypeBindSource(CustomPrototypeBindSource):
    """Wrapper for Delphi TPrototypeBindSource"""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation."""
    AutoEdit: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoPost: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    FieldDefs: GeneratorFieldDefs
    """GeneratorFieldDefs: Embarcadero Technologies does not currently have any additional information."""
    OnCreateAdapter: Callable[[Object,BindSourceAdapter],None]
    """Callable[[Object, BindSourceAdapter], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    RecordCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ScopeMappings: ScopeMappings
    """ScopeMappings: Specifies an owned collection of scope mappings.
        The ScopeMappings property specifies an owned collection whose elements are scope mappings. ScopeMappings are used to add name/value pairs that can be referenced by expressions that reference this source component."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class RadioButton(PresentedTextControl):
    """Represents a radio (option) button.
    TRadioButton, also called option button, presents a set of mutually exclusive choices. You can create individual radio buttons using TRadioButton or use a group to automatically arrange radio buttons into groups. You can group radio buttons to let the user select one from a limited set of choices.
    A selected radio button is displayed as a circle filled in the middle. When not selected, the radio button shows an empty circle. Assign the value True or False to the IsChecked property to change the visual state of the radio button.
    The Text property can be used to define an accelerator key to the control. The accelerator key behavior for TRadioButton is to select the radio button."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    GroupName: str
    """str: Specifies the name of the group this radio button is part of.
        Set the GroupName property to the name of the group this radio button belongs to. If multiple radio buttons are part of the same group, that is, all of them have the same GroupName, when you click one of them, it becomes selected, while the others in this group become cleared."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool: Specifies whether the default state of this radio button is selected or cleared.
        Set the IsChecked property to True to force this radio button's default state to be selected. The button comes back to its initial cleared state once you click it."""
    IsPressed: bool
    """bool: Reads the pressed state of this radio button.
        The IsPressed read-only property is True when this radio button is pressed, False otherwise."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TRadioButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TRadioButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TRadioButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def KeyDown(self, Key: int, KeyChar, Shift: ShiftState) -> None:
        """TRadioButton.KeyDown(Key: int, KeyChar: unicodechr(str), Shift: ShiftState) -> None
        Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
        FMX.StdCtrls.TRadioButton.KeyDown inherits from FMX.Controls.Presentation.TPresentedControl.KeyDown. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.KeyDown.
        Sends a PM_KEYDOWN message to the presentation layer through its presentation proxy when a key is pressed down while your presented control has the focus.
        The message includes a TKeyInfo record that contains the data of the parameters (AKey, AKeyChar, AShift).
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.PresentationProxy
        FMX.Presentation.Messages.TMessageSender.SendMessage
        FMX.Controls.Presentation.TKeyInfo
        FMX.Controls.TControl.KeyDown
        FMX.Forms.TCommonCustomForm.KeyDown
        FMX.Controls.Presentation.TPresentedControl.KeyUp"""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TRadioButton.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseDown event dispatcher. 
        FMX.StdCtrls.TRadioButton.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
        OnMouseDown event dispatcher. 
        A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:
        
        Button determines which mouse button is pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
        Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TRadioButton.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        OnMouseMove event dispatcher. 
        FMX.StdCtrls.TRadioButton.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
        OnMouseMove event dispatcher. 
        As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control's visual representation:
        
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TRadioButton.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseUp event dispatcher. 
        FMX.StdCtrls.TRadioButton.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
        OnMouseUp event dispatcher. 
        A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 
        
        Button determines which mouse button was previously pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TRadioButton.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        Sets a new Scene for the current control.
        FMX.StdCtrls.TRadioButton.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Rect:
    """wrapper for Delphi TRect type"""
    __hash__: ClassVar[None] = ...
    Bottom: Any
    """Provides access to the Bottom coordinate of a rectangle"""
    BottomRight: Any
    """Provides access to the BottomRight coordinate of a rectangle"""
    Left: Any
    """Provides access to the Left coordinate of a rectangle"""
    Right: Any
    """Provides access to the Right coordinate of a rectangle"""
    Top: Any
    """Provides access to the Top coordinate of a rectangle"""
    TopLeft: Any
    """Provides access to the TopLeft coordinate of a rectangle"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class RectF:
    """wrapper for Delphi FMX TRectF type"""
    __hash__: ClassVar[None] = ...
    Bottom: Any
    """Provides access to the bottom of a rectf"""
    Left: Any
    """Provides access to the left of a rectf"""
    Right: Any
    """Provides access to the right of a rectf"""
    Top: Any
    """Provides access to the top of a rectf"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Rectangle(Shape):
    """TRectangle defines 2D rectangles with customized corners. It inherits TControl and can be used in styles to construct controls.
    The CornerType, XRadius, and YRadius properties define how to customize shapes of rectangle corners:
    
    
    Corners specifies which corners to be customized.
    Notice that, if Corners is an empty set or any of the XRadius or YRadius properties is zero, then no corner shape customization is used.
    The rectangle size and position are defined by the following properties of the TRectangle object:
    
    The shape rectangle ShapeRect defines the initial size and position of the rectangle.
    You can use the rotation axis RotationCenter and rotation angle RotationAngle of the TRectangle object to rotate and move the rectangle.
    You can use the scaling factors of the TRectangle object to proportionally scale rectangle coordinates along local coordinate axes. Scaling moves the rectangle and changes its size.
    Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
    TRectangle draws the contour and fills the background with the Paint method. Paint uses the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    CornerType: CornerType
    """CornerType: Specifies the type of the corner shape's customization in the rectangle.
        Values of CornerType are defined in TCornerType. These Round, Bevel, InnerRound, and InnerLine values define the following types of corner shape customizations: 
        
        
        CornerType applies to corners specified in the Corners set.
        XRadius and YRadius specify the distance from a corner to the start point of the corner shape customization, on the horizontal and vertical sides. 
        
        Note: If Corners is an empty set or any of the XRadius and YRadius properties is zero, then no corner shape customization is used."""
    Corners: Corners
    """Corners: Specifies shapes of which corners in the TRectangle rectangle object are customized according to the CornerType, XRadius, and YRadius properties.
        By default, all four corners are customized. 
        Corners can contain a set of constants defined in the TCorner type: TopLeft, TopRight, BottomLeft, and BottomRight. Use the AllCorners constant to select all corners. 
        If Corners is an empty set or any of the XRadius and YRadius properties is zero, then no corner shape customization is used."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Sides: Sides
    """Sides: Specifies which sides of the TRectangle rectangle to display.
        A side is a rectangle boundary between two adjacent corners or end points of corner customizations. End points of corner customizations are defined by XRadius and YRadius. A corner customization applies to corners included into the Corners set.
        By default, all sides of the rectangle are displayed.
        Sides can contain a set of constants defined in TSide: Top, Left, Bottom, and Right. 
        Use the AllSides constant to select all sides.
        If Sides is empty, then no side is displayed."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    XRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the horizontal sides of TRectangle.
        During design time, the maximum possible value of XRadius is limited by the half of the smallest side.
        If XRadius=0, then no corner shape customization is used."""
    YRadius: float
    """float: Specifies the distance from a corner to the start point of the corner shape customization, on the vertical sides of TRectangle.
        During design time, the maximum possible value of YRadius is limited by the half of the smallest side.
        If YRadius=0, then no corner shape customization is used."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TRectangle.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TRectangle.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ResourceStream(CustomMemoryStream):
    """Wrapper for Delphi TResourceStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, Instance: int, ResName: str, ResType: PWideChar) -> None:
        """TResourceStream.Create(Instance: int, ResName: str, ResType: PWideChar) -> None"""
    def CreateFromID(self, Instance: int, ResID: int, ResType: PWideChar) -> None:
        """TResourceStream.CreateFromID(Instance: int, ResID: int, ResType: PWideChar) -> None"""
    def Destroy(self, *args, **kwargs) -> Any: ...
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TResourceStream.Write(Buffer, Count: int) -> int"""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class RoundRect(Shape):
    """TRoundRect defines 2D rectangles with rounded corners. It inherits TControl and can be used in styles to construct controls.
    The rectangle size and position are defined by the bounding rectangle of the TRoundRect object. You can use the scaling factors Scale of the TRoundRect object to proportionally change rectangle coordinates along local coordinate axes. This will move the rectangle and change its shape. The rotation axis RotationCenter and rotation angle RotationAngle of the TRoundRect object can be used to rotate the rectangle.
    
    Note: Scaling not only scales the shape of an object proportionally to the scaling factors. It also changes the thickness of the stroke that draws the contour proportionally to the scaling factor for each axis.
    The Corners property defines which rectangle corners are to be rounded. The Radius of the rounding is defined by the following formula:
    
    Radius := Min(RectHeight(GetShapeRect),RectWidth(GetShapeRect)) / 2;  
    
    TRoundRect draws the contour and fills the shape background with the Paint method. 
    Paint draws the contour and fills the background using the drawing pen and brush with the properties, color, and opacity defined by the Stroke and Fill properties of the TRoundRect object."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Corners: Corners
    """Corners: Specifies which corners in the TRoundRect object are to be rounded.
        The rounding radius is equal to the half of the smallest side.
        By default, all four corners are rounded.
        Corners is a set of TCorner values that specify which of the corners are rounded. 
        If Corners is an empty set, then no corner is rounded. 
        Use the AllCorners constant to select all corners."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TRoundRect.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner.
        FMX.Objects.TRoundRect.Create inherits from FMX.Objects.TShape.Create. All content below this line refers to FMX.Objects.TShape.Create.
        Creates an instance of TShape with the specified component as owner."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SaveDialog(OpenDialog):
    """Wrapper for Delphi TSaveDialog"""
    __hash__: ClassVar[None] = ...
    FileName: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TOpenDialog.Execute()
        Displays the dialog"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ScaledLayout(Control):
    """A FireMonkey scaled layout is a wrapper over TControl and acts like a layer for other objects with the possibility of scaling its content according to the physical dimensions of the layout.
    A scaled layout is a container for other graphical objects that can scale its contents as shown in the following image.
    
    The label and the button are scaled according to the dimensions of the form that contains the layer aligned as the client so that the layer occupies the entire surface."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    OriginalHeight: float
    """float: Specifies the original height of the scaled layout control. The original height represents the unscaled Y dimension of the scaled layout control."""
    OriginalWidth: float
    """float: Specifies the original width of the scaled layout control. The original width represents the unscaled X dimension of the scaled layout control."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TScaledLayout.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Layouts.TScaledLayout.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Layouts.TScaledLayout.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ScrollBar(StyledControl):
    """Represents a standard scroll bar that is used to scroll the contents of a window, form, or a control.
    TScrollBar adds a free-standing scroll bar to a form. Many controls have properties that add scroll bars that are an integral part of the control. However, TScrollBar allows controls that do not have integrated scroll bars or groupings of controls to be scrolled when the user manipulates the TScrollBar object."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Max: float
    """float: Specifies the maximum value of this scroll bar for the maximum position of the slider.
        Use the Max property to set a maximum value up to which the slider of this scroll bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100."""
    Min: float
    """float: Specifies the minimum value of this scroll bar for the minimum position of the slider.
        Use the Min property to set a minimum value down to which the slider of this scroll bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Orientation: Orientation
    """Orientation: Specifies the orientation of this scroll bar (left to right or bottom to top).
        Use the Orientation property to specify how this scroll bar will be displayed (left to right or bottom to top). Orientation can have one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        Vertical
        
        
        
        The scroll bar is rendered with the bottom-to-top orientation.
        
        
        
        
        Horizontal
        
        
        
        The scroll bar is rendered with the left-to-right orientation."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    SmallChange: float
    """float: Controls the number of positions this scroll bar's slider moves on each pressing of the min or max button.
        Use the SmallChange property to control the number of positions the slider of this scroll bar forwards or backwards in respect to pressing the max or min buttons.
        For instance, setting SmallChange to 10 causes each push of the max or min button make the slider move with exactly 10 positions forwards or backwards.
        
        Tip: If the current position of the slider (reflected by Value) is a number lower than SmallChange, then pressing the min button will bring Value to 0."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Value: float
    """float: Specifies the current value of this scroll bar.
        Set or get Value to specify or obtain the current value of this scroll bar. You can set Value programmatically or visually, at run time, with any value within the interval delimited by Min and Max."""
    ValueRange: ValueRange
    """ValueRange: Provides access to the Value value, to its Min and Max boundaries, and to the ViewportSize property."""
    ViewportSize: float
    """float: Specifies the size, in pixels, of the slider of this scroll bar.
        Use the ViewportSize property to specify the size of the viewport of this scroll bar, that is, the area, in pixels, of the slider of this scroll. As an example, the picture below shows two scroll bars, one with ViewportSize set to 0 and the other with ViewportSize set to 50.
        
        
        Tip: Changing the ViewportSize property does not affect the limits (Min or Max) of the Value of this scroll bar."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        FMX.StdCtrls.TScrollBar.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
        Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TScrollBar.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TScrollBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.StdCtrls.TScrollBar.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ScrollBox(CustomScrollBox):
    """Extends TCustomScrollBox declaring published properties.
    TScrollBox extends TCustomScrollBox declaring published properties. TScrollBox does not extend the base class with any new functionality.
    In difference to TFramedScrollBox, TScrollBox does not draw the edges (top, left, bottom, and right) and does not fill the control rectangle with any special color. Therefore, by default TScrollBox is not highlighted from the background of a parent control."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHide: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Content: ScrollContent
    """ScrollContent: Keeps an object that represents a scrollable content.
        A TScrollBox object uses a TScrollContent object in order to provide an area onto which you can place any other graphical components. Content keeps this TScrollContent object."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnHScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnVScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ShowSizeGrip: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SearchBox(Edit):
    """A search edit control.
    TSearchBox is an edit control that provides search capabilities such as filtering the result in the parent."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    Model: SearchBoxModel
    """SearchBoxModel: The data model representing the data used by the presentation of the current control.
        FMX.SearchBox.TSearchBox.Model inherits from FMX.Controls.Presentation.TPresentedControl.Model. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Model.
        The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns.
        
         See Also
        FMX.Controls.Model.TDataModel
        FMX.Controls.Presentation.TPresentedControl.Presentation
        FMX.Controls.Presentation.TPresentedControl.Create
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass"""
    OnFilter: Callable[[Object,str,str,bool],None]
    """Callable[[Object, str, str, bool], None]:"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSearchBox.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.SearchBox.TSearchBox.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Selection(Control):
    """TSelection defines 2D rectangle object that can be moved and resized. It inherits TControl and can be used in styles to construct controls.
    You can use scaling factors Scale of the TSelection object to proportionally change coordinates of a selection object's rectangle along local coordinate axes. Scaling moves the selection rectangle and change its size. The rotation axis RotationCenter and rotation angle RotationAngle of the selection object can also be used to modify the selection rectangle's size and position.
    The Paint method renders the TSelection image. Paint internally defines the properties of the drawing pen to draw the selection contour and the brush to fill the background depending on whether the control is enabled, the zone is hot, and other conditions. 
    To resize the TSelection rectangle you can use four grip controls. Grip controls appear as small circles at the selection rectangle corners when the mouse pointer hovers over the grip controls."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: int
    """int: Selection frame and handle's border color."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    GripSize: float
    """float: Defines the size of the grip controls used to resize the TSelection object."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HideSelection: bool
    """bool: Defines whether to hide the selection rectangle when the TSelection object is not selected.
        When HideSelection is True and the TSelection object is not selected, the rectangle and grip controls are invisible. 
        
        See also
        FMX.Objects.TSelection.GripSize"""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    HotHandle: Selection.TGrabHandle
    """Selection.TGrabHandle: It grips the handle where the mouse is hovered."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MinSize: int
    """int: Defines the minimum possible values for the width and height of the TSelection object."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTrack: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentBounds: bool
    """bool: Defines whether the shape of the TSelection object should be inside the boundaries of the parent control.
        When ParentBounds is True, the shape of the TSelection object cannot be moved outside the boundaries of the parent control."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Proportional: bool
    """bool: Defines whether the width/height proportion should be kept during the resizing of the TSelection object."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHandles: bool
    """bool: It indicates the visibility of the handles."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TSelection.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Objects.TSelection.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Objects.TSelection.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DoMouseLeave(self, *args, **kwargs) -> Any:
        """DoMouseLeave is called automatically when the mouse pointer leaves the TSelection object. 
        DoMouseLeave of the TSelection object calls the inherited FMX.Controls.TControl.DoMouseLeave method which starts animation by calling StartTriggerAnimation, applies effects by calling ApplyTriggerEffect, and calls the FMX.Controls.TControl.OnMouseLeave event handler. Then DoMouseLeave frees the grip controls. Finally, DoMouseLeave initializes the TSelection shape repaint operation.
        Override the protected DoMouseLeave method to provide other responses when the mouse pointer leaves the TSelection object."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TSelection.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        Handles the pressing of a mouse button inside the TSelection object. 
        MouseDown calls  FMX.Controls.TControl.MouseDown, checks whether any of the grip controls (small circles in the selection rectangular corners) are pointed to resize the selection shape and activate resizing by moving this control or activates moving of the TSelection object by moving the mouse pointer. 
        MouseDown has the following parameters:  
        
        Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
        Shift--belongs to the TShiftState type and passes additional information such as: whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were pressed when the mouse button was clicked; whether the mouse button was double-clicked (ssDouble).
        X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
        The TForm form, owner of the TSelection object, calls MouseDown in response to mouse-down messages.
        Override the public MouseDown method to provide a customized response when a mouse button is pressed when the mouse pointer is over the TSelection object."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TSelection.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        Handles moving of the mouse pointer over a TSelection object.
        As the mouse pointer moves over a TSelection object, this method is called repeatedly. It is called each time with the new mouse pointer coordinates that reflect the continuous path of the mouse pointer.
        
        Parameters
        MouseMove has the following parameters:  
        
        Shift--belongs to the TShiftState type and passes additional information, such as: which mouse button was pressed (ssLeft--left, ssRight--right) or whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were pressed when the mouse button was clicked.
        X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
        Functionality
        MouseMove executes the following operations:
        
        MouseMove calls the inherited FMX.Controls.TControl.MouseMove method. Then:
        If the mouse button is not pressed down:
        Check whether the mouse pointer hovers over a grip control:
        When the mouse pointer moves over a grip control--shows the resizing arrow on the grip control over which the mouse pointer is moving.
        When the mouse pointer moves outside a grip control--clears the resizing arrows, if any.
        Force repaint of the selection shape.
        If the left mouse button is pressed inside the TSelection object:
        Moves the shape of the TSelection object on the vector with the start point having the coordinates where the mouse button was pressed and the end point having the current coordinates of the mouse.
        If ParentBounds is True, the TSelection object shape is moved inside the boundaries of the parent control.
        If ParentBounds is False, the TSelection object shape is moved inside the boundaries of the current TCanvas object.
        Calls the customer event handler of the OnTrack event.
        If the left mouse button is pressed down on one of the grip controls of the TSelection object:
        The shape of the TSelection object is resized to reflect the moving of the selected grip control.
        If ParentBounds is True, the TSelection object shape is resized to fit the boundaries of the parent control.
        If ParentBounds is False, the TSelection object shape is resized to fit the boundaries of the current TCanvas object.
        If Proportional is True, the object shape is resized keeping the Width/Height proportion.
        Call the customer event handler of the OnTrack event.
        Force the repaint of the selection shape.
        
        Override the public MouseMove method to provide a customized response when the mouse pointer is moved over the TSelection object."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TSelection.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        Handles the release of a mouse button pressed inside the TSelection object. 
        MouseUp calls the inherited FMX.Controls.TControl.MouseUp. If the TSelection object is being moved or resized by the mouse, MouseUp calls the OnChange event handler, and then stops moving or resizing by the mouse.   
        MouseUp has the following parameters:  
        
        Button--belongs to the TMouseButton type and specifies the pressed mouse button: mbLeft--left, mbRight--right, or mbMiddle--middle.
        Shift--belongs to the TShiftState type and passes additional information, such as whether shift keys (ssShift--SHIFT, ssCtrl--CTRL, or ssAlt--ALT) were down when the pressed mouse button was released.
        X and Y--are the local pixel coordinates of the mouse pointer within the TSelection object.
        The TForm form (owner of the TSelection object) calls MouseUp in response to mouse-up messages.
        Override the public MouseUp method to provide a customized response if the mouse button is released when the mouse pointer is over the TSelection object."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TSelection.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        FMX.Objects.TSelection.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SelectionPoint(StyledControl):
    """TSelectionPoint defines a 2D point object that can be moved. It inherits TControl and can be used in styles to create controls.
    The TSelectionPoint class implements operations of moving of a 2D point object with a mouse or another pointing device. 
    The behavior of selection point objects depends upon the existence of a corresponding style-resource in an application style book: 
    
    When an application style book does not contain a style-resource for selection points:
    A selection point in this application is drawn as a circle having a radius equal to GripSize.
    The used GripSize is truncated to 1<= GripSize<=20.
    A selection point is drawn as a white circle having the blue circumference.
    When a selection point is selected, its circle is shown red.
    To select a selection point, place the mouse pointer over the circle shape or the  bounds rectangle of the selection point (having the Width and Height dimensions).
    When an application style book contains a style-resource for selection points, then all selection point properties are loaded from the style-resource; property values are set in the Form Designer or are ignored programmatically. On some platforms, selection points use predefined platform-specific values. For example, on some mobile platforms GripSize is 16 or 17 and this value cannot be changed programmatically.
    Notice that the GripCenter property has the following implementation. The X and Y values of GripCenter define an offset between the mouse pointer position and the shown selection point when the pressed mouse pointer is moved.  
    You can use scaling factors Scale of the TSelectionPoint object to proportionally change a selection point and a grip sizes along coordinate axes. The rotation axis RotationCenter and rotation angle RotationAngle of the selection point object can also be used to modify the position of the selection point."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    GripCenter: Position
    """Position: Defines an offset between the position of the mouse pointer and the shown selection point object when the pressed mouse pointer is moved.
        The X and Y values of GripCenter define an offset between the mouse pointer position and the shown selection point object when the pressed mouse pointer is moved.
        By default, X and Y equal 0."""
    GripSize: float
    """float: Defines the radius of the shown selection point object.
        When an application style book does not contain a style-resource for selection points, a selection point in this application is drawn as a circle having radius equal to GripSize. The used GripSize is truncated to 1<= GripSize<=20. When an application style book contains a style-resource for selection points, then all selection point properties are loaded from the style-resource; property values set in the Form Designer or programmatically are ignored. Under some platforms, selection points use predefined platform-specific values. For example, on some mobile platforms GripSize is 16 or 17 and this value cannot be changed programmatically."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTrack: Callable[[Object,float,float],None]
    """Callable[[Object, float, float], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentBounds: bool
    """bool: Defines whether the shape of the TSelectionPoint object should be within the boundaries of the parent control.
        When ParentBounds is True, the shape of the TSelectionPoint object cannot be moved outside the boundaries of the parent control."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSelectionPoint.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Objects.TSelectionPoint.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Objects.TSelectionPoint.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def PointInObjectLocal(self, X: float, Y: float) -> bool:
        """TSelectionPoint.PointInObjectLocal(X: float, Y: float) -> bool
        Checks whether the point specified by local coordinates belongs to the control area.
        FMX.Objects.TSelectionPoint.PointInObjectLocal inherits from FMX.Controls.TControl.PointInObjectLocal. All content below this line refers to FMX.Controls.TControl.PointInObjectLocal.
        Checks whether the point specified by local coordinates belongs to the control area.
        PointInObjectLocal returns True if the specified point belongs to the control area, and False otherwise. 
        The X and Y are the local coordinates of the point to be checked (compare with PointInObject):
        
        X is the X coordinate.
        Y is the Y coordinate.
        The local coordinates of the upper-left corner of the control rectangle are (0,0), and the local coordinates of the lower-right corner are (Width, Height). 
        The points of the control boundary specified by BoundsRect belong to the control and PointInObjectLocal returns True for them.
        If a control supports the Touch property, the control area can be optionally inflated on the values specified by the TouchTargetExpansion property. TouchTargetExpansion keeps four optional parameters representing the expansion for the four sides of the control in pixels (Bottom, Left, Right, and Top). 
        The dclasses can change the 'control area' definition. For example:
        
        The FMX.Objects.TSelection class extends the 'control area' definition relative to BoundsRect. FMX.Objects.TSelection.PointInObjectLocal also returns True if the point belongs to any of small rectangles of the four grip controls used to manage the selection shape. The rectangles of the grip controls are rectangles surrounding the four corners of the TSelection rectangle. The Width and Height of these rectangles are equal to 2 * GripSize. For example, the grip control's rectangle of the upper-right corner UR_Corner of TSelection is defined by the following corners:
        (UR_Corner.Top - GripSize, UR_Corner.Right - GripSize)--upper-left corner of the grip.
        (UR_Corner.Top + GripSize, UR_Corner.Right + GripSize)--lower-right corner of the grip.
        FMX.Objects.TSelectionPoint.PointInObjectLocal returns True if the specified point belongs to the rectangle of the grip control corresponding to the TSelectionPoint object, and False otherwise."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Shape(Control):
    """The base class for 2D graphic primitives--TLines, TRectangles, TPaths, and others. All these primitives inherit TControl and can be used in styles to construct controls. 
    TShape is the ancestor class to most other classes defined in the Objects unit. It defines the common behavior--methods and properties--for 2D graphic primitives. TShape objects cannot be used as stand-alone 2D components."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Fill: Brush
    """Brush: Determines the color and pattern used to fill the shape background.
        The value of Fill is an FMX.Graphics.TBrush object. It can define the gradient, brush pattern, brush color, opacity, and other parameters to fill the shape background."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    ShapeRect: RectF
    """RectF: Specifies the rectangle for drawing the shape.
        The coordinates of the upper-left corner of the rectangle are (0,0), and the coordinates of the lower-right corner are (Width, Height)."""
    Stroke: StrokeBrush
    """StrokeBrush: Determines the color and pattern of the drawing pen used to draw lines and shape contours of the graphical primitives.
        The value of Stroke is an FMX.Graphics.TStrokeBrush object. To customize the outline pen, change the Thickness, Cap, Dash, and Join properties of the TStrokeBrush object."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TShape.Create(AOwner: Component) -> None
        Creates an instance of TShape with the specified component as owner."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the object instance and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the object instance is not nil before calling Destroy."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Size:
    """wrapper for Delphi TSize type"""
    __hash__: ClassVar[None] = ...
    cx: Any
    """Provides access to the width of the size"""
    cy: Any
    """Provides access to the height of the size"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SizeF:
    """wrapper for Delphi FMX TSizeF type"""
    __hash__: ClassVar[None] = ...
    Height: Any
    """Provides access to the height of a sizef"""
    Width: Any
    """Provides access to the width of a sizef"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SizeGrip(StyledControl):
    """Represents a graphical control used to dynamically resize FireMonkey forms.
    Use a TSizeGrip component in a FireMonkey form  to add a custom-placed size grip used to dynamically resize the form.
    
    It is better that you position this size grip control in the bottom-rightmost position of the form, for consistency. If your FireMonkey form already contains a TStatusBar component, there is no need to add a TSizeGrip, because the status bar can display the size grip for your resizable form."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSizeGrip.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TSizeGrip.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SmallScrollBar(ScrollBar):
    """Represents a variation of a standard scroll bar.
    A TSmallScrollBar component is a trimmed-down standard TScrollBar without the min and max buttons. Otherwise the behavior is the same."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSmallScrollBar.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TSmallScrollBar.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SpeedButton(CustomButton):
    """Represents a push button that contains a text caption, for usage in various toolbars that you might employ into your applications.
    A TSpeedButton is a general-purpose push button for use in an application's toolbar. These buttons can be enabled, disabled, pressed, and can respond to control keys such as ESCAPE and ENTER.
    These speed buttons can also have a modal result attached to them.
    Their distinctive appearance differentiates them from other buttons. Also, speed buttons cannot receive TAB focus."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when displaying the text."""
    GroupName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IconTintColor: int
    """int: Allows you to apply a tint to a button icon. 
        This property is a value of the TAlphaColor type.
        
        Note: Some buttons might not have the tint support. In the Object Inspector, the IDE automatically displays/hides the IconTintColor property as appropriate when you change the button's StyleLookup property. Currently, the IconTintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms."""
    IconTintObject: IintedObject
    """IintedObject: Embarcadero Technologies does not currently have any additional information."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    IsPressed: bool
    """bool: Specifies whether the default state of this button is pressed or not.
        Set the IsPressed property to True in order to force this button's default state to be pressed. The button comes back to its initial unpressed state once you click it.
        
        Tip: Setting the IsPressed property only has an effect if the StaysPressed property is set to True."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    ModalResult: int
    '''int: Determines whether and how the button closes its (modal) parent form.
        Setting the ModalResult property of a button is an easy way to make clicking the button to close the parent modal form. When a button is clicked, the ModalResult property of its parent form is set to the same value as the ModalResult property of a button.
        For example, if a dialog box has OK and Cancel buttons, their ModalResult properties could be set at design time to mrOk and mrCancel, respectively. At run time, clicking the OK button changes the ModalResult property of the dialog box to mrOk, and clicking the Cancel button changes the ModalResult property of the dialog box to mrCancel. Unless further processing is required, no OnClick event handlers are required for the buttons.
        The following table lists the constants defined in the System.UITypes unit to be used for the ModalResult property of the TModalResult type.
        
        
        
        Constant
        
        Value
        
        Meaning
        
        
        
        mrNone
        
        
        
        0
        
        
        
        None. Used as a default value before the user exits.
        
        
        
        
        mrOk
        
        
        
        idOK = 1
        
        
        
        The user exited with the OK button.
        
        
        
        
        mrCancel
        
        
        
        idCancel = 2
        
        
        
        The user exited with the CANCEL button.
        
        
        
        
        mrAbort
        
        
        
        idAbort = 3
        
        
        
        The user exited with the ABORT button.
        
        
        
        
        mrRetry
        
        
        
        idRetry = 4
        
        
        
        The user exited with the RETRY button.
        
        
        
        
        mrIgnore
        
        
        
        idIgnore = 5
        
        
        
        The user exited with the IGNORE button.
        
        
        
        
        mrYes
        
        
        
        idYes = 6
        
        
        
        The user exited with the YES button.
        
        
        
        
        mrNo
        
        
        
        idNo = 7
        
        
        
        The user exited with the NO button.
        
        
        
        
        mrClose
        
        
        
        idClose = 8
        
        
        
        The user exited with the CLOSE button.
        
        
        
        
        mrHelp
        
        
        
        idHelp = 9
        
        
        
        The user exited with the HELP button.
        
        
        
        
        mrTryAgain
        
        
        
        idTryAgain = 10
        
        
        
        The user exited with the TRY AGAIN button.
        
        
        
        
        mrContinue
        
        
        
        idContinue = 11
        
        
        
        The user exited with the CONTINUE button.
        
        
        
        
        mrAll
        
        
        
        mrContinue + 1 (12 or $C)
        
        
        
        The user exited with the ALL button.
        
        
        
        
        mrNoToAll
        
        
        
        mrAll +1 (13 or $D)
        
        
        
        The user exited with the NO TO ALL button.
        
        
        
        
        mrYesToAll
        
        
        
        mrNoToAll +1 (14 or $E)
        
        
        
        The user exited with the YES TO ALL button.
        
        
        You can check a ModalResult value using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions, and use the StripAllFromResult function to convert ModalResult values that refer to "ALL" buttons to identifying values corresponding to simple buttons (Ok, No, or Yes).'''
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RepeatClick: bool
    """bool: Specifies whether to automatically repeat the button click after a preset time.
        Set the RepeatClick property to True to make the button automatically repeat the clicking event, thus executing its OnClick event cyclically, after a preset time has passed since the last OnClick execution.
        The timer interval starts with 500 milliseconds for the first wait and then moves to 100 milliseconds per wait cycle. This interval cannot be modified by the user.
        Each time 100 milliseconds pass, DoRepeatDelayTimer is executed. DoRepeatDelayTimer internally calls the DoRepeatTimer method to perform the button's OnClick event."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StaysPressed: bool
    """bool: Specifies whether this button remains in a pressed state once you click it.
        Set the StaysPressed property to True to force this button to remain in a pressed state once you click it. The button comes back to its initial depressed state once you click it again.
        If StaysPressed is set to False, then this button behaves like a standard push button that comes back to its initial state once you release the mouse button over its surface."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    """str: Specifies the text that will be displayed over the surface of this control.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters."""
    TextAlign: TextAlign
    """TextAlign: Specifies the horizontal alignment of the text in this control.
        This property can take values of the TTextAlign enumeration."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TintColor: int
    """int: Allows you to apply a tint to a button component. 
        This property is a value of the TAlphaColor type.
        
        Note: Some buttons might not have the tint support. In the Object Inspector, the RAD Studio IDE automatically displays/hides the TintColor property when you change the button's StyleLookup property. Currently, the TintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms."""
    TintObject: IintedObject
    """IintedObject: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Trimming: TextTrimming
    """TextTrimming: Specifies how the text is trimmed when it exceeds the edges of the text area in this control.
        This property sets or returns a value of the TTextTrimming type."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether to wrap the text inside the control when the text length exceeds the text area width."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSpeedButton.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TSpeedButton.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TPresentedControl.
        FMX.StdCtrls.TSpeedButton.Destroy inherits from FMX.Controls.Presentation.TPresentedControl.Destroy. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Destroy.
        Destroys this instance of TPresentedControl.
        
         See Also
        FMX.Controls.Presentation.TPresentedControl.Create"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SpinBox(CustomEditBox):
    """A special presented edit box equipped with buttons to increment or decrement the displayed numeric value.
    TSpinBox is a special edit box that can display only numerical values and is equipped with the Increase and Decrease buttons for incrementing or decrementing the displayed value."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Caret: CustomCaret
    """CustomCaret: Represents the caret of the control.
        Caret is of type TCaret."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Increment: float
    """float: Specifies the numerical value that will be used as an increment or decrement factor for this spin box.
        For instance, if you set the Increment value to 5, then pressing the plus (increment) button will increase the display value by 5. Pressing the minus (decrement) button will decrease the display value by 5.
        However, if, for instance, Value is 4, Increment is 5, and Min is 0 and you press the minus (decrement) button, the value will become 0. In a similar manner, if, for instance, Value is 8, Increment is 5, and Max is 10 and you press the plus (increment) button, the value will become 10."""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType: Determines the type of the virtual keyboard.
        Set KeyboardType to determine the type of virtual keyboard this edit is to use. Possible values for the KeyboardType property are Alphabet, Default, EmailAddress, NamePhonePad, and so on (values are selectable in the Object Inspector and are described in FMX.Types.TVirtualKeyboardType). 
        Keyboard types are illustrated in the Mobile Tutorial: Using the Web Browser Component (iOS and Android).
        
        Note: On Android, the Alphabet keyboard type has no word completion or word suggestions. The keyboard looks the same as the Default keyboard, but without suggestions."""
    KillFocusByReturn: bool
    """bool: Specifies whether to hide the virtual keyboard by clicking the Return key.
        When KillFocusByReturn is True, clicking the Return key hides the virtual keyboard."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPresentationNameChoosing: Callable[[Object,str],None]
    """Callable[[Object, str], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTyping: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Determines whether you can change the text of this edit control.
        To prevent the contents of the edit control from being edited, set the ReadOnly property to True. Set ReadOnly to False to allow the contents of the edit control to be edited.
        Setting ReadOnly to True ensures that the text is not altered, while still allowing you to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    RepeatClick: bool
    """bool: Determines whether the TSpinBox does several clicks when the user keeps the button held down. 
        When RepeatClick is True, the user can hold the button down to do several clicks until the button is released.
        By default the RepeatClick property is set to False."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how this edit control  displays the text in terms of horizontal alignment. TextAlign can have one of the following, defined in TTextAlign, values:
        
        Center (default) aligns the text at the middle of the edit control.
        Leading aligns the text at the leftmost position inside the edit control.
        Trailing aligns the text at the rightmost position inside the edit control.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Splitter(StyledControl):
    """TSplitter divides the client area of a FireMonkey form into resizable panes.
    Add a splitter to a form between two aligned controls to allow users to resize the controls at run time. The splitter sits between a control aligned to one edge of the form and the controls that fill up the rest of the client area. Give the splitter the same alignment as the control that is anchored to the edge of the form. When the user moves the splitter, it resizes the anchored control. This, in turn, changes the client area of the form, and the controls that fill up the rest of the client area resize accordingly.
    Use each control on the form as a separate pane. After each pane is placed, place a splitter with the same alignment to allow that pane to be resized. The last pane to be placed on the form should be client-aligned, so that it resizes automatically to fill up the remaining space after all other panes are resized."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    MinSize: float
    """float: Specifies the minimum size, in pixels, of the controls that are being split in case of sliding the splitter to the maximum of one of the left, right, top, or bottom margins.
        Use MinSize to set the minimum width or height of the controls that are being split using this splitter."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowGrip: bool
    """bool: Specifies whether to show the grip control of the  TSplitter.
        Set the  ShowGrip property to False to hide the grip control from the  TSplitter component. The default value is True so the  TSplitter shows the grip by default."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TSplitter.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TSplitter.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TSplitter.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseDown event dispatcher. 
        FMX.StdCtrls.TSplitter.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
        OnMouseDown event dispatcher. 
        A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:
        
        Button determines which mouse button is pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
        Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TSplitter.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        OnMouseMove event dispatcher. 
        FMX.StdCtrls.TSplitter.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
        OnMouseMove event dispatcher. 
        As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control's visual representation:
        
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TSplitter.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseUp event dispatcher. 
        FMX.StdCtrls.TSplitter.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
        OnMouseUp event dispatcher. 
        A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 
        
        Button determines which mouse button was previously pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StatusBar(StyledControl):
    """Represents a status bar component for use in FireMonkey forms.
    The status bar is usually aligned at the bottom of a form, and displays information about an application as it runs. A status bar can display a size grip, so if your form is sizable, there is no need to add a TSizeGrip component as long as you have a status bar already.
    The status bar can also intercept hints. See Using Hints to Show Contextual Help in a FireMonkey Application for more information on how to use hints."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHint: bool
    """bool: Indicates whether the OnHint event is enabled.
        Set this property to False to disable the OnHint event."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnHint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowSizeGrip: bool
    """bool: Specifies whether the status bar displays its size grip or not."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TStatusBar.Create(AOwner: Component) -> None
        Creates an instance of the TStatusBar class and places a status bar component on the form."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Stream(Object):
    """Wrapper for Delphi TStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Position: int
    """int:"""
    Size: int
    """int:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CopyFrom(self, Source: Stream, Count: int, BufferSize: int) -> int:
        """TStream.CopyFrom(Source: Stream, Count: int, BufferSize: int) -> int"""
    def FixupResourceHeader(self, FixupInfo: int) -> None:
        """TStream.FixupResourceHeader(FixupInfo: int) -> None"""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TStream.Read(Buffer, Count: int) -> int"""
    def Read64(self, Buffer: tuple, Offset: int, Count: int) -> int:
        """TStream.Read64(Buffer: tuple, Offset: int, Count: int) -> int"""
    def ReadBuffer(self, Buffer, Count: int) -> None:
        """TStream.ReadBuffer(Buffer, Count: int) -> None"""
    def ReadBufferData(self, Buffer: bool) -> None:
        """TStream.ReadBufferData(Buffer: bool) -> None"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadComponent(self, Instance: Component) -> Component:
        """TStream.ReadComponent(Instance: Component) -> Component"""
    def ReadComponentRes(self, Instance: Component) -> Component:
        """TStream.ReadComponentRes(Instance: Component) -> Component"""
    def ReadData(self, Buffer: Pointer, Count: int) -> int:
        """TStream.ReadData(Buffer: Pointer, Count: int) -> int"""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadResHeader(self, *args, **kwargs) -> Any: ...
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: int) -> int:
        """TStream.Seek(Offset: int, Origin: int) -> int"""
    def Seek32(self, Offset: int, Origin: SeekOrigin) -> int:
        """TStream.Seek32(Offset: int, Origin: SeekOrigin) -> int"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TStream.Write(Buffer, Count: int) -> int"""
    def Write64(self, Buffer: tuple, Offset: int, Count: int) -> int:
        """TStream.Write64(Buffer: tuple, Offset: int, Count: int) -> int"""
    def WriteBuffer(self, Buffer, Count: int) -> None:
        """TStream.WriteBuffer(Buffer, Count: int) -> None"""
    def WriteBufferData(self, Buffer: int, Count: int) -> None:
        """TStream.WriteBufferData(Buffer: int, Count: int) -> None"""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteComponent(self, Instance: Component) -> None:
        """TStream.WriteComponent(Instance: Component) -> None"""
    def WriteComponentRes(self, ResName: str, Instance: Component) -> None:
        """TStream.WriteComponentRes(ResName: str, Instance: Component) -> None"""
    def WriteData(self, Buffer: tuple, Count: int) -> int:
        """TStream.WriteData(Buffer: tuple, Count: int) -> int"""
    def WriteDescendent(self, Instance: Component, Ancestor: Component) -> None:
        """TStream.WriteDescendent(Instance: Component, Ancestor: Component) -> None"""
    def WriteDescendentRes(self, ResName: str, Instance: Component, Ancestor: Component) -> None:
        """TStream.WriteDescendentRes(ResName: str, Instance: Component, Ancestor: Component) -> None"""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteResourceHeader(self, ResName: str, FixupInfo: int) -> None:
        """TStream.WriteResourceHeader(ResName: str, FixupInfo: int) -> None"""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StringColumn(Column):
    """Wrapper for Delphi TStringColumn"""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StringGrid(CustomGrid):
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    Cells: str
    """str:"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultDrawing: bool
    """bool: Determines whether cells are drawn using the default drawing method (True) or using a user-defined drawing method (False)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Specifies the list of images associated with this grid control. 
        Images from the Images collection can be shown in cells of the TGlyphColumn type column."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Model: StringGridModel
    """StringGridModel: The data model representing the data used by the presentation of the current control.
        The constructor of your presented control creates a data model for your presented control. The class of the data model is the class that DefineModelClass returns."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCellClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnCellDblClick: Callable[[Column,int],None]
    """Callable[[Column, int], None]:"""
    OnColumnMoved: Callable[[Column,int,int],None]
    """Callable[[Column, int, int], None]:"""
    OnCreateCustomEditor: Callable[[Object,Column,StyledControl],None]
    """Callable[[Object, Column, StyledControl], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnDrawColumnBackground: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnCell: Callable[[Object,Canvas,Column,RectF,int,Value,GridDrawStates],None]
    """Callable[[Object, Canvas, Column, RectF, int, Value, GridDrawStates], None]:"""
    OnDrawColumnHeader: Callable[[Object,Canvas,Column,RectF],None]
    """Callable[[Object, Canvas, Column, RectF], None]:"""
    OnEditingDone: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnHeaderClick: Callable[[Column],None]
    """Callable[[Column], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectCell: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Options: GridOptions
    """GridOptions: Defines how grid controls look like and how they behave."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool: Specifies whether the cells in this grid can be modified or not.
        Use ReadOnly at run time to determine whether the cells in this grid can be edited. If ReadOnly is True, then you can only read and view the contents of the cells without the ability to affect the grid in any way."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    RowCount: int
    """int: Specifies the number of rows in the grid.
        The value of RowCount includes the scrollable rows in the grid, but not the fixed row with the headers.
        
        Read RowCount to determine the number of rows in the grid.
        Set RowCount to add or delete rows at the bottom of the grid."""
    RowHeight: float
    """float: Specifies the height of each row of this grid, in pixels.
        Read RowHeight to determine the size of each row in the grid. If the underlying grid is too tall to appear in the control, then the user must scroll to see the entire content of the grid."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StringStream(BytesStream):
    """Wrapper for Delphi TStringStream"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    DataString: str
    """str:"""
    Encoding: Encoding
    """Encoding:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, *args, **kwargs) -> Any: ...
    def Destroy(self, *args, **kwargs) -> Any: ...
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Strings(Persistent):
    """TStrings is the base class for objects that represent a list of strings.
    Derive a class from TStrings to store and manipulate a list of strings. TStrings contains abstract or, in C++ terminology, pure virtual methods and should not be directly instantiated.
    Descendants of TStrings can represent several individual strings, such as the individual lines that appear in a list box. Some objects use descendants of TStrings to represent one long body of text so that it can be manipulated in smaller chunks.
    TStrings introduces many properties and methods to:
    
    Add or delete strings at specified positions in the list.
    Rearrange the strings in the list.
    Access the string at a particular location.
    Read the strings from or write the strings to a file or stream.
    Associate an object with each string in the list.
    Store and retrieve strings as name-value pairs.
    For an explanation of name-value pairs, refer to the NameValueSeparator property."""
    __hash__: ClassVar[None] = ...
    Capacity: Any
    """Indicates the number of strings the TStrings object can hold."""
    CommaText: str
    '''str: Lists the strings in the TStrings object in a single comma-delimited string.
        Use CommaText to get or set all the strings in the TStrings object in a single comma-delimited string. The single comma-delimited string format is also known as the system data format (SDF).
        When retrieving CommaText, any string in the list that include spaces, commas or double quotes will be contained in double quotes, and any double quotes in a string will be repeated. For example, if the list contains the following strings:
        
        Stri,ng1
        Stri"ng2
        String 3
        String4
        
        CommaText will return: 
        
        "Stri,ng1","Stri""ng2","String 3",String4
        
        When assigning CommaText, the value is parsed as SDF formatted text. For SDF format, strings are separated by commas or spaces, and optionally enclosed in double quotes. Double quote marks that are part of the string are repeated to distinguish them from the quotes that surround the string. Spaces and commas that are not contained within double quote marks are delimiters. Two commas next to each other will indicate an empty string, but spaces that appear next to another delimiter are ignored. For example, suppose CommaText is set to:
        
        "Stri,ng 1","Stri""ng 2",String 3,String4
        
        The list will then contain:
        
        Stri,ng 1
        Stri"ng 2
        String
        3
        String4
        
        Note: CommaText is the same as the DelimitedText property with a delimiter of \',\' and a quote character of \'"\'.
        Including a trailing comma in the source string causes a blank item to be included in the string list. For example, if CommaText is set to
        
        "String1,String2,String3, "
        
        the string list will contain
        
        String1
        String2
        String3
        <Blank>'''
    Count: int
    """int: Introduces an abstract property to represent the number of strings in the list.
        Descendants of TStrings implement a Count property to indicate the number of strings in the list.
        Use the Count property when iterating over all the strings in the list, or when trying to locate the position of a string relative to the last string in the list."""
    DefaultEncoding: Encoding
    """Encoding: The default encoding for the current object.
        DefaultEncoding is used when the nil encoding is specified in a call to LoadFromStream or SaveToStream. 
        By default, DefaultEncoding is set to Default. The user can change DefaultEncoding if another default encoding is desired for LoadFromStream or SaveToStream."""
    DelimitedText: str
    '''str: Represents all the strings in the TStrings object as a single delimited string.
        Use DelimitedText to get or set all the strings in the TStrings object in a single string, separated by the character specified by the Delimiter property. 
        When retrieving DelimitedText, any string in the list that includes spaces or the delimiter and quotation marks characters specified in the Delimiter and QuoteChar properties will be surrounded (before and after) by the quotation mark character (QuoteChar). In addition, any QuoteChar character contained in an individual string will be repeated. 
        When retrieving DelimitedText, the resulting value delimits individual strings in two ways: each string is surrounded (before and after) by the quotation marks character specified by the QuoteChar property. In addition, individual strings are separated by the character specified by the Delimiter property. 
        When assigning DelimitedText, individual strings must be separated using Delimiter marks, and optionally enclosed in QuoteChar characters. 
        When assigning DelimitedText, the value is parsed as SDF formatted text. For SDF format, strings are separated by Delimiter characters or spaces, and optionally enclosed in QuoteChar characters. QuoteChar marks that are part of the string are repeated to distinguish them from the QuoteChar characters that surround the string. Spaces and Delimiter characters that are not contained within QuoteChar marks are delimiters. Two Delimiter characters next to each other will indicate an empty string, but spaces that appear next to another Delimiter character are ignored. 
        If StrictDelimiter is set to False, the space character is also interpreted as a delimiter, regardless of the value of Delimiter. This is not true when the space character occurs between quotation marks. 
        
        Note: CommaText is the same as the DelimitedText property when Delimiter is \',\' and QuoteChar is \'"\'. Including a trailing Delimiter in the source string causes a blank item to be included in the string list.'''
    Delimiter: Any
    """unicodechr(str): Specifies the delimiter used by the DelimitedText property.
        Use Delimiter to get or set the delimiter used by the DelimitedText property. DelimitedText represents all of the strings in the TStrings object as a single string, with individual strings separated by the character that is the value of Delimiter.
        The default delimiter is represented by comma (,)."""
    Encoding: Encoding
    """Encoding: Character encoding determined during reading from a stream or file.
        Encoding is a read-only property that contains the value of the character encoding detected when the LoadFromStream or LoadFromFile methods are called. If a file or stream does not contain a BOM (the encoding value cannot be detected) then Encoding is set to the value specified in the DefaultEncoding property.
        Encoding is used in the SaveToStream and SaveToFile methods."""
    KeyNames: str
    """str:"""
    LineBreak: str
    """str: Defines line-break characters.
        The LineBreak property is used internally in TStrings to set the string terminator characters. Set or read the LineBreak property to determine the string terminator characters in multistring output operations. 
        For example, the GetText method returns a long string containing all TStrings strings, each of which is terminated by the LineBreak value.
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on Android, Linux, macOS and iOS it is just a line feed (#10)."""
    NameValueSeparator: Any
    """unicodechr(str): Indicates the character used to separate names from values.
        Strings that contain the NameValueSeparator character are considered name-value pairs. NameValueSeparator defaults to the equal sign (=). TStrings defines various methods for accessing names and values and for searching for specific names.
        Strings that are name-value pairs consist of a name part, the separator character, and a value part. Any spaces around the separator character are part of the name or value. This convention corresponds to the format used in many initialization files. For example:
        
        DisplayGrid=1
        SnapToGrid=1
        GridSizeX=8
        GridSizeY=8"""
    Names: str
    """str:"""
    Objects: Any
    """Represents a set of objects that are associated one with each of the strings in the Strings property."""
    Options: StringsOptions
    """StringsOptions: Controls a set of boolean properties of TStrings.
        Use Options to specify the value of the following boolean properties of the list of strings:
        
        
        
        Option
        
        Property
        
        
        soStrictDelimiter
        
        StrictDelimiter
        
        
        soWriteBOM
        
        WriteBOM
        
        
        soTrailingLineBreak
        
        TrailingLineBreak
        
        
        soUseLocale
        
        UseLocale"""
    QuoteChar: Any
    """unicodechr(str): Specifies the quote character used by the DelimitedText property.
        Use QuoteChar to get or set the quote character that is used to enclose individual strings in the DelimitedText property.
        When QuoteChar is set to the null character, then DelimitedText does the following: 
        
        At reading, does not return quoted list items.
        At assigning, does not check an assigning value for quote char.
        That is, you can set QuoteChar to the null character to disable quoting in DelimitedText. To set the QuoteChar to the null character, do the following:
        
        
        Delphi:
        
        MyStringList.QuoteChar := #0;
        
        
        
        C++:
        
        MyStringList->QuoteChar = '\\0';"""
    StrictDelimiter: bool
    """bool: Determines how the Delimiter property is used.
        If StrictDelimiter is True, individual strings in DelimitedText are only separated by Delimiter or quoted between  QuoteChar. If StrictDelimiter is False, spaces and non-printable character are also used as delimiters.
        
        Tip: You can set QuoteChar to the null character (#0 in Delphi, '\\0' in C++) if you do not want quoted strings to be extracted as if they where surrounded by Delimiter."""
    Strings: str
    """str:"""
    StringsAdapter: IStringsAdapter
    """IStringsAdapter: Implements an IStringsAdapter interface for the TStrings object.
        
        StringsAdapter specifies the attached TStringsAdapter when it is used in OLE applications.
        
        Note: To create a StringsAdapter you can use GetOleStrings and SetOleStrings instead of creating an instance of TStringsAdapter. StringsAdapter is used internally with OLE applications."""
    Text: Any
    """Lists the strings in the TStrings object as a single string with the individual strings delimited by carriage returns and line feeds."""
    TrailingLineBreak: bool
    """bool: Determines whether to add a line Break after the last line of the Text property or not.
        Use TrailingLineBreak to add a finishing line break to Text. Set TrailingLineBreak to True to add a  line Break after the last line of Text. Set TrailingLineBreak to False to finish Text without a  line Break. Default is True."""
    Updating: bool
    """bool: Indicates whether or not the list of strings is in the middle of an update."""
    UseLocale: bool
    """bool: Determines the implementation that the list of strings must use for string comparison.
        Set UseLocale to True to use AnsiCompareStr and AnsiCompareText to compare strings.
        Set UseLocale to False to use CompareStr and CompareText. Default is True."""
    ValueFromIndex: str
    """str:"""
    Values: str
    """str:"""
    WriteBOM: bool
    """bool: Will cause SaveToStream and SaveToFile to write a BOM.
        Set WriteBOM to True to cause SaveToStream to write a BOM (byte-order mark) to the stream and to cause SaveToFile to write a BOM to the file."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self, s) -> Any:
        """TStrings.Add(s)
        Adds a string to the TStrings object and returns the index position"""
    def AddObject(self, s, delphiobject) -> Any:
        """TStrings.AddObject(s, delphiobject)
        Adds a string and an associated Delphi object to the Strings and returns the index position"""
    def AddPair(self, Name: str, Value: str) -> Strings:
        """TStrings.AddPair(Name: str, Value: str) -> Strings
        Adds name-value pairs to the list of strings using fluent-style coding.
        AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
        TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.\r
        Adds name-value pairs to the list of strings using fluent-style coding.
        AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
        TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding."""
    def AddStrings(self, Strings: Strings) -> None:
        """TStrings.AddStrings(Strings: Strings) -> None
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.\r
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.\r
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised."""
    def Append(self, S: str) -> None:
        """TStrings.Append(S: str) -> None
        Adds a string to the list.
        Append is the same as the Add method, except that it does not return a value. Use Append when there is no need to know the index of the string after it has been added, or with descendants of TStrings for which the index returned is not meaningful. 
        For example, the TStrings descendant used by memo objects uses an index to determine where to insert a string, but the inserted string does not necessarily end up as a single string in the list. Part of the inserted text may become part of the previous string, and part may be broken off into a subsequent string. The index returned by Add is not meaningful in this case. 
        Use Append rather than Add as a parameter for a function requiring a TGetStrProc."""
    def Assign(self, Source: Persistent) -> None:
        """TStrings.Assign(Source: Persistent) -> None
        Sets the strings in the Strings array, possibly associated Objects, and some other properties of the current TStrings object, from the Source object.
        Use Assign to set the properties of the TStrings object from the Source object. If Source is of the TStrings type, Assign copies the following properties:
        
        Strings
        Objects
        DefaultEncoding
        Encoding
        LineBreak
        Delimiter
        QuoteChar
        NameValueSeparator
        Options
        If Source is not of the TStrings type, the inherited Assign will set the value of the string array from any object that supports TStrings in its AssignTo method."""
    def BeginUpdate(self) -> Any:
        """TStrings.BeginUpdate()
        Enables the TStrings object to track when the list of strings is changing."""
    def Clear(self) -> Any:
        """TStrings.Clear()
        Clears all strings from a TStrings (and the associated objects"""
    def Create(self, *args, **kwargs) -> Any:
        """Creates an instance of a TStrings object.
        Do not call the Create method for TStrings directly. TStrings is an abstract class and its constructor should only be called as an inherited method from the constructor of a derived class."""
    def Delete(self, i) -> Any:
        """TStrings.Delete(i)
        Deletes the string at Index i (and the associated object"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TStrings instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def EndUpdate(self) -> Any:
        """TStrings.EndUpdate()
        Enables the TStrings object to keep track of when the list of strings has finished changing."""
    def Equals(self, Strings: Strings) -> bool:
        """TStrings.Equals(Strings: Strings) -> bool
        Compares the list of strings to the list from another TStrings object and returns true if the two lists match.
        Call Equals to compare the lists in two TStrings objects. Equals compares only the strings, not any references to associated objects. Equals returns true if the lists for both TStrings objects have the same number of strings and the strings in each list match. Equals returns false if the lists are different in length, if they contain different strings, or if the order of the strings in the two lists differ.
        
        Note:  The Equals method uses an overridden Get method to perform the compare, thus it does not provide a context-insensitive option."""
    def Exchange(self, Index1: int, Index2: int) -> None:
        """TStrings.Exchange(Index1: int, Index2: int) -> None
        Swaps the position of two strings in the list.
        Call Exchange to rearrange the strings in the list. The strings are specified by their index values in the Index1 and Index2 parameters. Indexes are zero-based, so the first string in the list has an index value of 0, the second has an index value of 1, and so on.
        If either string has an associated object, Exchange changes the position of the object as well."""
    def Get(self, Index: int) -> str:
        """TStrings.Get(Index: int) -> str
        Returns a string given its index.
        Get is the protected read implementation of the Strings property.
        In TStrings Get is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the string with the specified index."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TStrings enumerator.
        GetEnumerator returns a TStringsEnumerator reference, which enumerates the strings in a TStrings object. 
        To process all these strings, call the TStringsEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetObject(self, Index: int) -> Object:
        """TStrings.GetObject(Index: int) -> Object
        Returns the object associated with the string at a specified index.
        GetObject is the protected read implementation of the Objects property.
        Index is the index of the string with which the object is associated.
        In TStrings, GetObject always returns nil (Delphi) or NULL (C++). This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override GetObject to return the specified object."""
    def GetText(self, *args, **kwargs) -> Any:
        """Allocates a text buffer and fills it with the value of the Text property.
        Call GetText to obtain a dynamically allocated character buffer containing all of the strings in the list. Individual strings are separated by a carriage return (#13) on the OS X operating system, or by a carriage return and a line feed (#13#10) on Windows operating systems. The caller is responsible for freeing the returned value using the StrDispose procedure."""
    def IndexOf(self, s) -> Any:
        """TStrings.IndexOf(s)
        Returns the Index of a string s or -1 if not found"""
    def IndexOfName(self, Name: str) -> int:
        """TStrings.IndexOfName(Name: str) -> int
        Returns the position of the first name-value pair with the specified name.
        Call IndexOfName to locate the first occurrence of a name-value pair where the name part is equal to the Name parameter or differs only in case. IndexOfName returns the 0-based index of the string. If no string in the list has the indicated name, IndexOfName returns -1.
        
        Note:  If there is more than one name-value pair with a name portion matching the Name parameter, IndexOfName returns the position of the first such string."""
    def IndexOfObject(self, AObject: Object) -> int:
        """TStrings.IndexOfObject(AObject: Object) -> int
        Returns the index of the first string in the list associated with a given object.
        Call IndexOfObject to locate the first string in the list associated with the object AObject. Specify the object you want to locate as the value of the AObject parameter. IndexOfObject returns the 0-based index of the string and object. If the object is not associated with any of the strings, IndexOfObject returns -1."""
    def Insert(self, Index: int, S: str) -> None:
        """TStrings.Insert(Index: int, S: str) -> None
        Introduces abstract (Delphi) or pure virtual (C++) method to insert a string at a specified position.
        Descendants of TStrings implement an Insert method to add the string S to the list at the position specified by Index. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
        All methods that add strings to the list use the Insert method to add the string.
        If the string has an associated object, use the InsertObject method instead."""
    def InsertObject(self, Index: int, S: str, AObject: Object) -> None:
        """TStrings.InsertObject(Index: int, S: str, AObject: Object) -> None
        Inserts a string into the list at the specified position, and associates it with an object.
        Call InsertObject to insert the string S into the list at the position identified by Index, and associate it with the object AObject. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on."""
    def LoadFromFile(self, filename) -> Any:
        """TStrings.LoadFromFile(filename)
        Fills the list with the lines of text in a specified file."""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TStrings.LoadFromStream(Stream: Stream) -> None
        Fills the list with lines of text read from a stream.
        LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
        If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
        If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.\r
        Fills the list with lines of text read from a stream.
        LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
        If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
        If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream."""
    def Move(self, CurIndex: int, NewIndex: int) -> None:
        """TStrings.Move(CurIndex: int, NewIndex: int) -> None
        Changes the position of a string in the list.
        Use Move to move the string at position CurIndex so that it occupies the position NewIndex. The positions are specified as 0-based indexes. For example, the following lines of code move the string in the first position to the last position:
        For Delphi:
        
        MyStringsObject.Move(0, MyStringsObject.Count - 1);
        
        For C++: 
        
        MyStringsObject->Move(0, MyStringsObject->Count - 1);
        
        If the string has an associated object, the object remains associated with the string in its new position."""
    def Put(self, Index: int, S: str) -> None:
        """TStrings.Put(Index: int, S: str) -> None
        Changes the value of the string with a specified index.
        Put is the protected write implementation of the Strings property.
        Put changes the value of the string with the index specified by Index to S. Put does not change the object at the specified position. That is, any object associated with the previous string becomes associated with the new string."""
    def PutObject(self, Index: int, AObject: Object) -> None:
        """TStrings.PutObject(Index: int, AObject: Object) -> None
        Changes the object associated with the string at a specified index.
        PutObject is the protected write implementation of the Objects property.
        As implemented in TStrings, PutObject does nothing. This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override PutObject to change the specified object."""
    def SaveToFile(self, filename) -> Any:
        """TStrings.SaveToFile(filename)
        Saves the strings in the list to the specified file."""
    def SaveToStream(self, Stream: Stream) -> None:
        """TStrings.SaveToStream(Stream: Stream) -> None
        Writes the  value of the Text property to the Stream stream.
        SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
        If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
        If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
        Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
        If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.\r
        Writes the  value of the Text property to the Stream stream.
        SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
        If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
        If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
        Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
        If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream."""
    def SetStrings(self, Source: Strings) -> None:
        """TStrings.SetStrings(Source: Strings) -> None
        Sets the strings from another TStrings object to the list of strings.
        Use SetStrings to assign the value of the TStrings object from another TStrings object (Source).
        
        Note: SetStrings is similar to Assign, but Assign also copies multiple additional properties."""
    def SetText(self, Text: PWideChar) -> None:
        """TStrings.SetText(Text: PWideChar) -> None
        Sets the Text property.
        Call SetText to replace the list with the strings specified by the Text parameter. SetText adds strings one at a time to the list, using the carriage returns or linefeed characters in Text as delimiters indicating when to add a new string."""
    def ToObjectArray(self, *args, **kwargs) -> Any:
        """Returns the TObject array associated with Strings.
         
        Use ToObjectArray to obtain the array of TObject associated with Strings.
        
        Note: TStrings is an abstract class and this method has no effect. Descendent classes can associate objects with strings.
        Note:  The TStrings object does not own the objects in the Objects array. Objects added to the Objects array still exist even if the TStrings object is destroyed. They must be explicitly destroyed by the application."""
    def ToStringArray(self, *args, **kwargs) -> Any:
        """Converts a TStrings descendant to a string array.
         
        Use ToStringArray to obtain an array of strings for each string in the list."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class StyleBook(FmxObject):
    """TStyleBook stores a collection of styles for a form.
    There are two ways to create and use a TStyleBook component:
    
    Drop a TStyleBook component from the Tool Palette onto the Form Designer and make your new TStyleBook component the value of the StyleBook property of the form. This works for desktop applications and mobile applications.
    Right-click a control on a FireMonkey desktop form and choose either Edit Default Style or Edit Custom Style. This automatically creates a TStyleBook component, sets it to the form's StyleBook, and opens the Style Designer.
    TStyleBook stores the style definition as text in the Resource property and can be loaded from a .style file.
    Double-clicking the TStyleBook component on the form opens the Style Designer.
    
    TStyleBook and Form Inheritance
    If you want all the descendant forms to have the same style as the base form, place the TStyleBook in the base form.
    If you want the descendant forms to have different styles, place separate TStyleBooks in the descendant forms.
    Note: At design time, using the StyleLookup property of a control in any form in the current project group you can access any custom style defined in any TStyleBook component used in the current project group. That is, even if the form does not have a particular TStyleBook component, controls from this form can use custom  styles defined in this TStyleBook component (if this TStyleBook component is used in any form in the current project group). At run time, only styles in the current project and only after an owner of the TStyleBook containing these styles is already created can be accessed."""
    __hash__: ClassVar[None] = ...
    CurrentItem: StyleCollectionItem
    """StyleCollectionItem: Current style in the style collection.
         CurrentItem is the current  StyleCollectionItem from the  StyleCollection."""
    CurrentItemIndex: int
    """int: Index of the current style in the style collection.
         CurrentItemIndex is the index of the current  StyleCollectionItem from the  StyleCollection array.
         CurrentItemIndex is an integer value."""
    DesignInfo: StyleBookDesignInfo
    """StyleBookDesignInfo: DesignInfo is a  TStyleBookDesignInfo record that contains design-time information only used by the Form designer.
        
         ClassName: Class name of the selected control.
         CustomStyle: True when edit custom style mode is active.
         DefaultStyleLookup: The default StyleLookup for the selected control.
         Name: Name of the selected control.
         StyleLookup: Name of the StyleLookup for the selected control.
         Control: The selected control itself."""
    FileName: str
    """str: The name of the file that contains the style definition.
        Use FileName to specify the .style file from which the TStyleBook loads its Resource.
        Setting the FileName also loads and applies the style."""
    Parent: Any
    """Returns/Sets the Control Visibility"""
    Resource: Strings
    """Strings: The style definition. Resource is a string list containing the style defined by the TStyleBook."""
    Style: FmxObject
    """FmxObject: Represents the current style as a TFmxObject."""
    Styles: StyleCollection
    """StyleCollection: Contains the  collection of  styles stored in the  TStyleBook."""
    UnsupportedPlatform: bool
    """bool: Indicates whether the style can be loaded in the current target platform. 
        If the style cannot be loaded, UnsupportedPlatform is True and Style is empty."""
    UseStyleManager: bool
    """bool: Specifies whether the TStyleManager replaces the default style for the whole application."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Clear(self, *args, **kwargs) -> Any:
        """Clears the style collection of a  TStyleBook.
         TStyleCollection is a collection that stores the styles for the different platforms.
         Clear deletes all items from the collection."""
    def Create(self, AOwner: Component) -> None:
        """TStyleBook.Create(AOwner: Component) -> None
        Creates and initializes a TStyleBook instance. Create constructs a TStyleBook object and initializes its data before the object is first used."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TStyleBook and frees the associated memory.
        Do not call Destroy directly. Call Free instead. Free verifies that the object reference is not nil before calling Destroy."""
    def GetStyle(self, Context: FmxObject) -> FmxObject:
        """TStyleBook.GetStyle(Context: FmxObject) -> FmxObject
        Gets the style of the  CurrentItem stored in  TStyleCollectionItem. Getter of  Style. 
         TStyleCollectionItem stores one style for the specified platform. GetStyle  gets the style item.
        The style is a  TFmxObject type.\r
        Gets the style of the  CurrentItem stored in  TStyleCollectionItem. Getter of  Style. 
         TStyleCollectionItem stores one style for the specified platform. GetStyle  gets the style item.
        The style is a  TFmxObject type."""
    def LoadFromFile(self, AFileName: str) -> None:
        """TStyleBook.LoadFromFile(AFileName: str) -> None
        Method to load a style to a  TStyleBook, from a file.
        Select the full path to the file or the file name when located in the project folder.
        FireMonkey styles are delivered in the RAD Studio product installation, at the following paths:
        
        C:\\Program Files (x86)\\Embarcadero\\Studio\\21.0\\Redist\\styles\\Fmx
        C:\\Users\\Public\\Documents\\Embarcadero\\Studio\\21.0\\Styles
        Apply the style to the form using the  StyleBook  property of the form, for example:
        
        procedure TForm1.FormCreate(Sender: TObject);
        begin
          StyleBook1.LoadFromFile('Air.Style');
          Form1.StyleBook := StyleBook1;
        end;
        
        To load a style to an  item of the  TStyleCollection, that is a style for each platform added to the  TStyleBook, then use FMX.Controls.TStyleCollectionItem.LoadFromFile."""
    @overload
    def LoadFromStream(self, Stream: Stream) -> None:
        """TStyleBook.LoadFromStream(Stream: Stream) -> None
        Method to load a style to the  TStyleBook, from a stream.
        To load the style from a file use  LoadFromFile.
        
        procedure TForm1.FormCreate(Sender: TObject);
        var
          S: TFileStream; 
        begin
          S :=  TFileStream.Create('Air.Style', fmOpenRead);
          Stylebook1.LoadFromStream(S);
        end;
        
        procedure TForm2.FormCreate(Sender: TObject);
        var
          iStream: TMemoryStream;
        begin
          StyleBook1.LoadFromFile('Air.Style'); //Loads the style from a file.
          iStream := TMemoryStream.Create; //Instanziate the memory stream var.
          TStyleStreaming.SaveToStream(StyleBook1.Style, iStream); //saves the style as a memory stream.
          StyleBook1.Clear; //Clear the styles from the stylebook.
          iStream.Position := 0; //Sets the position to start the streaming.
          StyleBook1.LoadFromStream(iStream); //Loads the style to the stylebook from the memory stream.
        end;"""
    @overload
    def LoadFromStream(self, S) -> Any:
        """TStyleBook.LoadFromStream(Stream: Stream) -> None
        Method to load a style to the  TStyleBook, from a stream.
        To load the style from a file use  LoadFromFile.
        
        procedure TForm1.FormCreate(Sender: TObject);
        var
          S: TFileStream; 
        begin
          S :=  TFileStream.Create('Air.Style', fmOpenRead);
          Stylebook1.LoadFromStream(S);
        end;
        
        procedure TForm2.FormCreate(Sender: TObject);
        var
          iStream: TMemoryStream;
        begin
          StyleBook1.LoadFromFile('Air.Style'); //Loads the style from a file.
          iStream := TMemoryStream.Create; //Instanziate the memory stream var.
          TStyleStreaming.SaveToStream(StyleBook1.Style, iStream); //saves the style as a memory stream.
          StyleBook1.Clear; //Clear the styles from the stylebook.
          iStream.Position := 0; //Sets the position to start the streaming.
          StyleBook1.LoadFromStream(iStream); //Loads the style to the stylebook from the memory stream.
        end;"""
    @overload
    def LoadFromStream(self, iStream) -> Any:
        """TStyleBook.LoadFromStream(Stream: Stream) -> None
        Method to load a style to the  TStyleBook, from a stream.
        To load the style from a file use  LoadFromFile.
        
        procedure TForm1.FormCreate(Sender: TObject);
        var
          S: TFileStream; 
        begin
          S :=  TFileStream.Create('Air.Style', fmOpenRead);
          Stylebook1.LoadFromStream(S);
        end;
        
        procedure TForm2.FormCreate(Sender: TObject);
        var
          iStream: TMemoryStream;
        begin
          StyleBook1.LoadFromFile('Air.Style'); //Loads the style from a file.
          iStream := TMemoryStream.Create; //Instanziate the memory stream var.
          TStyleStreaming.SaveToStream(StyleBook1.Style, iStream); //saves the style as a memory stream.
          StyleBook1.Clear; //Clear the styles from the stylebook.
          iStream.Position := 0; //Sets the position to start the streaming.
          StyleBook1.LoadFromStream(iStream); //Loads the style to the stylebook from the memory stream.
        end;"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StyleManager(Object):
    """TStyleManager handles styles-related operations.
    Use TStyleManager to:
    
    Set and retrieve the active style.
    Load styles from files or streams."""
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    @classmethod
    def ActiveStyle(cls, Context: FmxObject) -> FmxObject:
        """TStyleManager.ActiveStyle(Context: FmxObject) -> FmxObject
        Returns the style that is currently set."""
    @classmethod
    def ActiveStyleForScene(cls, AScene: IInterface) -> FmxObject:
        """TStyleManager.ActiveStyleForScene(AScene: IInterface) -> FmxObject
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def EnumStyleResources(cls, Proc: StyleResourceEnumProc) -> None:
        """TStyleManager.EnumStyleResources(Proc: StyleResourceEnumProc) -> None
        Enumetates all the registered style resource objects."""
    @classmethod
    def FindStyleDescriptor(cls, AObject: FmxObject) -> StyleDescription:
        """TStyleManager.FindStyleDescriptor(AObject: FmxObject) -> StyleDescription
        Returns the style description of the specified style.
        FindStyleDescriptor returns the TStyleDescription object associated with the style specified by AObject, if such a description is set.
        You can set the style description fields using the Tools > Bitmap Style Designer dialog."""
    @classmethod
    def GetStyleDescriptionForControl(cls, AObject: FmxObject) -> StyleDescription:
        """TStyleManager.GetStyleDescriptionForControl(AObject: FmxObject) -> StyleDescription
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def GetStyleResource(cls, ResourceName: str) -> FmxObject:
        """TStyleManager.GetStyleResource(ResourceName: str) -> FmxObject
        Gets the style resource object.
        GetStyleResource returns the style resource if it exits in cache. Otherwise it loads the style resource.
        ResourceName specifies the style resource as per name."""
    @classmethod
    def RegisterPlatformStyleResource(cls, APlatform: OSPlatform, ResourceName: str) -> None:
        """TStyleManager.RegisterPlatformStyleResource(APlatform: OSPlatform, ResourceName: str) -> None
        Registers the style resource for the specified platform.
        
        ResourceName specifies the resource style.
        APlatform specifies the target platform."""
    @classmethod
    def RegisterPlatformStyleSelection(cls, APlatform: OSPlatform, ASelection: Callable[[OSPlatform],str]) -> None:
        """TStyleManager.RegisterPlatformStyleSelection(APlatform: OSPlatform, ASelection: Callable[[OSPlatform], str]) -> None
        Registers the style resource specified by selection.
        
        APlatform specifies the target platform.
        ASelection specifies the style selection with type TPlatformStyleSelectionProc."""
    @classmethod
    def RemoveStyleFromGlobalPool(cls, Style: FmxObject) -> None:
        """TStyleManager.RemoveStyleFromGlobalPool(Style: FmxObject) -> None
        Removes the specified Style from the pool of styles."""
    @classmethod
    def SetStyle(cls, Style: FmxObject) -> None:
        """TStyleManager.SetStyle(Style: FmxObject) -> None
        Sets the active style to the instance specified by the Style parameter.
        To set the active style to the native system style, for example Windows theme, pass nil as the Style parameter.
        
        Note: If you call the SetStyle function in the initialization section of a unit on the main project file, before Application.Initialize, then it is applied to all forms.\r
        Sets the active style to the instance specified by the Style parameter.
        To set the active style to the native system style, for example Windows theme, pass nil as the Style parameter.
        
        Note: If you call the SetStyle function in the initialization section of a unit on the main project file, before Application.Initialize, then it is applied to all forms."""
    @classmethod
    def SetStyleFromFile(cls, FileName: str) -> bool:
        """TStyleManager.SetStyleFromFile(FileName: str) -> bool
        Sets the style specified by FileName as the active style.
        Do not place multiple lines calling SetStyleFromFile in a project, because you can have only one active style in the style manager.
        You can call SetStyleFromFile either in the project source code (before calling Application.Initialize) or in the initialization section of one of the form units:
        
        If you call SetStyleFromFile in a form, the style is reapplied.
        If you call SetStyleFromFile before the form is created, the custom style fully replaces the platform style.
        Example
        This Delphi code demonstrates how to use the StyleManager:
        
        
        Delphi:
        
        procedure TForm1.FormCreate(Sender: TObject);
          var
            od : TOpenDialog;
          begin
            od := nil;
            try
            od := TOpenDialog.Create(self);
            od.Filter := 'Style Files|*.style';
            if od.Execute() then
              TStyleManager.SetStyleFromFile(od.FileName);
          finally
            od.Free();
          end;
        end;\r
        Sets the style specified by FileName as the active style.
        Do not place multiple lines calling SetStyleFromFile in a project, because you can have only one active style in the style manager.
        You can call SetStyleFromFile either in the project source code (before calling Application.Initialize) or in the initialization section of one of the form units:
        
        If you call SetStyleFromFile in a form, the style is reapplied.
        If you call SetStyleFromFile before the form is created, the custom style fully replaces the platform style.
        Example
        This Delphi code demonstrates how to use the StyleManager:
        
        
        Delphi:
        
        procedure TForm1.FormCreate(Sender: TObject);
          var
            od : TOpenDialog;
          begin
            od := nil;
            try
            od := TOpenDialog.Create(self);
            od.Filter := 'Style Files|*.style';
            if od.Execute() then
              TStyleManager.SetStyleFromFile(od.FileName);
          finally
            od.Free();
          end;
        end;"""
    @classmethod
    def TrySetStyleFromResource(cls, ResourceName: str) -> bool:
        """TStyleManager.TrySetStyleFromResource(ResourceName: str) -> bool
        Loads the style from ResourceName and sets the style as the active style.
        TrySetStyleFromResource sets the style without raising exceptions."""
    @classmethod
    def UnInitialize(cls, *args, **kwargs) -> Any:
        """Uninitializes data about styles.
        
        Note: This function is reserved for internal use only. Do not call it directly."""
    @classmethod
    def UpdateScenes(cls, *args, **kwargs) -> Any:
        """Updates the style for all the registered scenes."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StyleStreaming(Object):
    """Embarcadero Technologies does not currently have any additional information."""
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    @classmethod
    def CanLoadFromFile(cls, FileName: str) -> bool:
        """TStyleStreaming.CanLoadFromFile(FileName: str) -> bool
        Loads a style from the specified file without raising an exception.
        CanLoadFromFile searches for the style specified by FileName.
        CanLoadFromFile returns True if the style is successfully loaded, and False otherwise."""
    @classmethod
    def CanLoadFromResource(cls, ResourceName: str, ResourceType: PWideChar) -> bool:
        """TStyleStreaming.CanLoadFromResource(ResourceName: str, ResourceType: PWideChar) -> bool
        Loads a style from the specified resource without raising an exception.
        In the first signature CanLoadFromResource searches for the specified ResourceName with type ResourceType in the instace handle indicated by Instance.
        In the second signature CanLoadFromResource internally calls EnumModules in order to search for ResourceName in all modules of the application. 
        CanLoadFromResource returns True if the style is successfully loaded, and False otherwise.\r
        Loads a style from the specified resource without raising an exception.
        In the first signature CanLoadFromResource searches for the specified ResourceName with type ResourceType in the instace handle indicated by Instance.
        In the second signature CanLoadFromResource internally calls EnumModules in order to search for ResourceName in all modules of the application. 
        CanLoadFromResource returns True if the style is successfully loaded, and False otherwise."""
    @classmethod
    def CanLoadFromStream(cls, AStream: Stream) -> bool:
        """TStyleStreaming.CanLoadFromStream(AStream: Stream) -> bool
        Loads a style from the specified stream without raising an exception.
        CanLoadFromStream searches for the style specified by AStream.
        CanLoadFromStream returns True if the style is successfully loaded, and False otherwise."""
    @classmethod
    def DefaultIsSupportedPlatformTarget(cls, PlatformTarget: str) -> bool:
        """TStyleStreaming.DefaultIsSupportedPlatformTarget(PlatformTarget: str) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def LoadFromFile(cls, FileName: str) -> FmxObject:
        """TStyleStreaming.LoadFromFile(FileName: str) -> FmxObject
        Loads a style from the specified file.
        LoadFromFile returns a style object that can be set as the active style using the SetStyle method.
        Note that LoadFromFile does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method."""
    @classmethod
    def LoadFromResource(cls, Instance: int, ResourceName: str, ResourceType: PWideChar) -> FmxObject:
        """TStyleStreaming.LoadFromResource(Instance: int, ResourceName: str, ResourceType: PWideChar) -> FmxObject
        Loads a style from the specified resource.
        LoadFromResource returns a style object that can be set as the active style using the SetStyle method.
        Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method. 
        
        
        
        Parameter
        
        Meaning
        
        
        Instance
        
        The instance handle of the loaded resource.
        
        
        ResourceName
        
        The string associated with the resource.
        
        
        ResourceType
        
        A string that identifies the type of resource."""
    @classmethod
    def LoadFromStream(cls, AStream: Stream) -> FmxObject:
        """TStyleStreaming.LoadFromStream(AStream: Stream) -> FmxObject
        Loads a style from the specified stream.
        LoadFromStream returns a style object that can be set as the active style using the SetStyle method.
        Note that LoadFromStream does not automatically switch to the loaded style. To do that, call the SetStyleFromFile method."""
    @classmethod
    def SameStyle(cls, Style1: FmxObject, Style2: FmxObject) -> bool:
        """TStyleStreaming.SameStyle(Style1: FmxObject, Style2: FmxObject) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def SaveToStream(cls, Style: FmxObject, AStream: Stream, Format: StyleFormat) -> None:
        """TStyleStreaming.SaveToStream(Style: FmxObject, AStream: Stream, Format: StyleFormat) -> None
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def SetDefaultContainerClass(cls, AClass: FmxObjectClass) -> None:
        """TStyleStreaming.SetDefaultContainerClass(AClass: FmxObjectClass) -> None
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def SetSupportedPlatformHook(cls, AHook: Callable[[str],bool]) -> None:
        """TStyleStreaming.SetSupportedPlatformHook(AHook: Callable[[str], bool]) -> None
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def TryLoadStyleDescription(cls, Stream: Stream, Description: StyleDescription) -> bool:
        """TStyleStreaming.TryLoadStyleDescription(Stream: Stream, Description: StyleDescription) -> bool
        This method tries to parse the style file and read the style description.
        The TStyleDescription object specified by Description should be destroyed by the caller."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StyledControl(Control):
    """TStyledControl is the base class for customizable and user-interaction controls.
    TStyledControl extends TControl to act as the immediate superclass for concrete user-facing widgets.
    For descendants of TStyledControl, you can set the style resource and the basis for FireMonkey's dynamic look-and-feel. Subclasses of TStyledControl search their style resource among those assigned to the StyleBook property of the form, using a simple search routine based on class names returned by the GetStyleObject method. The access to the subcomponents defined by the same style permits the parent control to be modified at run time. To apply a style to a control, set the StyleLookup property to the name of the style.
    For more details about the style and design of FireMonkey components, see FireMonkey Component Rendering and Customizing with Styles.
    Descendants of TStyledControl are controls like TPanel, TLabel, TCheckBox, TImageControl, or TCalendar."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    ParentClassStyleLookupName: str
    '''str: The name of the default style of the parent class of this control.
        The name of the style is composed of the class name without the leading T, followed by the string "style". For example, if the class name is TEdit, the style name is Editstyle.'''
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StylesData: Value
    """Value:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        FMX.Controls.TStyledControl.BeforeDestruction inherits from System.Classes.TComponent.BeforeDestruction. All content below this line refers to System.Classes.TComponent.BeforeDestruction.
        Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def Create(self, AOwner: Component) -> None:
        """TStyledControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TStyledControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        FMX.Controls.TStyledControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def FindStyleResource(self, AStyleLookup: str, Clone: bool) -> FmxObject:
        """TStyledControl.FindStyleResource(AStyleLookup: str, Clone: bool) -> FmxObject
        Finds the linked resource object for the style specified by name.
        The AStyleLookup parameter specifies the name of the style.
        If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks to the styles of the control's children. If no resource object is found, it returns nil.
        Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True).\r
        Finds the linked resource object for the style specified by name.
        The AStyleLookup parameter specifies the name of the style.
        If AStyleLookup is empty, FindStyleResource returns nil. If no resource object is linked directly to the control, FindStyleResource looks to the styles of the control's children. If no resource object is found, it returns nil.
        Clone determines whether the returned style resource object should be the original style object (False) or a copy of the original (True)."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    @classmethod
    def LookupStyleObject(cls, Instance: FmxObject, Context: FmxObject, Scene: IScene, StyleLookup: str, DefaultStyleLookup: str, ParentClassStyleLookup: str, Clone: bool, UseGlobalPool: bool) -> FmxObject:
        """TStyledControl.LookupStyleObject(Instance: FmxObject, Context: FmxObject, Scene: IScene, StyleLookup: str, DefaultStyleLookup: str, ParentClassStyleLookup: str, Clone: bool, UseGlobalPool: bool) -> FmxObject
        Looks for the style resource object linked to the TStyledControl.
        If no style is defined for the current control, LookupStyleObject seeks in the current scene for the active style.
        If the current scene does not have a resource object, LookupStyleObject continues the search through the default styles and Parent's style."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def PrepareForPaint(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def RecalcSize(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def SetNewScene(self, AScene: IScene) -> None:
        """TStyledControl.SetNewScene(AScene: IScene) -> None
        Sets a new Scene for the current control.
        FMX.Controls.TStyledControl.SetNewScene inherits from FMX.Controls.TControl.SetNewScene. All content below this line refers to FMX.Controls.TControl.SetNewScene.
        Sets a new Scene for the current control.
        AScene specifies the new scene. If AScene is empty, SetNewScene does nothing.
        SetNewScene sets the same scene for the control's children."""
    def StartTriggerAnimation(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TStyledControl.StartTriggerAnimation(AInstance: FmxObject, ATrigger: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def StartTriggerAnimationWait(self, AInstance: FmxObject, ATrigger: str) -> None:
        """TStyledControl.StartTriggerAnimationWait(AInstance: FmxObject, ATrigger: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Switch(CustomSwitch):
    """Represents a two-way on-off switch for use in applications.
    Use a TSwitch whenever you need to provide the user with a two-way on-off switch."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool: Indicates if the Switch is turned on or off.
        IsChecked is True if the Switch is turned on, False otherwise."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSwitch: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SysCommonAction(CustomAction):
    """A base class for standard actions that provides system functionality.
    TSysCommonAction extends the TCustomAction class redeclaring properties and events, used in system actions, with the published visibility. 
    These are the following: CustomText,  Enabled,  HelpContext,  HelpKeyword,  HelpType,  Hint,  SecondaryShortCuts,  ShortCut,  Visible,  UnsupportedArchitectures,  OnCanActionExec,  OnUpdate.
    The published scope of properties and events provides the possibility to use the Object Inspector for editing values of these properties and defining event handlers at design time.
    Standard actions descending from TSysCommonAction are the following:
    
    TFileExit
    TWindowClose
    TFileHideApp
    TFileHideAppOthers."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    CustomText: str
    """str: CustomText is a user text.
        Some actions can, by default, automatically set the Text property. For example, in the TFileExit standard action, the Text property has the Quit <Application.Title> value. To set your own value, set the value of the Text property to the value of the CustomText property."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    OnCanActionExec: Callable[[CustomAction,bool],None]
    """Callable[[CustomAction, bool], None]:"""
    OnHint: Callable[[str,bool],None]
    """Callable[[str, bool], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TabControl(StyledControl):
    """TTabControl is a tab set that has the appearance of notebook dividers.
    Use TTabControl to add a control with multiple tab settings to a FireMonkey form. When the current tab changes, the tab control must directly update its contents to reflect the change, in an OnChange event handler.
    Disabling a TTabControl object disables all tabs at once. To enable or disable specific tabs, you can programmatically use the Tabs property as in the following code snippet where the tab with the index of 1 is rendered as disabled:
    
      TabControl1.Tabs[1].Enabled := False;
    
    Use TTabControl to create rich graphical interfaces with great functionality, such as options and configurations for a specific application.
    
    Code Examples
    FMX.ControlsDemo Sample
    FMX.MusicPlayer Sample
    FMX.TabSlideTransition Sample"""
    __hash__: ClassVar[None] = ...
    ActiveTab: TabItem
    """TabItem: Specifies the currently active tab.
        ActiveTab sets or gets the currently active (focused) tab item on the current tab control."""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AniCalculations: AniCalculations
    """AniCalculations: Represents the settings for the inertial scrolling that controls the movement in the title area of the tabs."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EffectiveFullSize: bool
    """bool: Indicates whether the tab buttons take up all the space in the tabs band. 
        See its getter method GetEffectiveFullSize for further details."""
    EffectiveTabPosition: TabPosition
    """TabPosition: Embarcadero Technologies does not currently have any additional information."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    FullSize: BehaviorBoolean
    """BehaviorBoolean: Specifies whether the tab buttons occupy all the space in the tabs band.
        Set the FullSize property to True in order for the clickable tab buttons to take up all the space in the tabs band. For instance, if you have a tab control component of a fairly large width and only two tabs, then setting FullSize to True will make the two tab buttons span over the entire width of the tab control.
        Set FullSize to False to let Delphi automatically adjust the way the tab buttons occupy the space."""
    HasTouchScreen: bool
    """bool: Indicates whether the device the application runs on has a touch screen. 
        When HasTouchScreen is True the device where the application runs on has a touch screen."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabBarButtons: TabControl.TTabBarButtons
    """TabControl.TTabBarButtons: Specifies the buttons to be displayed in the field names of the tabs. 
        The set of buttons displayed depends on various factors: the availability of the touch screen, the location of the headers, and the number of tabs."""
    TabBarRect: RectF
    """RectF: The coordinates of the rectangle where all the tab titles are placed."""
    TabContentPosition: float
    """float: Offset of the area of the tab headers."""
    TabContentSize: SizeF
    """SizeF: The size of the area that contains all the tab titles."""
    TabCount: int
    """int: Specifies the number of tabs that are present on this tab control component.
        Read the TabCount property to obtain the number of tab items that this tab control component has. If there are no tabs present, reading the TabCount property obtains 0."""
    TabHeight: float
    """float: Specifies the height, in pixels, of the clickable tabs' captions.
        Use the TabHeight property to specify the height, in pixels, of the band that holds all the clickable tab buttons that correspond to individual tabs of this tab control component."""
    TabIndex: int
    """int: Specifies the index of the active tab.
        Use the TabIndex property to set or get the index of the tab that is active (focused) on this tab control component. A value of 0 indicates that the first tab is active, while a value of -1 indicates that none of the tabs is active, or there are none present."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabPosition: TabPosition
    """TabPosition: Specifies the position of the tabs on this TTabControl component.
        The default value of the TTabPosition property is PlatformDefault. 
        Refer to the TTabPosition help topic for the description of the possible tab positions."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Tabs: TabItem
    """TabItem:"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    TransitionRunning: bool
    """bool: Determines whether the transition between tabs is currently running.
        TransitionRunning returns True if the transition between tabs is currently running and False otherwise."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self, TabClass: TabItemClass) -> TabItem:
        """TTabControl.Add(TabClass: TabItemClass) -> TabItem
        Adds a new tab to the tab control.
        Use the Add method to create a new tab object and add it to the tab control. The type of the tab object is specified by the TabClass parameter.
        If TabClass is nil, the created tab object will have the default type TTabItem."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TTabControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.TabControl.TTabControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Delete(self, Index: int) -> bool:
        """TTabControl.Delete(Index: int) -> bool
        Deletes a tab from the tab control.
        Use the Delete method to delete the tab specified by AIndex from the tab control."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.TabControl.TTabControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def FindVisibleTab(self, Index: int, FindKind: TabControl.TFindKind) -> bool:
        """TTabControl.FindVisibleTab(Index: int, FindKind: TabControl.TFindKind) -> bool
        Returns the first visible tab from the current tab.
        Use the FindVisibleTab method to get the first visible tab of type FindKind.
        The first overloaded method calculates the index of the found tab in the Index parameter. Index represents:
        
        At input, the index of the tab where the search begins.
        At output, if the returned value is True, the index of the found tab; otherwise, the old value.
        The second overloaded method returns the index of the found tab. Searching starts with the current tab. If the tab is found, it return its index, otherwise it returns -1.\r
        Returns the first visible tab from the current tab.
        Use the FindVisibleTab method to get the first visible tab of type FindKind.
        The first overloaded method calculates the index of the found tab in the Index parameter. Index represents:
        
        At input, the index of the tab where the search begins.
        At output, if the returned value is True, the index of the found tab; otherwise, the old value.
        The second overloaded method returns the index of the found tab. Searching starts with the current tab. If the tab is found, it return its index, otherwise it returns -1."""
    def FinishCurrentTabTransition(self, *args, **kwargs) -> Any:
        """Finishes current tabs transition."""
    def First(self, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool:
        """TTabControl.First(ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool
        Moves to the first visible tab in the tab control.
        Use the First method to set the active tab to the first visible tab in the tab control.
        ATransition specifies the type of transition used to switch the tab.
        ADirection specifies the direction in which the content of the tab is replaced with the content of the first tab."""
    def GetTabItem(self, AIndex: int) -> TabItem:
        """TTabControl.GetTabItem(AIndex: int) -> TabItem
        Protected getter implementation for the Tabs property."""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Returns the list of tabs contained in this tab control."""
    def GoToActiveTab(self, *args, **kwargs) -> Any:
        """Moves the title area of the tabs so that the active tab is visible.
        The movement of the tabs is asynchronous."""
    def GotoVisibleTab(self, Index: int, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool:
        """TTabControl.GotoVisibleTab(Index: int, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool
        Sets the focused tab using the specified transition. Animation of the switch transition depends on mutual positions of the current focused tab and the specified tab.
        GotoVisibleTab switches the active tab to the tab specified by the Index parameter if possible (the tab with the specified Index exists and it is visible). GotoVisibleTab switches the active tab using the switch transition specified by the ATransition and ADirection parameters and taking into account mutual positions of the current active tab and the tab specified by Index.
        ATransition specifies the type of transition used to switch the tab. When ATransition = Slide, then the tab control uses visual animation for the switching action. That is, moving of contents in the switched tabs is animated. The default ATransition is Slide.  
        ADirection specifies the direction in which the content of the current active tab is replaced with the content of the specified Index tab. ADirection is taken into account only when ATransition = Slide. GotoVisibleTab animates switching transitions of tabs taking into account mutual positions of the current active tab and the tab specified by Index:
        
        When ADirection = Normal. If the destination tab is left of the current active tab (lower Index), then the forward left-to-right switching transition animation of tab items is used. If the tab to display is to the right of the active tab (upper Index), then the backward right-to-left switching transition animation of tab items is used.
        When ADirection = Reversed, then the switching transitions uses the opposite animation directions to the described above.
        The default ADirection is Normal.
        In difference to SetActiveTabWithTransition, the 
        GotoVisibleTab method animates the switch transition depending on mutual positions of the current focused tab and the specified Index tab.
        GotoVisibleTab returns True in case of success and False otherwise."""
    def HasActiveTab(self, *args, **kwargs) -> Any:
        """Determines whether there is an active tab in the tab control.
        HasActiveTab returns True if one of the tabs in the tab control is selected and False otherwise.
        The tab control has an active tab if TabIndex is between 0 and TabCount-1."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def Insert(self, Index: int, TabClass: TabItemClass) -> TabItem:
        """TTabControl.Insert(Index: int, TabClass: TabItemClass) -> TabItem
        Inserts a new tab on the specified position.
        Use the Insert method to create a new tab object and insert it on the position specified by Index. 
        The type of the tab object is specified by the TabClass parameter. If TabClass is nil, the created tab object will have the default type TTabItem.
        The Index parameter is 0-based."""
    def Last(self, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool:
        """TTabControl.Last(ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool
        Moves to the last visible tab in the tab control.
        Use the Last method to set the active tab to the last visible tab in the tab control.
        ATransition specifies the type of transition used to switch the tab.
        ADirection specifies the direction in which the content of the tab is replaced with the content of the last tab."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def Next(self, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool:
        """TTabControl.Next(ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool
        Moves the active tab to the next tab.
        Use the Next method to move over to the following tab, if it exists.
        ATransition specifies the type of transition used to switch the tab.
        ADirection specifies the direction in which the content of the tab is replaced with the content of the next tab."""
    def Previous(self, ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool:
        """TTabControl.Previous(ATransition: TabTransition, ADirection: TabTransitionDirection) -> bool
        Moves the active tab to the previous tab.
        Use the Previous method to move over to the previous tab, if it exists.
        ATransition specifies the type of transition used to switch the tab.
        ADirection specifies the direction in which the content of the tab is replaced with the content of the previous tab."""
    def SetActiveTabWithTransition(self, ATab: TabItem, ATransition: TabTransition, ADirection: TabTransitionDirection) -> None:
        """TTabControl.SetActiveTabWithTransition(ATab: TabItem, ATransition: TabTransition, ADirection: TabTransitionDirection) -> None
        Sets the focused tab using the specified transition.
        SetActiveTabWithTransition sets the currently active tab to ATab using the specified ATransition and ADirection transition parameters.
        ATransition specifies the type of transition used to switch the tab. When ATransition = Slide, then the tab control uses visual animation for the switching action. It means that moving of contents in the switched tabs is animated.
        ADirection specifies the direction in which the content of the current active tab is replaced with the content of the specified ATab tab. ADirection is considered only when ATransition = Slide. If ADirection = Normal, then the forward left-to-right tab items switching transition animation is used. If ADirection = Reversed, then the backward right-to-left tab items switching transition animation is used. The default is Normal.
        Compare with GotoVisibleTab.
        
        Note: SetActiveTabWithTransition Does not work on Android."""
    def SetActiveTabWithTransitionAsync(self, ATab: TabItem, ATransition: TabTransition, ADirection: TabTransitionDirection, AOnFinish: Proc) -> None:
        """TTabControl.SetActiveTabWithTransitionAsync(ATab: TabItem, ATransition: TabTransition, ADirection: TabTransitionDirection, AOnFinish: Proc) -> None
        Changes the currently active tab to a new ATab asynchronously.
        When the animation ends, callback AOnFinish is called.
        
        Note: SetActiveTabWithTransitionAsync is required when working on Android.\r
        Changes the currently active tab to a new ATab asynchronously.
        When the animation ends, callback AOnFinish is called.
        
        Note: SetActiveTabWithTransitionAsync is required when working on Android."""
    def UpdateTabBarButtons(self, *args, **kwargs) -> Any:
        """Updates the state of the buttons in the area of the tab titles. 
        UpdateTabBarButtons calls the DoUpdateTabBarButtons method."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TabItem(TextControl):
    """TTabItem is a tab item in a TTabControl component. A TTabControl contains one or more TTabItem objects.
    The Text property can be used to define an accelerator key to the control."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoSize: bool
    """bool: Specifies whether TTabItem header (where the TabItem names appear) is auto-sized based on the length of the Text. 
        Set the AutoSize property to True to automatically resize the tab item header according to the length of the Text.
        Set the AutoSize property to False to lock autoresize of the TTabItem header.
        
        Tip:  The size of the TTabItem header readjusts when the Font property changes."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    CustomIcon: FixedMultiResBitmap
    """FixedMultiResBitmap: Specifies custom multi-resolution icons for the tab. This property is of the TFixedMultiResBitmap type. 
        A TFixedMultiResBitmap multi-resolution bitmap represents a collection of TFixedBitmapItem bitmap items displayed at different scales. You can create a multi-resolution bitmap with the MultiResBitmap Editor.
        Mobile applications need to have images of different scales defined for various devices, such as Retina and non-Retina iOS devices."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    ImageIndex: int
    """int: Defines the zero-based index enumerating images in the Images list of images.
        If you use a non-existing ImageIndex value to access an image in the Images list, then no image is retrieved and no exception is raised. The usual default value is -1. Call ImagesChanged when ImageIndex is changed."""
    Images: CustomImageList
    """CustomImageList: Defines the reference to a TCustomImageList list of images to be used to draw images on the component.
        If the TCustomImageList list is empty, then Images is nil/null.
        Call ImagesChanged when Images is changed."""
    Index: int
    """int: Specifies the index of the child object in the children array attached to this object."""
    IsSelected: bool
    """bool: Property that has the True value when the TTabItem object is selected.
        IsSelected is a property of TTabItem that has the Boolean value True if the tab item is selected. Otherwise, it has the Boolean value False."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowAsDot: bool
    """bool: If ShowAsDot is true, then the StyleLookup property has the value tabdotstyle."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabControl: TabControl
    """TabControl: Returns a TTabControl object that holds this tab page.
        
        
        Note: You cannot access this TTabControl using the TTabItem.Parent property."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Text: str
    '''str: Specifies the text that will be rendered over the surface of this TTextControl object.
        Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
        If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters.
        
        Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
        Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be "any string", but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.'''
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
        Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
        Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Trimming: TextTrimming
    """TextTrimming: Specifies the behavior of the text, when it overflows the area for drawing the text.
        Trimming may take the following values defined in the TTextTrimming type: None, Character, and Word.
        If the value of this property is not None and the text does not fit in the drawing area, then it is trimmed to fit the area and an ellipsis sign is printed after the trimmed text.
        
        Note: Under the iOS platform, Trimming works only when WordWrap = False."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of vertical alignment.
        The VertTextAlign property specifies how the TTextControl control displays the text in terms of vertical alignment. VertTextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a vertical axis, at the middle of the TTextControl object.
        Leading--aligns the text on a vertical axis, at the topmost position inside the TTextControl object.
        Trailing--aligns the text on a vertical axis, at the bottommost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that VertTextAlign corresponds to VertAlign."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether the text inside the TTextControl object wraps when it is longer than the width of the control.
        Set WordWrap to True to allow the TTextControl control to display multiple lines of text. When WordWrap is True, text that is too long for the TTextControl object wraps at the right margin and continues in additional lines.
        Set WordWrap to False for the text to span onto a single line of the TTextControl. However, in this case, the text that is too long for TTextControl appears truncated.
        The default value for the WordWrap property is False."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TTabItem.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.TabControl.TTabItem.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.TabControl.TTabItem.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetTabList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Text(Control):
    """TText defines 2D text objects. It inherits TControl and can be used in styles to construct controls.
    TText implements the ITextSettings interface. Therefore, TText objects provide all declared in ITextSettings methods and properties to manage the text appearance parameters declared in TTextSettings."""
    __hash__: ClassVar[None] = ...
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoSize: bool
    """bool: Specifies whether TText control is auto-sized based on the length of the text.
        Set the AutoSize property to True to automatically resize the TText control according to the length of the Text.
        Set the AutoSize property to False to lock autoresize of the TText control.
        
        Tip:  The size of the TText control readjusts when the Font property changes.
        When both AutoSize and WordWrap are set to True, the height of the TText control increases to show the full text, while the width does not change.
        When AutoSize is set to True and WordWrap is False the width of the TText control changes to display the text in one line, while the height does not change."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Color: int
    """int: Specifies the color of the Text.
        Use Color to set and get the color used to display Text within TText."""
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    HorzTextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The HorzTextAlign property specifies how the TText control will display the text in terms of horizontal alignment. HorzTextAlign can have one of the following values:
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TText control.
        Leading--aligns the text on a horizontal axis, at the topmost position inside the TText control.
        Trailing--aligns the text on a horizontal axis, at the bottommost position inside the TText control."""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    PrefixStyle: PrefixStyle
    '''PrefixStyle: It determines the way to portray a single character, such as "&".'''
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    Stretch: bool
    """bool: Specifies whether the text in the control will be displayed as stretched over the entire client area.
        Set the Stretch property to True to display the text stretched over the entire client area of the TText control. Set the Stretch property to False to display the text normally, without the stretch effect. The default value for the Stretch property is False.
        
        Tip: Setting the Stretch property to True cancels the effect of the WordWrap property."""
    Text: str
    """str: Specifies the text that will be displayed in the TText control.
        The Text property sets or reads the text that is displayed by the TText control. Text is a string."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Trimming: TextTrimming
    """TextTrimming: Specifies the behavior of the text, when it overflows the area for drawing the text.
        Trimming may take the following values defined in the TTextTrimming type: None, Character, and Word.
        If the value of this property is not None and the text does not fit in the drawing area, then it is trimmed to fit the area and an ellipsis sign is printed after the trimmed text.
        
        Note: For Android and iOS platforms, Trimming works only when WordWrap = False."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of vertical alignment.
        The VertTextAlign property specifies how the TText control will display the text in terms of vertical alignment. VertTextAlign can have one of the following values:
        
        Center (default)--aligns the text on a vertical axis, at the middle of the TText control.
        Leading--aligns the text on a vertical axis, at the topmost position inside the TText control.
        Trailing--aligns the text on a vertical axis, at the bottommost position inside the TText control."""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    WordWrap: bool
    """bool: Specifies whether the text inside the TText control wraps when it is longer than the width of the control.
        Set WordWrap to True to allow the TText control to display multiple lines of text. When WordWrap is True, text that is too long to fit in the TText control wraps at the right margin and continues in additional lines.
        Set WordWrap to False for the text to span onto a single line of the TText control. However, in this case, the text that is too long to fit in the TText control appears truncated."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        FMX.Objects.TText.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
        Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TText.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Objects.TText.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Objects.TText.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TextControl(StyledControl):
    """Base class for all text controls such as TDateEdit.
    TTextControl is the base class for all graphical controls that display text, such as TTimeEdit, TListBoxItem, TTabItem, and so on.
    TTextControl encapsulates standard functionality to manipulate the displayed text, offering the possibility of changing the font, the alignment of the text, or enabling word wrapping.
    If you need to create a new control from scratch that displays text (for instance, an enhanced label graphical control or a custom redesigned check box control), then you should derive your component from TTextControl.
    TTextControl implements the ITextSettings interface. This interface provides methods and properties to manage the most common text representation properties of general text objects independently of the particular types of these objects. TTextControl and its descendants contain the public property TextSettings of the TTextSettings type. Using the methods and the properties declared in the ITextSettings interface, you can manage the text representation TFont.Family, TFont.Size, TFont.Style, FontColor, HorzAlign, VertAlign, Trimming, and WordWrap properties defining visual parameters of the text representation. For more information, see Setting Text Parameters in FireMonkey.
    TTextControl uses the TTextSettingsInfo service class to manage sets of styled text representation properties stored in the DefaultTextSettings, TextSettings, StyledSettings, and ResultingTextSettings properties.
    TTextControl implements the IAcceleratorKeyReceiver interface to allow the use of this control as an accelerator key receiver."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DefaultTextSettings: TextSettings
    """TextSettings: Stores a TTextSettings type object keeping the default values of the text representation properties.
        DefaultTextSettings is set during the loading of the style in the ApplyStyle method. 
        DefaultTextSettings is initialized in Create with the following values: 
        
        Font.Size := 11 ;          // depends on the platform     
        Font.Family = 'Tahoma';    // depends on the platform
        Font.Style := [] ;
        FontColor := TAlphaColorRec.Black;
        TextAlign := TTextAlign.Leading;
        VertTextAlign := TTextAlign.Center;
        Trimming := TTextTrimming.None;
        WordWrap := False;"""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    FontColor: int
    """int: Specifies the font color of the text in this TTextControl control.
        Use the FontColor property to read or change the font color of the text in this TTextControl control. The default value of the FontColor property is TAlphaColorRec.Black."""
    PrefixStyle: PrefixStyle
    """PrefixStyle: Determines whether the ampersand character (&) is considered as a special prefix character.
        The default value is TPrefixStyle.HidePrefix, which means that the (first) ampersand is hidden at run-time."""
    ResultingTextSettings: TextSettings
    """TextSettings: Keeps final values of text representation properties. These values are really used to draw texts in a control. 
        ResultingTextSettings keeps a TTextSettings object that manages the final values of the text representation properties. These values are really used to draw texts in a control. 
        To obtain values stored in ResultingTextSettings, a control uses the StyledSettings property. For example, if StyledSettings contains the TStyledSetting.Family value, then the TFont.Family value is taken from the DefaultTextSettings. (That is the font family name defined in the loaded style is used. The font family name defined by the programmer in the Object Editor is ignored.) Oppositely, if StyledSettings does not contain TStyledSetting.Family, then the font family name defined by the programmer in the Object Editor is used and the font family name defined in the loaded style is ignored.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        RecalculateTextSettings updates the ResultingTextSettings."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    Text: str
    '''str: Specifies the text that will be rendered over the surface of this TTextControl object.
        Set the Text property to specify the text that will be displayed by this TTextControl. Text can be any string.
        If there are any effects already applied before changing the Text property, they will be preserved for the new text. Also, the surface of this TTextControl is repainted.
        In the Text property you can define an accelerator key. On Windows platforms, an accelerator key is shown as an underlined letter. To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character. The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save button, type &Save. On Windows platforms, accelerator keys enable the user to access controls pressing Alt+<accelerator_letter> key combination. When run on not Windows platforms, a single ampersand is simply stripped from the text. To show a single ampersand & character in a Text property specify doubled ampersand && characters.
        
        Tip:  If you specify a new text string that is exactly the same as the one already displayed, the effects will not be re-updated and this TTextControl object will not be repainted.
        Note: FMX.ExtCtrls.TPopupBox.Text is not a writable property in the same way as FMX.Controls.TTextControl.Text. The FMX.ExtCtrls.TPopupBox.Text property cannot be "any string", but instead must be just one of the strings in the FMX.ExtCtrls.TPopupBox.Items property and, in this case, FMX.ExtCtrls.TPopupBox.ItemIndex is updated accordingly.'''
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
        Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
        Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Trimming: TextTrimming
    """TextTrimming: Specifies the behavior of the text, when it overflows the area for drawing the text.
        Trimming may take the following values defined in the TTextTrimming type: None, Character, and Word.
        If the value of this property is not None and the text does not fit in the drawing area, then it is trimmed to fit the area and an ellipsis sign is printed after the trimmed text.
        
        Note: Under the iOS platform, Trimming works only when WordWrap = False."""
    VertTextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of vertical alignment.
        The VertTextAlign property specifies how the TTextControl control displays the text in terms of vertical alignment. VertTextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a vertical axis, at the middle of the TTextControl object.
        Leading--aligns the text on a vertical axis, at the topmost position inside the TTextControl object.
        Trailing--aligns the text on a vertical axis, at the bottommost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that VertTextAlign corresponds to VertAlign."""
    WordWrap: bool
    """bool: Specifies whether the text inside the TTextControl object wraps when it is longer than the width of the control.
        Set WordWrap to True to allow the TTextControl control to display multiple lines of text. When WordWrap is True, text that is too long for the TTextControl object wraps at the right margin and continues in additional lines.
        Set WordWrap to False for the text to span onto a single line of the TTextControl. However, in this case, the text that is too long for TTextControl appears truncated.
        The default value for the WordWrap property is False."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        FMX.Controls.TTextControl.AfterConstruction inherits from System.TObject.AfterConstruction. All content below this line refers to System.TObject.AfterConstruction.
        Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Change(self, *args, **kwargs) -> Any:
        """Calls DoChanged when any of the styled text representation properties of the current TTextControl control is changed.
        Change is called when any of the Font, FontColor, VertTextAlign, Trimming or WordWrap properties is changed. 
        If the control is not in a loading or destroying state (csLoading or csDestroying), Change calls DoChanged to update the representation of the text on the control."""
    def Create(self, AOwner: Component) -> None:
        """TTextControl.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Controls.TTextControl.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Disposes of the component and its owned components.
        FMX.Controls.TTextControl.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def ToString(self, *args, **kwargs) -> Any:
        """Returns a string containing the class name followed by the text that is rendered over the surface of this TTextControl object.
        ToString returns a string containing the concatenation of two substrings:
        
        The first substring contains the class name of the instance that is being called (retrieved by TObject.ToString). For example, calling  on a TCheckBox instance returns a substring containing TCheckBox.
        The second substring contains the text from the Text property. This is the text that will be rendered over the surface of the object in which ToString is called."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Thumb(StyledControl):
    """Represents a thumb control for use with track bars."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsPressed: bool
    """bool: Specifies the state of this thumb component (pressed or unpressed).
        Use the IsPressed property to specify the status of this thumb (pressed - True; unpressed - False)."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TThumb.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.StdCtrls.TThumb.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def GetDefaultTouchTargetExpansion(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def MouseDown(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TThumb.MouseDown(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseDown event dispatcher. 
        FMX.StdCtrls.TThumb.MouseDown inherits from FMX.Controls.TControl.MouseDown. All content below this line refers to FMX.Controls.TControl.MouseDown.
        OnMouseDown event dispatcher. 
        A control calls MouseDown in response to any of mouse-down messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively:
        
        Button determines which mouse button is pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the user pressed the mouse button.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control. If Button is mbLeft, MouseDown sets PressedPosition as a TPointF(X,Y).
        Override the protected MouseDown method to provide other responses when a mouse button is down while the cursor is over the control."""
    def MouseMove(self, Shift: ShiftState, X: float, Y: float) -> None:
        """TThumb.MouseMove(Shift: ShiftState, X: float, Y: float) -> None
        OnMouseMove event dispatcher. 
        FMX.StdCtrls.TThumb.MouseMove inherits from FMX.Controls.TControl.MouseMove. All content below this line refers to FMX.Controls.TControl.MouseMove.
        OnMouseMove event dispatcher. 
        As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control's visual representation:
        
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the mouse cursor is over the control.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseMove method to provide other responses when the mouse cursor moves over the control."""
    def MouseUp(self, Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None:
        """TThumb.MouseUp(Button: MouseButton, Shift: ShiftState, X: float, Y: float) -> None
        OnMouseUp event dispatcher. 
        FMX.StdCtrls.TThumb.MouseUp inherits from FMX.Controls.TControl.MouseUp. All content below this line refers to FMX.Controls.TControl.MouseUp.
        OnMouseUp event dispatcher. 
        A control calls MouseUp in response to any of mouse-up messages, decoding the message parameters into the shift-key state and position, which it passes in the Shift, X and Y parameters, respectively: 
        
        Button determines which mouse button was previously pressed: left, right, or middle.
        Shift indicates which shift keys--SHIFT, CTRL, ALT, and CMD (only for Mac)--were down when the pressed mouse button is released.
        X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
        Override the protected MouseUp method to provide other responses when the mouse button previously pressed is released while the cursor is over the control."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TimeColumn(DateTimeColumnBase):
    """Represents a column in a grid, whose cells use an editor similar to TTimeEdit  to edit cells in this column.
    A really used editor depends on implementation of the styled presentation class of TCustomGrid. For example, see TStyledGrid."""
    __hash__: ClassVar[None] = ...
    Controls: Any
    """Returns an iterator over contained controls"""
    ControlsCount: Any
    """Returns the count of contained controls"""
    IsFocused: Any
    """Determines whether the control has input focus."""
    Position: Any
    """Returns an access to the position of the control inside its parent"""
    Visible: Any
    """Returns/Sets the Control Visibility"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AbsoluteToLocal(self) -> Any:
        """TControl.AbsoluteToLocal()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CanFocus(self) -> Any:
        """TControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TTimeColumn.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Grid.TTimeColumn.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def LocalToAbsolute(self) -> Any:
        """TControl.LocalToAbsolute()
        Translates a given point from client area coordinates to global screen coordinates."""
    def PrepareForPaint(self) -> Any:
        """TControl.PrepareForPaint()
        Prepares the current control for painting."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ResetFocus(self) -> Any:
        """TControl.ResetFocus()
        Removes the focus from a control of from any children of the control."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetFocus(self) -> Any:
        """TControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TimeEdit(CustomTimeEdit):
    """Wrapper for Delphi TTimeEdit"""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the font to use when rendering the text.
        Set Font to specify the font to use when rendering the text. To change to a new font, specify a new TFont object. To modify a font, change the value of the Family, Size, or Style of the TFont object."""
    FontColor: int
    """int: Specifies the font color of the text in this TTextControl control.
        Use the FontColor property to read or change the font color of the text in this TTextControl control. The default value of the FontColor property is TAlphaColorRec.Black."""
    Format: str
    """str:"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    IsChecked: bool
    """bool:"""
    IsEmpty: bool
    """bool:"""
    KeyboardType: VirtualKeyboardType
    """VirtualKeyboardType:"""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCheckChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClosePicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnOpenPicker: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    ReadOnly: bool
    """bool:"""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowCheckBox: bool
    """bool:"""
    ShowClearButton: bool
    """bool:"""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    StyledSettings: StyledSettings
    '''StyledSettings: Defines the set of styled text representation properties whose values are loaded from the current style and cannot be changed manually. 
        Text representation properties are used as parameters for drawing texts in controls.
        The StyledSettings property is used in FMX controls such as TButton, TSpeedButton, TCheckBox, and others.
        Styles, for example Metropolis UI styles, define the default values of the text representation properties like font name, font size, word-wrapping, and others.
        The TTextSettings class define properties keeping values of the FontColor, TextAlign, VertTextAlign, Trimming,  WordWrap, and Font (TFont.Family, TFont.Size, TFont.Style) elements defining visual parameters of a text representation.
        StyledSettings can contain the Family, Size, Style, FontColor, and 
        Other values defined in TStyledSetting. The "Relation between TStyledSetting constants and TTextSettings properties" table shows which of the  TStyledSetting constants control the handling of these TTextSettings text representation properties.
        Keep in mind that the values of all styled text representation properties listed in the StyledSettings are taken from a style and cannot be changed manually. For example, if you set a new value of the FontColor property of a TTextControl control, then the real updating of the font color takes place only if the StyledSettings property of this control does not contain TStyledSetting.FontColor. For more details, see the example in Setting Text Parameters in FireMonkey.
        To switch OFF a font property for a control, select the control in the Form Designer. In the Object Inspector, expand the StyledSettings property. Clear the check mark before the property. For example, the following figure shows a TButton control with Size turned OFF (for Button1) and ON (for Button2):
        
        With StyledSettings you can also use the DefaultStyledSettings constant that defines the values of the styled properties that are taken from a style by default.
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control.'''
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TextAlign: TextAlign
    """TextAlign: Specifies how the text will be displayed in terms of horizontal alignment.
        The TextAlign property specifies how the TTextControl object will display the text in terms of horizontal alignment. TextAlign can have one of the following values (defined in TTextAlign):
        
        Center (default)--aligns the text on a horizontal axis, at the middle of the TTextControl object.
        Leading--aligns the text on a horizontal axis, at the leftmost position inside the TTextControl object.
        Trailing--aligns the text on a horizontal axis, at the rightmost position inside the TTextControl object.
        When you use text representation properties stored in ITextSettings.TextSettings, remember that TextAlign corresponds to HorzAlign."""
    TextSettings: TextSettings
    """TextSettings: Keeps the values of styled text representation properties that are set in the Object Inspector or programmatically.
        TextSettings references a TTextSettings type object that handles values of styled text representation properties that are set in the Object Inspector or programmatically. TextSettings references a TTextSettings type object, which handles  styled text representation properties to be used for drawing texts in this control. 
        TTextSettings type objects provide all styled text representation properties and methods to manage them.
        The styled text representation properties are 
        FontColor, TextAlign,
        VertTextAlign,
        Trimming, WordWrap, and Font (TFont.Family, TFont.Size, and TFont.Style).
        TTextSettings objects provide both styled text representation properties, whose values are loaded from a style (specified in StyledSettings), so all other styled text representation properties, whose values can be set manually, and methods to manage these text representation properties. The text representation properties identified in StyledSettings are loaded from the style and cannot be set manually. 
        Remember that the HorzAlign and VertAlign text representation properties stored in the TextSettings property of a control correspond to the TextAlign and 
        VertTextAlign properties of the control."""
    Time: float
    """float:"""
    TimeFormatKind: DTFormatKind
    """DTFormatKind:"""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    UseNowTime: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Timer(FmxObject):
    """Wrapper for Delphi TTimer"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Enabled: bool
    """bool:"""
    Interval: int
    """int:"""
    OnTimer: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TTimer.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        FMX.Types.TFmxObject.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        FMX.Types.TFmxObject.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ToolBar(StyledControl):
    """Represents a toolbar component for use in FireMonkey forms.
    The toolbar is usually aligned at the top of a form, and has a bunch of buttons that represent shortcuts or ways to access the functionality embedded into your application. A toolbar holds essentially speed buttons, but any other FireMonkey control can sit inside a toolbar. All tool buttons on a toolbar should maintain a uniform width and height for consistency.
    Typically, the tool buttons correspond to items in an application's menu and give the user more direct access to the application's commands, but they can access other functionality implemented into your application."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TintColor: int
    """int: Allows you to apply a tint to a toolbar. 
        This property is a value of the TAlphaColor type.
        
        Note: Currently, the TintColor property is only available for mobile platforms (iOS and Android). For more information, see Using Styled and Colored Buttons on Target Platforms."""
    TintObject: IintedObject
    """IintedObject: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TToolBar.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TToolBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Touch:
    """wrapper for Delphi FMX TTouch type"""
    __hash__: ClassVar[None] = ...
    Location: Any
    """Provides access to the location of a touch"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Track(CustomTrack):
    """Is a TCustomTrack with a set of published properties.
    TTrack publishes a set of properties from the TCustomTrack base component, but is not registered to the Tool Palette, so it cannot be added directly to a FireMonkey form.
    You can derive your own custom track bar component from TTrack."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Frequency: float
    """float: Specifies the number of positions the slider advances with each move.
        Use the Frequency property to specify how many steps at once the slider advances with each move. For instance, if you set Frequency to 10, Min to 0, and Max to 100, then there are only 10 steps for this slider to move within the 0 to 100 range; Value is incremented or decremented with 10 divisions.
        Frequency is a floating-point Single value; setting Frequency to 0 enables this track bar to increment or decrement by 0.01 divisions by step. Setting Frequency to any integer value (for instance 1, or 5, and so on) will enable this track bar to increment or decrement by the specified value.
        However, please take into consideration that if you set Frequency to any value greater than 0 and you try to programmatically assign a value to Value, then your value will be converted to the nearest multiple of Frequency.
        For instance, setting Frequency to 5 and then attempting to programmatically set Value to 12 will actually set Value to 10.
        
          MyTrackBar.Frequency := 5;
          MyTrackBar.Value := 12; { actually sets Value to 10 }
        
          MyTrackBar->Frequency = 5;
          MyTrackBar->Value = 12; /* actually sets Value to 10 */"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Max: float
    """float: Specifies the maximum value of this track bar for the maximum position of the slider.
        Use the Max property to set a maximum value up to which the slider of this track bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100."""
    Min: float
    """float: Specifies the minimum value of this track bar, for the minimum position of the slider.
        Use the Min property to set a minimum value down to which the slider of this track bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Orientation: Orientation
    """Orientation: Specifies the orientation of this track bar (from left to right or from bottom to top).
        Use the Orientation property to specify how this track bar will be displayed in terms of left-to-right orientation or bottom-to-top orientation. Orientation can have one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        Vertical
        
        
        
        The track bar is rendered with the bottom-to-top orientation.
        
        
        
        
        Horizontal
        
        
        
        The track bar is rendered with the left-to-right orientation."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Tracking: bool
    '''bool: Indicates whether thumb tracking is active or not. The default value of Tracking is True.
        The following table shows how the value of Tracking impacts the behavior of a track bar and the related events:
        
        
        
        Tracking
        
        Scenario
        
        Behaviour
        
        Events fired
        
        IsTracking
        
        
        
        True or False
        
        
        
        Press an arrow key on the keyboard.
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each "step" of the movement:
        
        OnTracking
        OnChange
        
        
        True
        
        
        
        
        False
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each step of the movement:
        
        OnTracking
        After you release the Thumb
        
        OnChange
        
        
        True
        
        
        
        
        True
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        False
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True or False
        
        
        
        Hold the Shift button and click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False'''
    Value: float
    """float: Specifies the current value of this track bar.
        Set or get Value to specify or obtain the current value of this track bar. You can set Value programmatically or visually at run time, with any value within the interval delimited by Min and Max."""
    ViewportSize: float
    """float: Specifies the size, in pixels, of the area that the slider cannot span to the left or right of this track bar.
        Use the ViewportSize property to specify the size of the view port of this track bar, that is, the area, in pixels, that the slider of this track bar cannot span. As an example, the picture below shows two track bars, one with ViewportSize set to 0 and the other with ViewportSize set to 50.
        
        
        Tip: Changing the ViewportSize property does not affect the limits (Min or Max) or the Value of this track bar."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TrackBar(CustomTrack):
    """Represents a general-purpose track bar for use in applications where tracking is required.
    TTrackBar represents a FireMonkey styled track bar that can be used for various types of tracking operations; for instance, it is useful for adjusting properties such as color, volume, and brightness. Move the slide indicator by dragging it to a particular location or click in the bar to change its Value. Adjust this track bar's view port by affecting the value of the ViewportSize property.
    
    Use the Max and Min properties to set the upper and lower range of the track bar. The Orientation property determines whether this track bar is vertical or horizontal."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action allows an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        If an object of the descendant from the TFmxObject class does not support actions, and when this object tries to assign a value to the Action property, the setter method for Action calls GetActionLinkClass that should return nil. In this case, attempting to set a value to the Action property raises the following exception: 
        
        StrEActionNoSuported = 'Class %s does not support the action'"""
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    CanFocus: bool
    """bool: Specifies whether the current control can receive focus. 
        CanFocus is True if it can receive focus, and False otherwise.
        If it is set to False, the control cannot be selected when using the TAB key.
        A control can receive focus after it is created."""
    CanParentFocus: bool
    """bool: Specifies whether the parent of this control should be evaluated to receive focus.
        CanParentFocus is True when the parent of this control should be evaluated to receive focus if this control cannot receive focus itself, and False otherwise."""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    ControlType: ControlType
    """ControlType:"""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableFocusEffect: bool
    """bool: Specifies whether the control has the focus effect disabled.
        Set DisableFocusEffect to True so the control disables the effect applied when it receives focus. Usually, DisableFocusEffect for FireMonkey controls is False."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Frequency: float
    """float: Specifies the number of positions the slider advances with each move.
        Use the Frequency property to specify how many steps at once the slider advances with each move. For instance, if you set Frequency to 10, Min to 0, and Max to 100, then there are only 10 steps for this slider to move within the 0 to 100 range; Value is incremented or decremented with 10 divisions.
        Frequency is a floating-point Single value; setting Frequency to 0 enables this track bar to increment or decrement by 0.01 divisions by step. Setting Frequency to any integer value (for instance 1, or 5, and so on) will enable this track bar to increment or decrement by the specified value.
        However, please take into consideration that if you set Frequency to any value greater than 0 and you try to programmatically assign a value to Value, then your value will be converted to the nearest multiple of Frequency.
        For instance, setting Frequency to 5 and then attempting to programmatically set Value to 12 will actually set Value to 10.
        
          MyTrackBar.Frequency := 5;
          MyTrackBar.Value := 12; { actually sets Value to 10 }
        
          MyTrackBar->Frequency = 5;
          MyTrackBar->Value = 12; /* actually sets Value to 10 */"""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    Max: float
    """float: Specifies the maximum value of this track bar for the maximum position of the slider.
        Use the Max property to set a maximum value up to which the slider of this track bar can go. For instance, if Max is set to 100 (a default value), then attempting to move the slider to the maximum will result in a Value of 100."""
    Min: float
    """float: Specifies the minimum value of this track bar, for the minimum position of the slider.
        Use the Min property to set a minimum value down to which the slider of this track bar can go. For instance, if Min is set to 0 (a default value), then attempting to move the slider to the minimum will result in a Value of 0."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCanFocus: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnKeyUp: Any
    """Callable[[Object, int, unicodechr(str), ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Orientation: Orientation
    """Orientation: Specifies the orientation of this track bar (from left to right or from bottom to top).
        Use the Orientation property to specify how this track bar will be displayed in terms of left-to-right orientation or bottom-to-top orientation. Orientation can have one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        Vertical
        
        
        
        The track bar is rendered with the bottom-to-top orientation.
        
        
        
        
        Horizontal
        
        
        
        The track bar is rendered with the left-to-right orientation."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Tracking: bool
    '''bool: Indicates whether thumb tracking is active or not. The default value of Tracking is True.
        The following table shows how the value of Tracking impacts the behavior of a track bar and the related events:
        
        
        
        Tracking
        
        Scenario
        
        Behaviour
        
        Events fired
        
        IsTracking
        
        
        
        True or False
        
        
        
        Press an arrow key on the keyboard.
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each "step" of the movement:
        
        OnTracking
        OnChange
        
        
        True
        
        
        
        
        False
        
        
        
        Click on the Thumb of the track bar and move the Thumb.
        
        
        
        The Thumb moves as much as you move it.
        
        
        
        For each step of the movement:
        
        OnTracking
        After you release the Thumb
        
        OnChange
        
        
        True
        
        
        
        
        True
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves for one "step".
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        False
        
        
        
        Click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False
        
        
        
        
        True or False
        
        
        
        Hold the Shift button and click anywhere on the track bar (excluding the Thumb).
        
        
        
        The Thumb moves to the position where you click.
        
        
        
        OnTracking
        OnChange
        
        
        False'''
    Value: float
    """float: Specifies the current value of this track bar.
        Set or get Value to specify or obtain the current value of this track bar. You can set Value programmatically or visually at run time, with any value within the interval delimited by Min and Max."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Create(self, AOwner: Component) -> None:
        """TTrackBar.Create(AOwner: Component) -> None
        Creates a new instance of TPresentedControl.
        FMX.StdCtrls.TTrackBar.Create inherits from FMX.Controls.Presentation.TPresentedControl.Create. All content below this line refers to FMX.Controls.Presentation.TPresentedControl.Create.
        Creates a new instance of TPresentedControl.
        AOwner takes ownership of the control and becomes responsible of destroying the control once the control is no longer necessary.
        The control constructor creates a data model for the control. DefineModelClass determines the default class of data model for each subclass of TPresentedControl.
        Create also sets the value of the CanUseDefaultPresentation property to True.
        
         See Also
        System.Classes.TComponent.Create
        FMX.Controls.Presentation.TPresentedControl.Model
        FMX.Controls.Presentation.TPresentedControl.DefineModelClass
        FMX.Controls.Presentation.TPresentedControl.Destroy
        FMX.Controls.Presentation.TPresentedControl.CanUseDefaultPresentation"""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ValueRange(CustomValueRange):
    """Wrapper for Delphi TValueRange"""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Frequency: float
    """float: The step of possible Value variations.
        FMX.StdActns.TCustomValueRange.Frequency inherits from FMX.StdActns.TBaseValueRange.Frequency. All content below this line refers to FMX.StdActns.TBaseValueRange.Frequency.
        The step of possible Value variations. 
        Value can be multiple of Frequency, Min, or Max. For example, if
        
        Min = 0.1
        Max = 2.1
        ViewportSize = 0
        Frequency = 1
        
        then Value can be:
        
        0.1
        1
        2
        2.1
        
        but it cannot be:
        
        Value = 1.1"""
    Max: float
    """float: Maximum permissible value of the floating-point Value range.
        FMX.StdActns.TCustomValueRange.Max inherits from FMX.StdActns.TBaseValueRange.Max. All content below this line refers to FMX.StdActns.TBaseValueRange.Max.
        Maximum permissible value of the floating-point Value range."""
    Min: float
    """float: Minimum permissible value of the floating-point Value range.
        FMX.StdActns.TCustomValueRange.Min inherits from FMX.StdActns.TBaseValueRange.Min. All content below this line refers to FMX.StdActns.TBaseValueRange.Min.
        Minimum permissible value of the floating-point Value range."""
    RelativeValue: float
    """float: The Value-based position of the thumb in the scrollable control. 
        The RelativeValue property is calculated relatively to Value, according to the following expression:
        
        RelativeValue = (Value-Min)/(Max-Min-ViewportSize)
        
        It can be in the range from 0 through 1. It can be used for positioning a thumb in a scrollable control, whose parameters are defined by the ValueRange properties (Value, Min, Max, ViewportSize, and Frequency)."""
    Value: float
    """float: A changeable floating-point parameter.
        FMX.StdActns.TCustomValueRange.Value inherits from FMX.StdActns.TBaseValueRange.Value. All content below this line refers to FMX.StdActns.TBaseValueRange.Value.
        A changeable floating-point parameter. 
        The TBaseValueRange class associates a floating-point number Value to its Min and Max ranges."""
    ViewportSize: float
    """float: Used by controls such as TScrollBar to define the thumb size.
        FMX.StdActns.TCustomValueRange.ViewportSize inherits from FMX.StdActns.TBaseValueRange.ViewportSize. All content below this line refers to FMX.StdActns.TBaseValueRange.ViewportSize.
        Used by controls such as TScrollBar to define the thumb size. 
        Note that the effective maximum value of Value decreases according to Max - ViewportSize."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ValueRangeAction(CustomValueRangeAction):
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    AutoCheck: bool
    """bool: Controls whether the Checked property toggles when the action executes.
        AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
        If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client."""
    Checked: bool
    """bool: Indicates whether client controls and menu items appear checked.
        Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.
        
        Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
        Tip: Use the AutoCheck property to ensure that the action's Checked property toggles when the action executes."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    GroupIndex: int
    """int: Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
        The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
        When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.
        
        Note:  All actions in a group must be listed by the same action list."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Embarcadero Technologies does not currently have any additional information."""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    Text: str
    """str: Represents the caption of the action.
        Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action's clients.
        Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
        In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+<accelerator_letter> key combination.  To show a single ampersand & character in a Text property specify doubled ampersand && characters.  Notice that & and _ are seen and can be used only under Windows."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    ValueRange: CustomValueRange
    """CustomValueRange: Provides access to a floating-point value and its permitted ranges.
        ValueRange provides access to the Value, Min, Max, Frequency, ViewportSize, and
        RelativeValue properties and to the methods handling consistency of these properties."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class VarParameter:
    """Container object allowing modification of Delphi var parameters from Python"""
    __hash__: ClassVar[None] = ...
    Value: Any
    """Provides access to the Value associated with the Var parameter"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class VertScrollBox(CustomScrollBox):
    """Represents a TScrollBox restricted to vertical scrolling."""
    __hash__: ClassVar[None] = ...
    AdjustSizeValue: Any
    """Updates the width and height of this control according to its current style"""
    AdjustType: Any
    """Determines if and how the width and height of this control should be modified to take the fixed space dictated by the style of this control"""
    Align: AlignLayout
    """AlignLayout: Specifies the alignment options (top, left, client, and so on) of this control. 
        Use Align to automatically set the alignment of the current control. Setting Align to a value different than None can affect the  position, size (height and width), and anchors of the control. By default, Align is set to None.
        Descendants of TControl typically set the visibility and value for the Align property. For example, for TToolBar, Align defaults to TAlignLayout.Top.
        To see the possible values for Align and their visible effects over the control, see FMX.Types.TAlignLayout.  
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent. 
        Use Anchors to ensure that a control maintains its current position relative to the edges of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored. Anchors is enforced only when the parent control is resized.
        If a control is anchored to opposite edges at the same time, the control stretches horizontally or vertically to maintain constant the distance between the control edges and parent edges. If a control is anchored to all four edges of its parent, the control stretches in all directions. By default, a control is anchored to the top and left edges of its container (Anchors=[akTop,akLeft]).
        The automatic alignment may affect the anchors of a control. When Align is set to None, all the anchors are available. If Align is not None, the anchors affected by the automatic alignment are excluded. Changing the state of the anchors affected by the automatic alignment has no effect over the control.
        Controls that have the Align or Anchors properties set can use a Scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    AutoHide: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoTranslate: Any
    """Specifies whether the control's text should be translated"""
    ClipChildren: bool
    """bool: Specifies if children of the control should be clipped to the control's on-screen region.
        Set ClipChildren to 
        
        True if you want child controls to be clipped to the control's on-screen region.
        False if you want child controls to be able to extend beyond the region of the parent control."""
    ClipParent: bool
    """bool: Specifies whether the current control has clipped its parent. 
        When ClipParent is True, TControl cuts off the portion of the parent that lies under the control when the control is painted by the Paint and Painting methods. 
        Parts of the control that do not contain visible objects cut off holes in the parent's image.
        ClipParent is ignored in PaintChildren and other painting methods.
        If one parent has more that one child control having ClipParent equals True, then only one of these child controls is painted with ClipParent equals True. Others child controls are painted as if ClipParent equals False."""
    Content: ScrollContent
    """ScrollContent: Keeps an object that represents a scrollable content.
        A TScrollBox object uses a TScrollContent object in order to provide an area onto which you can place any other graphical components. Content keeps this TScrollContent object."""
    Cursor: int
    """int: Image to use to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. For a list of cursor constants, see System.UITypes Constants. The image representations of the cursor depend on the theme active on the current platform.
        If Cursor is set to the default cursor, this control might display a different cursor when the mouse pointer is over it. The actual cursor that this control displays is the cursor defined in InheritedCursor, a read-only property that is calculated based not only in the value of Cursor in this control, but also the value of Cursor in any ancestor of this control (parent, grand-parent, and so on until the parent form)."""
    DefaultStyleLookupName: Any
    """Returns a string with the name of the default style of this control"""
    DisableMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic."""
    EnableDragHighlight: bool
    """bool: Specifies whether the control is highlighted when the dragged object is over it."""
    Enabled: bool
    """bool: Specifies whether the control responds to mouse, keyboard, and timer events. 
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        This property applies to all TControl descendants."""
    Height: float
    """float: Height specifies the vertical size of the control (in dp).
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: Contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm Help file, you must symbolically map Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set the HelpType property to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        If HelpType is htContext, the HelpContext property value identifies the control's Help topic. 
        If HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic."""
    Hint: str
    """str: Specifies the text string that appears when the user moves the mouse over a control. 
        See Using Hints to Show Contextual Help in a FireMonkey Application for more information about hints."""
    HitTest: bool
    """bool: Enables the control to capture mouse events.
        
        If you set HitTest to True, this control captures all mouse events. The example below shows the use of HitTest for an OnClick event.
        If you set HitTest to False, the mouse events will pass through this control, so that a control laid out behind this one receives the mouse events instead of this control.
        Note:  The HitTest enables all mouse-related events, which also include the display of Hints and Hint-related events.
        For most controls, HitTest is True by default. However, this is not true for all the controls. For example, for TLabel and TPathLabel, HitTest is False by default; these two controls do not capture the mouse-related events unless you set HitTest to True.
        
        Example of HitTest
        1. On a form, place a TPanel component.
        2. Inside the panel, place a TPathLabel component.
        3. Implement the OnClick event for both the TPanel and the TPathLabel:
        
        procedure TForm1.Panel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPanel');
        end;
        
        procedure TForm1.PathLabel1Click(Sender: TObject);
        begin
          ShowMessage('OnClick event fired for TPathLabel');
        end;
        
        4. Set the TPathLabel HitTest property to False (this is the default setting). Run the application and click the label. The OnClick event is fired for the panel (not the label).
        5. Set the TPathLabel HitTest property to True. Run the application and click the label. The OnClick event is fired for the TPathLabel."""
    Locked: bool
    """bool: Specifies whether the control is locked at design time. 
        A locked control prohibits to move the control at design time, all the other properties can be modified at design time.
        To lock the control, set Locked to True. 
        By default, Locked is False, and the control can be modified at design time."""
    Margins: Bounds
    """Bounds: Aligns the component to the margins points of other components. 
        The Margins of a control are the distances (in pixels) from each edge (top, left, bottom, right) to another control within the same Parent or to the edge of its Parent.  The Margins add space to the outer side of the control. It only applies for controls that do not use TAlignLayout None and the components are located to each other.
        If a margin is not 0, no other control will come closer to the control than the specified distance. If the distance from a Parent edge to the corresponding control edge is smaller than the specified Margins for that edge, the control is repositioned and resized, if necessary, to maintain the specified distance. 
        If the Margins control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Margins values. It only applies to the IDE control's guidelines, when you are dragging control. But if you use Align=Client (for example), it will use the specified values in Margins.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls."""
    OnApplyStyleLookup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCalcContentBounds: Callable[[Object,RectF],None]
    """Callable[[Object, RectF], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragEnd: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragEnter: Callable[[Object,DragObject,PointF],None]
    """Callable[[Object, DragObject, PointF], None]:"""
    OnDragLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragOver: Callable[[Object,DragObject,PointF,DragOperation],None]
    """Callable[[Object, DragObject, PointF, DragOperation], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,float,float],None]
    """Callable[[Object, ShiftState, float, float], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,float,float],None]
    """Callable[[Object, MouseButton, ShiftState, float, float], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,bool],None]
    """Callable[[Object, ShiftState, int, bool], None]:"""
    OnPaint: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnPainting: Callable[[Object,Canvas,RectF],None]
    """Callable[[Object, Canvas, RectF], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnVScrollChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnViewportPositionChange: Callable[[Object,PointF,PointF,bool],None]
    """Callable[[Object, PointF, PointF, bool], None]:"""
    Opacity: float
    """float: Specifies the control opacity. 
        Set Opacity to customize the transparency of the current control.
        Opacity takes values between 0 and 1. If Opacity is 1, the control is completely opaque; if it is 0, the control is completely transparent. The values over 1 are treated as 1, and the ones under 0 are treated as 0.
        Opacity applies to the control's children."""
    Padding: Bounds
    """Bounds: Aligns the component to the padding points of other components. 
        The Padding of a control specifies how close, in pixels, the control's children can come to each of its edges (top, left, bottom, right). Padding adds space to the inner side of the control.
        The control's children are repositioned and resized, if necessary, to maintain the Padding. 
        If the Padding control has zero values, RAD Studio uses the default values (Left=4, Top=4, Right=4, Bottom=4). You can also set your own Padding values.
        The following image shows how Padding and Margins properties affect alignment, position, and size of controls.
        
        
        Note: Padding constraints do not work for TScrollBox, TListBox, TTreeView, and TGrid based controls."""
    ParentShowHint: bool
    """bool: If True, the value of the ShowHint property of this control inherits the value of the ShowHint property of the parent control.
        See Using Hints to Show Contextual Help in a FireMonkey Application - Enabling Hints for a Control for more information."""
    PopupMenu: CustomPopupMenu
    """CustomPopupMenu: Specifies the context (pop-up) menu object. 
        Use PopupMenu to set the context menu of the current control. The pop-up window is displayed when ShowContextMenu is called."""
    Position: Position
    """Position: Aligns the component to the position points of other components (Bounds points).
        Specifies the upper-left corner of the current control, relative to its parent. 
        The Position can be affected by the Padding of its parent and the Margins of the control."""
    RotationAngle: float
    """float: Specifies the amount (in degrees) by which the control is rotated from the x-axis. 
        Positive angles correspond to clockwise rotation. For counterclockwise rotation, use negative values.
        To set the rotation center, use RotationCenter."""
    RotationCenter: Position
    """Position: Specifies the position of the pivot point of the control.
        The coordinates of the rotation center take values in the range from 0 through 1. The point with the coordinates (0,0) corresponds to the upper-left corner of the control, the point with the coordinates (1,1) corresponds to the lower-right corner of the control. The default center of rotation is (0.5, 0.5).
        Values outside of [0,0] and [1,1] can be clipped in some descendant classes.
        To set the rotation angle, use RotationAngle."""
    Scale: Position
    """Position: Specifies the scale of the control.
        Set the Scale coordinates to specify the scale on each axis.
        The initial scale rate is 1 on each axis.
        
        Note:  Controls that have the Align or Anchors properties set can use a scale that is different from the default (1,1), so that controls align together even when they have a custom scale."""
    ShowHint: bool
    """bool: Specifies whether the Hint can be shown. 
        If ShowHint is set to True, a Hint string is displayed when the user moves the mouse over the control."""
    ShowScrollBars: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ShowSizeGrip: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Size: ControlSize
    """ControlSize: Specifies the vertical and horizontal size (Size.Height and Size.Width) of the control (in pixels).
        Use the Size property to read or change the size of the control."""
    StyleLookup: Any
    """Specifies the name of the resource object to which the current TStyledControl is linked"""
    StyleState: Any
    """This property allows you to define the current state of style"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child controls are visited when the user presses the TAB key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. 
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that ensures that the control is the last in the tab order."""
    TabStop: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    TouchTargetExpansion: Bounds
    """Bounds: Set of optional pixel values you can specify to expand the touch target of a FireMonkey styled control.
        FMX.Controls.TControl.TouchTargetExpansion is a published property of all FireMonkey styled controls that support Touch. 
        Defined as an  FMX.Types.TBounds, TouchTargetExpansion takes four optional parameters representing the expansion of the four sides of the control in pixels (Bottom, Left, Right, Top). Each parameter specifies the size of an additional screen area that is to be treated as part of the touch target of the control. 
        The following figure illustrates how TouchTargetExpansion expands the touch target for a FireMonkey control:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible."""
    Width: float
    """float: Specifies the horizontal size of the control (in pixels).
        Use the Width property to read or change the width of the control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyStyleLookup(self) -> Any:
        """TStyledControl.ApplyStyleLookup()
        Gets and applies the style of a TStyledControl."""
    def Inflate(self) -> Any:
        """TStyledControl.Inflate()
        Call this procedure to get and apply its style lookup."""
    def NeedStyleLookup(self) -> Any:
        """TStyledControl.NeedStyleLookup()
        Call this procedure to indicate that this control requires to get and apply its style lookup."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ViewAction(ObjectViewAction):
    """Shows a component stored in the FmxObject property.
    TViewAction standard action is executed by clients (controls, menu commands, toolbar buttons) linked to this action and it shows the TFmxObject type component stored in the FmxObject property. 
    TViewAction extends TCustomViewAction by redeclaring some public properties and events as having published visibility, which makes them editable in the Object Inspector. 
    The following properties are the most important: Enabled, FmxObject, ImageIndex, SecondaryShortCuts, ShortCut, Text, ShortCut, and Visible.  
    Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TViewAction, as the TCustomViewAction descendant, does not distribute changes in Visible, Enabled, Checked, GroupIndex, and OnExecute to the linked clients."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    FmxObject: FmxObject
    """FmxObject: Keeps an FMX object (of the component) that executes an action and whose image becomes visible during the execution of the action."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    OnAfterShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnBeforeShow: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnCreateComponent: Callable[[Object,Component],None]
    """Callable[[Object, Component], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    Text: str
    """str: Represents the caption of the action.
        Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action's clients.
        Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
        In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+<accelerator_letter> key combination.  To show a single ampersand & character in a Text property specify doubled ampersand && characters.  Notice that & and _ are seen and can be used only under Windows."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TViewAction.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TViewAction.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class VirtualKeyboard(ObjectViewAction):
    """Shows a component stored in the FmxObject property and shows the on-screen virtual keyboard over the surface of this component.
    TVirtualKeyboard standard action is executed by clients (controls, menu commands, toolbar buttons) linked to this action, and it shows the component stored in the FmxObject property. TVirtualKeyboard shows the on-screen virtual keyboard over the surface of the shown component. 
    TVirtualKeyboard extends TCustomViewAction by redeclaring some public properties and events as having published visibility, which makes them editable in the Object Inspector. 
    The following properties are the most important: Enabled, FmxObject, ImageIndex, SecondaryShortCuts, ShortCut, Text, ShortCut, and Visible. 
    Contrary to ordinary actions (like TAction, TControlAction, TCustomValueRangeAction, and so on) TVirtualKeyboard, as a descendant of TCustomViewAction, does not distribute changes of Visible, Enabled, Checked, GroupIndex, and OnExecute to the linked clients. 
    Virtual keyboard components are supported by so-called Platform Services. Therefore, this standard action might not be supported for some platforms. For more information, see UnsupportedArchitectures and UnsupportedPlatforms. 
    To display the on-screen keyboard provided by the TVirtualKeyboard component, do the following:
    
    Add a TActionList and a TButton to the form.
    Double-click the TActionList to open the Action List editor.
    Click the arrowhead beside the  icon, select New Standard Action > Edit > TVirtualKeyboard, and then click OK.
    In the Object Inspector, set the Action property of the TButton to be the TVirtualKeyboard you just added to the TActionList.
    Run the project.
    The type of the TVirtualKeyboard is set by the KeyboardType property.
    
    Code Examples
    FMX.ScrollableForm Sample
    FMX.KeyboardTypes Sample
    FMX.KeyboardToolbar Sample"""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    FmxObject: FmxObject
    """FmxObject: Keeps an FMX object (of the component) that executes an action and whose image becomes visible during the execution of the action."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    Text: str
    """str: Represents the caption of the action.
        Text holds the string that is used in the same way as the Caption of the action, when it is set. The value of Text is propagated to the action's clients.
        Text is the same as Caption. You can use both Text and Caption, but descendant classes should only use the published property Text, so that the Object Inspector displays only the Text property, as in most FireMonkey components. 
        In the Text property you can define an accelerator key.  On Windows platforms, an accelerator key is shown as an underlined letter.  To specify an accelerator key, precede an <accelerator_letter> with an ampersand & character.  The letter after the ampersand appears underlined. For example, to set the S character as an accelerator key for a Save action, type &Save.  On Windows platforms, accelerator keys enable the user to activate actions pressing Alt+<accelerator_letter> key combination.  To show a single ampersand & character in a Text property specify doubled ampersand && characters.  Notice that & and _ are seen and can be used only under Windows."""
    UnsupportedArchitectures: Architectures
    """Architectures: Defines the set of unsupported CPU architectures.
        The TArchitecture type defines the arIntelX86 and arIntelX64 constants that identify the processor architectures Intel x86 and Intel x64.
        Use UnsupportedArchitectures to identify sets of unsupported processor architectures."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TVirtualKeyboard.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TVirtualKeyboard.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def IsSupportedInterface(self, *args, **kwargs) -> Any:
        """Returns True if this action can be realized on the current platform.
        FMX.StdActns.TVirtualKeyboard.IsSupportedInterface inherits from FMX.ActnList.TCustomAction.IsSupportedInterface. All content below this line refers to FMX.ActnList.TCustomAction.IsSupportedInterface.
        Returns True if this action can be realized on the current platform.
        As implemented in TCustomAction, IsSupportedInterface always returns True. 
        IsSupportedInterface is virtual and can be overridden in descendent classes."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class WindowClose(SysCommonAction):
    """The standard action for closing an active modeless form. 
    TWindowClose is not immediate, it calls the Close method that closes the active modeless form. 
    The default ShortCut for TWindowClose is CMD+W."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    UnsupportedPlatforms: Platforms
    """Platforms: Defines the set of unsupported OS platforms.
        The TPlatform type defines the pfWindows, pfMacOS, pfiOS, pfAndroid,  and pfLinux constants that identify the Windows, Mac OS, Android, and other platforms.
        Use UnsupportedPlatforms to identify sets of unsupported OS platforms."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TWindowClose.Create(AOwner: Component) -> None
        Instantiates and initializes a FireMonkey TCustomAction object.
        FMX.StdActns.TWindowClose.Create inherits from FMX.ActnList.TCustomAction.Create. All content below this line refers to FMX.ActnList.TCustomAction.Create.
        Instantiates and initializes a FireMonkey TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action list component using New Action in the Action List editor at design time.
        If you want to create an action at run time, assign a TActionList component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create calls an inherited System.Actions.TContainedAction.Create constructor and then initializes the Supported property with True ."""
    def CustomTextChanged(self, *args, **kwargs) -> Any:
        """Introduces an interface for a function that is called when the CustomText property for the action changes.
        FMX.StdActns.TWindowClose.CustomTextChanged inherits from FMX.ActnList.TCustomAction.CustomTextChanged. All content below this line refers to FMX.ActnList.TCustomAction.CustomTextChanged.
        Introduces an interface for a function that is called when the CustomText property for the action changes.
        As implemented in TCustomAction, CustomTextChanged does nothing. 
        Descendant classes can override CustomTextChanged to provide business functionality.
        The announced purpose of this method is to update the Text property when the CustomText property is changed."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TWindowClose.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        FMX.StdActns.TWindowClose.ExecuteTarget inherits from System.Classes.TBasicAction.ExecuteTarget. All content below this line refers to System.Classes.TBasicAction.ExecuteTarget.
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TWindowClose.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        FMX.StdActns.TWindowClose.HandlesTarget inherits from System.Classes.TBasicAction.HandlesTarget. All content below this line refers to System.Classes.TBasicAction.HandlesTarget.
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

def Abort() -> Any:
    """Abort()
    Raises a silent exception."""
def CreateComponent(ComponentClass, Owner) -> Any:
    """CreateComponent(ComponentClass, Owner)
    Creates a component of type ComponentClass owned by Owner"""
def GetProcessDpiAwareness() -> Any:
    """GetProcessDpiAwareness()
    Get the DPI awareness of the process."""
def IsDpiAware(*args, **kwargs) -> Any:
    """IsDPIAware()
    Check for process DPI awareness."""
def SetHighDpiAware() -> Any:
    """SetHighDpiAware()
    Automatically set the DPI awareness that best fits to the process."""
def SetProcessDpiAwareness() -> Any:
    """SetProcessDpiAwareness()
    Set the DPI awareness to the process."""
